var Al=Object.create;var{getPrototypeOf:Kl,defineProperty:os,getOwnPropertyNames:jl}=Object;var Nl=Object.prototype.hasOwnProperty;var Pl=(D,q,Y)=>{Y=D!=null?Al(Kl(D)):{};let H=q||!D||!D.__esModule?os(Y,"default",{value:D,enumerable:!0}):Y;for(let Q of jl(D))if(!Nl.call(H,Q))os(H,Q,{get:()=>D[Q],enumerable:!0});return H};var Vl=(D,q)=>()=>(q||D((q={exports:{}}).exports,q),q.exports);var rs=Vl((Os,Qs)=>{(function(D,q){typeof Os=="object"&&typeof Qs!="undefined"?Qs.exports=q():typeof define=="function"&&define.amd?define(q):(D=typeof globalThis!="undefined"?globalThis:D||self).graphology=q()})(Os,function(){function D(b){return D=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(g){return typeof g}:function(g){return g&&typeof Symbol=="function"&&g.constructor===Symbol&&g!==Symbol.prototype?"symbol":typeof g},D(b)}function q(b,g){b.prototype=Object.create(g.prototype),b.prototype.constructor=b,H(b,g)}function Y(b){return Y=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(g){return g.__proto__||Object.getPrototypeOf(g)},Y(b)}function H(b,g){return H=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(f,s){return f.__proto__=s,f},H(b,g)}function Q(){if(typeof Reflect=="undefined"||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(b){return!1}}function h(b,g,f){return h=Q()?Reflect.construct.bind():function(s,l,u){var E=[null];E.push.apply(E,l);var m=new(Function.bind.apply(s,E));return u&&H(m,u.prototype),m},h.apply(null,arguments)}function j(b){var g=typeof Map=="function"?new Map:void 0;return j=function(f){if(f===null||(s=f,Function.toString.call(s).indexOf("[native code]")===-1))return f;var s;if(typeof f!="function")throw new TypeError("Super expression must either be null or a function");if(g!==void 0){if(g.has(f))return g.get(f);g.set(f,l)}function l(){return h(f,arguments,Y(this).constructor)}return l.prototype=Object.create(f.prototype,{constructor:{value:l,enumerable:!1,writable:!0,configurable:!0}}),H(l,f)},j(b)}function W(b){if(b===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return b}var O=function(){for(var b=arguments[0],g=1,f=arguments.length;g<f;g++)if(arguments[g])for(var s in arguments[g])b[s]=arguments[g][s];return b};function A(b,g,f,s){var l=b._nodes.get(g),u=null;return l?u=s==="mixed"?l.out&&l.out[f]||l.undirected&&l.undirected[f]:s==="directed"?l.out&&l.out[f]:l.undirected&&l.undirected[f]:u}function P(b){return D(b)==="object"&&b!==null}function a(b){var g;for(g in b)return!1;return!0}function K(b,g,f){Object.defineProperty(b,g,{enumerable:!1,configurable:!1,writable:!0,value:f})}function d(b,g,f){var s={enumerable:!0,configurable:!0};typeof f=="function"?s.get=f:(s.value=f,s.writable=!1),Object.defineProperty(b,g,s)}function us(b){return!!P(b)&&!(b.attributes&&!Array.isArray(b.attributes))}typeof Object.assign=="function"&&(O=Object.assign);var i,ls={exports:{}},I=typeof Reflect=="object"?Reflect:null,v=I&&typeof I.apply=="function"?I.apply:function(b,g,f){return Function.prototype.apply.call(b,g,f)};i=I&&typeof I.ownKeys=="function"?I.ownKeys:Object.getOwnPropertySymbols?function(b){return Object.getOwnPropertyNames(b).concat(Object.getOwnPropertySymbols(b))}:function(b){return Object.getOwnPropertyNames(b)};var Z=Number.isNaN||function(b){return b!=b};function L(){L.init.call(this)}ls.exports=L,ls.exports.once=function(b,g){return new Promise(function(f,s){function l(E){b.removeListener(g,u),s(E)}function u(){typeof b.removeListener=="function"&&b.removeListener("error",l),f([].slice.call(arguments))}Ms(b,g,u,{once:!0}),g!=="error"&&function(E,m,$){typeof E.on=="function"&&Ms(E,"error",m,$)}(b,l,{once:!0})})},L.EventEmitter=L,L.prototype._events=void 0,L.prototype._eventsCount=0,L.prototype._maxListeners=void 0;var T=10;function N(b){if(typeof b!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof b)}function p(b){return b._maxListeners===void 0?L.defaultMaxListeners:b._maxListeners}function r(b,g,f,s){var l,u,E,m;if(N(f),(u=b._events)===void 0?(u=b._events=Object.create(null),b._eventsCount=0):(u.newListener!==void 0&&(b.emit("newListener",g,f.listener?f.listener:f),u=b._events),E=u[g]),E===void 0)E=u[g]=f,++b._eventsCount;else if(typeof E=="function"?E=u[g]=s?[f,E]:[E,f]:s?E.unshift(f):E.push(f),(l=p(b))>0&&E.length>l&&!E.warned){E.warned=!0;var $=new Error("Possible EventEmitter memory leak detected. "+E.length+" "+String(g)+" listeners added. Use emitter.setMaxListeners() to increase limit");$.name="MaxListenersExceededWarning",$.emitter=b,$.type=g,$.count=E.length,m=$,console&&console.warn&&console.warn(m)}return b}function gs(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function bs(b,g,f){var s={fired:!1,wrapFn:void 0,target:b,type:g,listener:f},l=gs.bind(s);return l.listener=f,s.wrapFn=l,l}function G(b,g,f){var s=b._events;if(s===void 0)return[];var l=s[g];return l===void 0?[]:typeof l=="function"?f?[l.listener||l]:[l]:f?function(u){for(var E=new Array(u.length),m=0;m<E.length;++m)E[m]=u[m].listener||u[m];return E}(l):xs(l,l.length)}function fs(b){var g=this._events;if(g!==void 0){var f=g[b];if(typeof f=="function")return 1;if(f!==void 0)return f.length}return 0}function xs(b,g){for(var f=new Array(g),s=0;s<g;++s)f[s]=b[s];return f}function Ms(b,g,f,s){if(typeof b.on=="function")s.once?b.once(g,f):b.on(g,f);else{if(typeof b.addEventListener!="function")throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof b);b.addEventListener(g,function l(u){s.once&&b.removeEventListener(g,l),f(u)})}}function B(b){if(typeof b!="function")throw new Error("obliterator/iterator: expecting a function!");this.next=b}Object.defineProperty(L,"defaultMaxListeners",{enumerable:!0,get:function(){return T},set:function(b){if(typeof b!="number"||b<0||Z(b))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+b+".");T=b}}),L.init=function(){this._events!==void 0&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},L.prototype.setMaxListeners=function(b){if(typeof b!="number"||b<0||Z(b))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+b+".");return this._maxListeners=b,this},L.prototype.getMaxListeners=function(){return p(this)},L.prototype.emit=function(b){for(var g=[],f=1;f<arguments.length;f++)g.push(arguments[f]);var s=b==="error",l=this._events;if(l!==void 0)s=s&&l.error===void 0;else if(!s)return!1;if(s){var u;if(g.length>0&&(u=g[0]),u instanceof Error)throw u;var E=new Error("Unhandled error."+(u?" ("+u.message+")":""));throw E.context=u,E}var m=l[b];if(m===void 0)return!1;if(typeof m=="function")v(m,this,g);else{var $=m.length,M=xs(m,$);for(f=0;f<$;++f)v(M[f],this,g)}return!0},L.prototype.addListener=function(b,g){return r(this,b,g,!1)},L.prototype.on=L.prototype.addListener,L.prototype.prependListener=function(b,g){return r(this,b,g,!0)},L.prototype.once=function(b,g){return N(g),this.on(b,bs(this,b,g)),this},L.prototype.prependOnceListener=function(b,g){return N(g),this.prependListener(b,bs(this,b,g)),this},L.prototype.removeListener=function(b,g){var f,s,l,u,E;if(N(g),(s=this._events)===void 0)return this;if((f=s[b])===void 0)return this;if(f===g||f.listener===g)--this._eventsCount==0?this._events=Object.create(null):(delete s[b],s.removeListener&&this.emit("removeListener",b,f.listener||g));else if(typeof f!="function"){for(l=-1,u=f.length-1;u>=0;u--)if(f[u]===g||f[u].listener===g){E=f[u].listener,l=u;break}if(l<0)return this;l===0?f.shift():function(m,$){for(;$+1<m.length;$++)m[$]=m[$+1];m.pop()}(f,l),f.length===1&&(s[b]=f[0]),s.removeListener!==void 0&&this.emit("removeListener",b,E||g)}return this},L.prototype.off=L.prototype.removeListener,L.prototype.removeAllListeners=function(b){var g,f,s;if((f=this._events)===void 0)return this;if(f.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):f[b]!==void 0&&(--this._eventsCount==0?this._events=Object.create(null):delete f[b]),this;if(arguments.length===0){var l,u=Object.keys(f);for(s=0;s<u.length;++s)(l=u[s])!=="removeListener"&&this.removeAllListeners(l);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(typeof(g=f[b])=="function")this.removeListener(b,g);else if(g!==void 0)for(s=g.length-1;s>=0;s--)this.removeListener(b,g[s]);return this},L.prototype.listeners=function(b){return G(this,b,!0)},L.prototype.rawListeners=function(b){return G(this,b,!1)},L.listenerCount=function(b,g){return typeof b.listenerCount=="function"?b.listenerCount(g):fs.call(b,g)},L.prototype.listenerCount=fs,L.prototype.eventNames=function(){return this._eventsCount>0?i(this._events):[]},typeof Symbol!="undefined"&&(B.prototype[Symbol.iterator]=function(){return this}),B.of=function(){var b=arguments,g=b.length,f=0;return new B(function(){return f>=g?{done:!0}:{done:!1,value:b[f++]}})},B.empty=function(){return new B(function(){return{done:!0}})},B.fromSequence=function(b){var g=0,f=b.length;return new B(function(){return g>=f?{done:!0}:{done:!1,value:b[g++]}})},B.is=function(b){return b instanceof B||typeof b=="object"&&b!==null&&typeof b.next=="function"};var c=B,Ls={};Ls.ARRAY_BUFFER_SUPPORT=typeof ArrayBuffer!="undefined",Ls.SYMBOL_SUPPORT=typeof Symbol!="undefined";var Es=c,As=Ls,fl=As.ARRAY_BUFFER_SUPPORT,ul=As.SYMBOL_SUPPORT,Ks=function(b){var g=function(f){return typeof f=="string"||Array.isArray(f)||fl&&ArrayBuffer.isView(f)?Es.fromSequence(f):typeof f!="object"||f===null?null:ul&&typeof f[Symbol.iterator]=="function"?f[Symbol.iterator]():typeof f.next=="function"?f:null}(b);if(!g)throw new Error("obliterator: target is not iterable nor a valid iterator.");return g},gl=Ks,js=function(b,g){for(var f,s=arguments.length>1?g:1/0,l=s!==1/0?new Array(s):[],u=0,E=gl(b);;){if(u===s)return l;if((f=E.next()).done)return u!==g&&(l.length=u),l;l[u++]=f.value}},qs=function(b){function g(f){var s;return(s=b.call(this)||this).name="GraphError",s.message=f,s}return q(g,b),g}(j(Error)),U=function(b){function g(f){var s;return(s=b.call(this,f)||this).name="InvalidArgumentsGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(W(s),g.prototype.constructor),s}return q(g,b),g}(qs),R=function(b){function g(f){var s;return(s=b.call(this,f)||this).name="NotFoundGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(W(s),g.prototype.constructor),s}return q(g,b),g}(qs),J=function(b){function g(f){var s;return(s=b.call(this,f)||this).name="UsageGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(W(s),g.prototype.constructor),s}return q(g,b),g}(qs);function Ns(b,g){this.key=b,this.attributes=g,this.clear()}function Ps(b,g){this.key=b,this.attributes=g,this.clear()}function Vs(b,g){this.key=b,this.attributes=g,this.clear()}function ms(b,g,f,s,l){this.key=g,this.attributes=l,this.undirected=b,this.source=f,this.target=s}Ns.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}},Ps.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}},Vs.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}},ms.prototype.attach=function(){var b="out",g="in";this.undirected&&(b=g="undirected");var f=this.source.key,s=this.target.key;this.source[b][s]=this,this.undirected&&f===s||(this.target[g][f]=this)},ms.prototype.attachMulti=function(){var b="out",g="in",f=this.source.key,s=this.target.key;this.undirected&&(b=g="undirected");var l=this.source[b],u=l[s];if(u===void 0)return l[s]=this,void(this.undirected&&f===s||(this.target[g][f]=this));u.previous=this,this.next=u,l[s]=this,this.target[g][f]=this},ms.prototype.detach=function(){var b=this.source.key,g=this.target.key,f="out",s="in";this.undirected&&(f=s="undirected"),delete this.source[f][g],delete this.target[s][b]},ms.prototype.detachMulti=function(){var b=this.source.key,g=this.target.key,f="out",s="in";this.undirected&&(f=s="undirected"),this.previous===void 0?this.next===void 0?(delete this.source[f][g],delete this.target[s][b]):(this.next.previous=void 0,this.source[f][g]=this.next,this.target[s][b]=this.next):(this.previous.next=this.next,this.next!==void 0&&(this.next.previous=this.previous))};function t(b,g,f,s,l,u,E){var m,$,M,x;if(s=""+s,f===0){if(!(m=b._nodes.get(s)))throw new R("Graph.".concat(g,': could not find the "').concat(s,'" node in the graph.'));M=l,x=u}else if(f===3){if(l=""+l,!($=b._edges.get(l)))throw new R("Graph.".concat(g,': could not find the "').concat(l,'" edge in the graph.'));var y=$.source.key,k=$.target.key;if(s===y)m=$.target;else{if(s!==k)throw new R("Graph.".concat(g,': the "').concat(s,'" node is not attached to the "').concat(l,'" edge (').concat(y,", ").concat(k,")."));m=$.source}M=u,x=E}else{if(!($=b._edges.get(s)))throw new R("Graph.".concat(g,': could not find the "').concat(s,'" edge in the graph.'));m=f===1?$.source:$.target,M=l,x=u}return[m,M,x]}var El=[{name:function(b){return"get".concat(b,"Attribute")},attacher:function(b,g,f){b.prototype[g]=function(s,l,u){var E=t(this,g,f,s,l,u),m=E[0],$=E[1];return m.attributes[$]}}},{name:function(b){return"get".concat(b,"Attributes")},attacher:function(b,g,f){b.prototype[g]=function(s,l){return t(this,g,f,s,l)[0].attributes}}},{name:function(b){return"has".concat(b,"Attribute")},attacher:function(b,g,f){b.prototype[g]=function(s,l,u){var E=t(this,g,f,s,l,u),m=E[0],$=E[1];return m.attributes.hasOwnProperty($)}}},{name:function(b){return"set".concat(b,"Attribute")},attacher:function(b,g,f){b.prototype[g]=function(s,l,u,E){var m=t(this,g,f,s,l,u,E),$=m[0],M=m[1],x=m[2];return $.attributes[M]=x,this.emit("nodeAttributesUpdated",{key:$.key,type:"set",attributes:$.attributes,name:M}),this}}},{name:function(b){return"update".concat(b,"Attribute")},attacher:function(b,g,f){b.prototype[g]=function(s,l,u,E){var m=t(this,g,f,s,l,u,E),$=m[0],M=m[1],x=m[2];if(typeof x!="function")throw new U("Graph.".concat(g,": updater should be a function."));var y=$.attributes,k=x(y[M]);return y[M]=k,this.emit("nodeAttributesUpdated",{key:$.key,type:"set",attributes:$.attributes,name:M}),this}}},{name:function(b){return"remove".concat(b,"Attribute")},attacher:function(b,g,f){b.prototype[g]=function(s,l,u){var E=t(this,g,f,s,l,u),m=E[0],$=E[1];return delete m.attributes[$],this.emit("nodeAttributesUpdated",{key:m.key,type:"remove",attributes:m.attributes,name:$}),this}}},{name:function(b){return"replace".concat(b,"Attributes")},attacher:function(b,g,f){b.prototype[g]=function(s,l,u){var E=t(this,g,f,s,l,u),m=E[0],$=E[1];if(!P($))throw new U("Graph.".concat(g,": provided attributes are not a plain object."));return m.attributes=$,this.emit("nodeAttributesUpdated",{key:m.key,type:"replace",attributes:m.attributes}),this}}},{name:function(b){return"merge".concat(b,"Attributes")},attacher:function(b,g,f){b.prototype[g]=function(s,l,u){var E=t(this,g,f,s,l,u),m=E[0],$=E[1];if(!P($))throw new U("Graph.".concat(g,": provided attributes are not a plain object."));return O(m.attributes,$),this.emit("nodeAttributesUpdated",{key:m.key,type:"merge",attributes:m.attributes,data:$}),this}}},{name:function(b){return"update".concat(b,"Attributes")},attacher:function(b,g,f){b.prototype[g]=function(s,l,u){var E=t(this,g,f,s,l,u),m=E[0],$=E[1];if(typeof $!="function")throw new U("Graph.".concat(g,": provided updater is not a function."));return m.attributes=$(m.attributes),this.emit("nodeAttributesUpdated",{key:m.key,type:"update",attributes:m.attributes}),this}}}],ml=[{name:function(b){return"get".concat(b,"Attribute")},attacher:function(b,g,f){b.prototype[g]=function(s,l){var u;if(this.type!=="mixed"&&f!=="mixed"&&f!==this.type)throw new J("Graph.".concat(g,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new J("Graph.".concat(g,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var E=""+s,m=""+l;if(l=arguments[2],!(u=A(this,E,m,f)))throw new R("Graph.".concat(g,': could not find an edge for the given path ("').concat(E,'" - "').concat(m,'").'))}else{if(f!=="mixed")throw new J("Graph.".concat(g,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(s=""+s,!(u=this._edges.get(s)))throw new R("Graph.".concat(g,': could not find the "').concat(s,'" edge in the graph.'))}return u.attributes[l]}}},{name:function(b){return"get".concat(b,"Attributes")},attacher:function(b,g,f){b.prototype[g]=function(s){var l;if(this.type!=="mixed"&&f!=="mixed"&&f!==this.type)throw new J("Graph.".concat(g,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>1){if(this.multi)throw new J("Graph.".concat(g,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var u=""+s,E=""+arguments[1];if(!(l=A(this,u,E,f)))throw new R("Graph.".concat(g,': could not find an edge for the given path ("').concat(u,'" - "').concat(E,'").'))}else{if(f!=="mixed")throw new J("Graph.".concat(g,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(s=""+s,!(l=this._edges.get(s)))throw new R("Graph.".concat(g,': could not find the "').concat(s,'" edge in the graph.'))}return l.attributes}}},{name:function(b){return"has".concat(b,"Attribute")},attacher:function(b,g,f){b.prototype[g]=function(s,l){var u;if(this.type!=="mixed"&&f!=="mixed"&&f!==this.type)throw new J("Graph.".concat(g,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new J("Graph.".concat(g,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var E=""+s,m=""+l;if(l=arguments[2],!(u=A(this,E,m,f)))throw new R("Graph.".concat(g,': could not find an edge for the given path ("').concat(E,'" - "').concat(m,'").'))}else{if(f!=="mixed")throw new J("Graph.".concat(g,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(s=""+s,!(u=this._edges.get(s)))throw new R("Graph.".concat(g,': could not find the "').concat(s,'" edge in the graph.'))}return u.attributes.hasOwnProperty(l)}}},{name:function(b){return"set".concat(b,"Attribute")},attacher:function(b,g,f){b.prototype[g]=function(s,l,u){var E;if(this.type!=="mixed"&&f!=="mixed"&&f!==this.type)throw new J("Graph.".concat(g,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>3){if(this.multi)throw new J("Graph.".concat(g,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var m=""+s,$=""+l;if(l=arguments[2],u=arguments[3],!(E=A(this,m,$,f)))throw new R("Graph.".concat(g,': could not find an edge for the given path ("').concat(m,'" - "').concat($,'").'))}else{if(f!=="mixed")throw new J("Graph.".concat(g,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(s=""+s,!(E=this._edges.get(s)))throw new R("Graph.".concat(g,': could not find the "').concat(s,'" edge in the graph.'))}return E.attributes[l]=u,this.emit("edgeAttributesUpdated",{key:E.key,type:"set",attributes:E.attributes,name:l}),this}}},{name:function(b){return"update".concat(b,"Attribute")},attacher:function(b,g,f){b.prototype[g]=function(s,l,u){var E;if(this.type!=="mixed"&&f!=="mixed"&&f!==this.type)throw new J("Graph.".concat(g,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>3){if(this.multi)throw new J("Graph.".concat(g,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var m=""+s,$=""+l;if(l=arguments[2],u=arguments[3],!(E=A(this,m,$,f)))throw new R("Graph.".concat(g,': could not find an edge for the given path ("').concat(m,'" - "').concat($,'").'))}else{if(f!=="mixed")throw new J("Graph.".concat(g,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(s=""+s,!(E=this._edges.get(s)))throw new R("Graph.".concat(g,': could not find the "').concat(s,'" edge in the graph.'))}if(typeof u!="function")throw new U("Graph.".concat(g,": updater should be a function."));return E.attributes[l]=u(E.attributes[l]),this.emit("edgeAttributesUpdated",{key:E.key,type:"set",attributes:E.attributes,name:l}),this}}},{name:function(b){return"remove".concat(b,"Attribute")},attacher:function(b,g,f){b.prototype[g]=function(s,l){var u;if(this.type!=="mixed"&&f!=="mixed"&&f!==this.type)throw new J("Graph.".concat(g,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new J("Graph.".concat(g,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var E=""+s,m=""+l;if(l=arguments[2],!(u=A(this,E,m,f)))throw new R("Graph.".concat(g,': could not find an edge for the given path ("').concat(E,'" - "').concat(m,'").'))}else{if(f!=="mixed")throw new J("Graph.".concat(g,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(s=""+s,!(u=this._edges.get(s)))throw new R("Graph.".concat(g,': could not find the "').concat(s,'" edge in the graph.'))}return delete u.attributes[l],this.emit("edgeAttributesUpdated",{key:u.key,type:"remove",attributes:u.attributes,name:l}),this}}},{name:function(b){return"replace".concat(b,"Attributes")},attacher:function(b,g,f){b.prototype[g]=function(s,l){var u;if(this.type!=="mixed"&&f!=="mixed"&&f!==this.type)throw new J("Graph.".concat(g,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new J("Graph.".concat(g,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var E=""+s,m=""+l;if(l=arguments[2],!(u=A(this,E,m,f)))throw new R("Graph.".concat(g,': could not find an edge for the given path ("').concat(E,'" - "').concat(m,'").'))}else{if(f!=="mixed")throw new J("Graph.".concat(g,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(s=""+s,!(u=this._edges.get(s)))throw new R("Graph.".concat(g,': could not find the "').concat(s,'" edge in the graph.'))}if(!P(l))throw new U("Graph.".concat(g,": provided attributes are not a plain object."));return u.attributes=l,this.emit("edgeAttributesUpdated",{key:u.key,type:"replace",attributes:u.attributes}),this}}},{name:function(b){return"merge".concat(b,"Attributes")},attacher:function(b,g,f){b.prototype[g]=function(s,l){var u;if(this.type!=="mixed"&&f!=="mixed"&&f!==this.type)throw new J("Graph.".concat(g,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new J("Graph.".concat(g,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var E=""+s,m=""+l;if(l=arguments[2],!(u=A(this,E,m,f)))throw new R("Graph.".concat(g,': could not find an edge for the given path ("').concat(E,'" - "').concat(m,'").'))}else{if(f!=="mixed")throw new J("Graph.".concat(g,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(s=""+s,!(u=this._edges.get(s)))throw new R("Graph.".concat(g,': could not find the "').concat(s,'" edge in the graph.'))}if(!P(l))throw new U("Graph.".concat(g,": provided attributes are not a plain object."));return O(u.attributes,l),this.emit("edgeAttributesUpdated",{key:u.key,type:"merge",attributes:u.attributes,data:l}),this}}},{name:function(b){return"update".concat(b,"Attributes")},attacher:function(b,g,f){b.prototype[g]=function(s,l){var u;if(this.type!=="mixed"&&f!=="mixed"&&f!==this.type)throw new J("Graph.".concat(g,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new J("Graph.".concat(g,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var E=""+s,m=""+l;if(l=arguments[2],!(u=A(this,E,m,f)))throw new R("Graph.".concat(g,': could not find an edge for the given path ("').concat(E,'" - "').concat(m,'").'))}else{if(f!=="mixed")throw new J("Graph.".concat(g,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(s=""+s,!(u=this._edges.get(s)))throw new R("Graph.".concat(g,': could not find the "').concat(s,'" edge in the graph.'))}if(typeof l!="function")throw new U("Graph.".concat(g,": provided updater is not a function."));return u.attributes=l(u.attributes),this.emit("edgeAttributesUpdated",{key:u.key,type:"update",attributes:u.attributes}),this}}}],$l=c,yl=Ks,ss=function(){var b=arguments,g=null,f=-1;return new $l(function(){for(var s=null;;){if(g===null){if(++f>=b.length)return{done:!0};g=yl(b[f])}if((s=g.next()).done!==!0)break;g=null}return s})},xl=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function Ml(b,g,f,s){var l=!1;for(var u in g)if(u!==s){var E=g[u];if(l=f(E.key,E.attributes,E.source.key,E.target.key,E.source.attributes,E.target.attributes,E.undirected),b&&l)return E.key}}function Ll(b,g,f,s){var l,u,E,m=!1;for(var $ in g)if($!==s){l=g[$];do{if(u=l.source,E=l.target,m=f(l.key,l.attributes,u.key,E.key,u.attributes,E.attributes,l.undirected),b&&m)return l.key;l=l.next}while(l!==void 0)}}function Ys(b,g){var f,s=Object.keys(b),l=s.length,u=0;return new c(function(){do if(f)f=f.next;else{if(u>=l)return{done:!0};var E=s[u++];if(E===g){f=void 0;continue}f=b[E]}while(!f);return{done:!1,value:{edge:f.key,attributes:f.attributes,source:f.source.key,target:f.target.key,sourceAttributes:f.source.attributes,targetAttributes:f.target.attributes,undirected:f.undirected}}})}function Rl(b,g,f,s){var l=g[f];if(l){var{source:u,target:E}=l;return s(l.key,l.attributes,u.key,E.key,u.attributes,E.attributes,l.undirected)&&b?l.key:void 0}}function kl(b,g,f,s){var l=g[f];if(l){var u=!1;do{if(u=s(l.key,l.attributes,l.source.key,l.target.key,l.source.attributes,l.target.attributes,l.undirected),b&&u)return l.key;l=l.next}while(l!==void 0)}}function Ws(b,g){var f=b[g];return f.next!==void 0?new c(function(){if(!f)return{done:!0};var s={edge:f.key,attributes:f.attributes,source:f.source.key,target:f.target.key,sourceAttributes:f.source.attributes,targetAttributes:f.target.attributes,undirected:f.undirected};return f=f.next,{done:!1,value:s}}):c.of({edge:f.key,attributes:f.attributes,source:f.source.key,target:f.target.key,sourceAttributes:f.source.attributes,targetAttributes:f.target.attributes,undirected:f.undirected})}function Cl(b,g){if(b.size===0)return[];if(g==="mixed"||g===b.type)return typeof Array.from=="function"?Array.from(b._edges.keys()):js(b._edges.keys(),b._edges.size);for(var f,s,l=g==="undirected"?b.undirectedSize:b.directedSize,u=new Array(l),E=g==="undirected",m=b._edges.values(),$=0;(f=m.next()).done!==!0;)(s=f.value).undirected===E&&(u[$++]=s.key);return u}function _s(b,g,f,s){if(g.size!==0){for(var l,u,E=f!=="mixed"&&f!==g.type,m=f==="undirected",$=!1,M=g._edges.values();(l=M.next()).done!==!0;)if(u=l.value,!E||u.undirected===m){var x=u,y=x.key,k=x.attributes,C=x.source,X=x.target;if($=s(y,k,C.key,X.key,C.attributes,X.attributes,u.undirected),b&&$)return y}}}function Tl(b,g){if(b.size===0)return c.empty();var f=g!=="mixed"&&g!==b.type,s=g==="undirected",l=b._edges.values();return new c(function(){for(var u,E;;){if((u=l.next()).done)return u;if(E=u.value,!f||E.undirected===s)break}return{value:{edge:E.key,attributes:E.attributes,source:E.source.key,target:E.target.key,sourceAttributes:E.source.attributes,targetAttributes:E.target.attributes,undirected:E.undirected},done:!1}})}function hs(b,g,f,s,l,u){var E,m=g?Ll:Ml;if(f!=="undirected"){if(s!=="out"&&(E=m(b,l.in,u),b&&E))return E;if(s!=="in"&&(E=m(b,l.out,u,s?void 0:l.key),b&&E))return E}if(f!=="directed"&&(E=m(b,l.undirected,u),b&&E))return E}function Dl(b,g,f,s){var l=[];return hs(!1,b,g,f,s,function(u){l.push(u)}),l}function Ul(b,g,f){var s=c.empty();return b!=="undirected"&&(g!=="out"&&f.in!==void 0&&(s=ss(s,Ys(f.in))),g!=="in"&&f.out!==void 0&&(s=ss(s,Ys(f.out,g?void 0:f.key)))),b!=="directed"&&f.undirected!==void 0&&(s=ss(s,Ys(f.undirected))),s}function Js(b,g,f,s,l,u,E){var m,$=f?kl:Rl;if(g!=="undirected"){if(l.in!==void 0&&s!=="out"&&(m=$(b,l.in,u,E),b&&m))return m;if(l.out!==void 0&&s!=="in"&&(s||l.key!==u)&&(m=$(b,l.out,u,E),b&&m))return m}if(g!=="directed"&&l.undirected!==void 0&&(m=$(b,l.undirected,u,E),b&&m))return m}function Hl(b,g,f,s,l){var u=[];return Js(!1,b,g,f,s,l,function(E){u.push(E)}),u}function vl(b,g,f,s){var l=c.empty();return b!=="undirected"&&(f.in!==void 0&&g!=="out"&&(s in f.in)&&(l=ss(l,Ws(f.in,s))),f.out!==void 0&&g!=="in"&&(s in f.out)&&(g||f.key!==s)&&(l=ss(l,Ws(f.out,s)))),b!=="directed"&&f.undirected!==void 0&&s in f.undirected&&(l=ss(l,Ws(f.undirected,s))),l}var ql=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function Ts(){this.A=null,this.B=null}function Rs(b,g,f,s,l){for(var u in s){var E=s[u],m=E.source,$=E.target,M=m===f?$:m;if(!g||!g.has(M.key)){var x=l(M.key,M.attributes);if(b&&x)return M.key}}}function Xs(b,g,f,s,l){if(g!=="mixed"){if(g==="undirected")return Rs(b,null,s,s.undirected,l);if(typeof f=="string")return Rs(b,null,s,s[f],l)}var u,E=new Ts;if(g!=="undirected"){if(f!=="out"){if(u=Rs(b,null,s,s.in,l),b&&u)return u;E.wrap(s.in)}if(f!=="in"){if(u=Rs(b,E,s,s.out,l),b&&u)return u;E.wrap(s.out)}}if(g!=="directed"&&(u=Rs(b,E,s,s.undirected,l),b&&u))return u}function ks(b,g,f){var s=Object.keys(f),l=s.length,u=0;return new c(function(){var E=null;do{if(u>=l)return b&&b.wrap(f),{done:!0};var m=f[s[u++]],$=m.source,M=m.target;E=$===g?M:$,b&&b.has(E.key)&&(E=null)}while(E===null);return{done:!1,value:{neighbor:E.key,attributes:E.attributes}}})}function Yl(b,g){var{name:f,type:s,direction:l}=g;b.prototype[f]=function(u){if(s!=="mixed"&&this.type!=="mixed"&&s!==this.type)return[];u=""+u;var E=this._nodes.get(u);if(E===void 0)throw new R("Graph.".concat(f,': could not find the "').concat(u,'" node in the graph.'));return function(m,$,M){if(m!=="mixed"){if(m==="undirected")return Object.keys(M.undirected);if(typeof $=="string")return Object.keys(M[$])}var x=[];return Xs(!1,m,$,M,function(y){x.push(y)}),x}(s==="mixed"?this.type:s,l,E)}}function Wl(b,g){var{name:f,type:s,direction:l}=g,u=f.slice(0,-1)+"Entries";b.prototype[u]=function(E){if(s!=="mixed"&&this.type!=="mixed"&&s!==this.type)return c.empty();E=""+E;var m=this._nodes.get(E);if(m===void 0)throw new R("Graph.".concat(u,': could not find the "').concat(E,'" node in the graph.'));return function($,M,x){if($!=="mixed"){if($==="undirected")return ks(null,x,x.undirected);if(typeof M=="string")return ks(null,x,x[M])}var y=c.empty(),k=new Ts;return $!=="undirected"&&(M!=="out"&&(y=ss(y,ks(k,x,x.in))),M!=="in"&&(y=ss(y,ks(k,x,x.out)))),$!=="directed"&&(y=ss(y,ks(k,x,x.undirected))),y}(s==="mixed"?this.type:s,l,m)}}function Ds(b,g,f,s,l){for(var u,E,m,$,M,x,y,k=s._nodes.values(),C=s.type;(u=k.next()).done!==!0;){var X=!1;if(E=u.value,C!=="undirected")for(m in $=E.out){M=$[m];do{if(x=M.target,X=!0,y=l(E.key,x.key,E.attributes,x.attributes,M.key,M.attributes,M.undirected),b&&y)return M;M=M.next}while(M)}if(C!=="directed"){for(m in $=E.undirected)if(!(g&&E.key>m)){M=$[m];do{if((x=M.target).key!==m&&(x=M.source),X=!0,y=l(E.key,x.key,E.attributes,x.attributes,M.key,M.attributes,M.undirected),b&&y)return M;M=M.next}while(M)}}if(f&&!X&&(y=l(E.key,null,E.attributes,null,null,null,null),b&&y))return null}}function hl(b){if(!P(b))throw new U('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in b))throw new U("Graph.import: serialized node is missing its key.");if("attributes"in b&&(!P(b.attributes)||b.attributes===null))throw new U("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function Jl(b){if(!P(b))throw new U('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in b))throw new U("Graph.import: serialized edge is missing its source.");if(!("target"in b))throw new U("Graph.import: serialized edge is missing its target.");if("attributes"in b&&(!P(b.attributes)||b.attributes===null))throw new U("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in b&&typeof b.undirected!="boolean")throw new U("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}Ts.prototype.wrap=function(b){this.A===null?this.A=b:this.B===null&&(this.B=b)},Ts.prototype.has=function(b){return this.A!==null&&b in this.A||this.B!==null&&b in this.B};var Ss,Xl=(Ss=255&Math.floor(256*Math.random()),function(){return Ss++}),Ol=new Set(["directed","undirected","mixed"]),cs=new Set(["domain","_events","_eventsCount","_maxListeners"]),Ql={allowSelfLoops:!0,multi:!1,type:"mixed"};function ps(b,g,f){var s=new b.NodeDataClass(g,f);return b._nodes.set(g,s),b.emit("nodeAdded",{key:g,attributes:f}),s}function Gs(b,g,f,s,l,u,E,m){if(!s&&b.type==="undirected")throw new J("Graph.".concat(g,": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead."));if(s&&b.type==="directed")throw new J("Graph.".concat(g,": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead."));if(m&&!P(m))throw new U("Graph.".concat(g,': invalid attributes. Expecting an object but got "').concat(m,'"'));if(u=""+u,E=""+E,m=m||{},!b.allowSelfLoops&&u===E)throw new J("Graph.".concat(g,': source & target are the same ("').concat(u,`"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`));var $=b._nodes.get(u),M=b._nodes.get(E);if(!$)throw new R("Graph.".concat(g,': source node "').concat(u,'" not found.'));if(!M)throw new R("Graph.".concat(g,': target node "').concat(E,'" not found.'));var x={key:null,undirected:s,source:u,target:E,attributes:m};if(f)l=b._edgeKeyGenerator();else if(l=""+l,b._edges.has(l))throw new J("Graph.".concat(g,': the "').concat(l,'" edge already exists in the graph.'));if(!b.multi&&(s?$.undirected[E]!==void 0:$.out[E]!==void 0))throw new J("Graph.".concat(g,': an edge linking "').concat(u,'" to "').concat(E,`" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`));var y=new ms(s,l,$,M,m);b._edges.set(l,y);var k=u===E;return s?($.undirectedDegree++,M.undirectedDegree++,k&&($.undirectedLoops++,b._undirectedSelfLoopCount++)):($.outDegree++,M.inDegree++,k&&($.directedLoops++,b._directedSelfLoopCount++)),b.multi?y.attachMulti():y.attach(),s?b._undirectedSize++:b._directedSize++,x.key=l,b.emit("edgeAdded",x),l}function Zl(b,g,f,s,l,u,E,m,$){if(!s&&b.type==="undirected")throw new J("Graph.".concat(g,": you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead."));if(s&&b.type==="directed")throw new J("Graph.".concat(g,": you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead."));if(m){if($){if(typeof m!="function")throw new U("Graph.".concat(g,': invalid updater function. Expecting a function but got "').concat(m,'"'))}else if(!P(m))throw new U("Graph.".concat(g,': invalid attributes. Expecting an object but got "').concat(m,'"'))}var M;if(u=""+u,E=""+E,$&&(M=m,m=void 0),!b.allowSelfLoops&&u===E)throw new J("Graph.".concat(g,': source & target are the same ("').concat(u,`"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`));var x,y,k=b._nodes.get(u),C=b._nodes.get(E);if(!f&&(x=b._edges.get(l))){if(!(x.source.key===u&&x.target.key===E||s&&x.source.key===E&&x.target.key===u))throw new J("Graph.".concat(g,': inconsistency detected when attempting to merge the "').concat(l,'" edge with "').concat(u,'" source & "').concat(E,'" target vs. ("').concat(x.source.key,'", "').concat(x.target.key,'").'));y=x}if(y||b.multi||!k||(y=s?k.undirected[E]:k.out[E]),y){var X=[y.key,!1,!1,!1];if($?!M:!m)return X;if($){var V=y.attributes;y.attributes=M(V),b.emit("edgeAttributesUpdated",{type:"replace",key:y.key,attributes:y.attributes})}else O(y.attributes,m),b.emit("edgeAttributesUpdated",{type:"merge",key:y.key,attributes:y.attributes,data:m});return X}m=m||{},$&&M&&(m=M(m));var S={key:null,undirected:s,source:u,target:E,attributes:m};if(f)l=b._edgeKeyGenerator();else if(l=""+l,b._edges.has(l))throw new J("Graph.".concat(g,': the "').concat(l,'" edge already exists in the graph.'));var z=!1,w=!1;k||(k=ps(b,u,{}),z=!0,u===E&&(C=k,w=!0)),C||(C=ps(b,E,{}),w=!0),x=new ms(s,l,k,C,m),b._edges.set(l,x);var F=u===E;return s?(k.undirectedDegree++,C.undirectedDegree++,F&&(k.undirectedLoops++,b._undirectedSelfLoopCount++)):(k.outDegree++,C.inDegree++,F&&(k.directedLoops++,b._directedSelfLoopCount++)),b.multi?x.attachMulti():x.attach(),s?b._undirectedSize++:b._directedSize++,S.key=l,b.emit("edgeAdded",S),[l,!0,z,w]}function $s(b,g){b._edges.delete(g.key);var{source:f,target:s,attributes:l,undirected:u}=g,E=f===s;u?(f.undirectedDegree--,s.undirectedDegree--,E&&(f.undirectedLoops--,b._undirectedSelfLoopCount--)):(f.outDegree--,s.inDegree--,E&&(f.directedLoops--,b._directedSelfLoopCount--)),b.multi?g.detachMulti():g.detach(),u?b._undirectedSize--:b._directedSize--,b.emit("edgeDropped",{key:g.key,attributes:l,source:f.key,target:s.key,undirected:u})}var _=function(b){function g(s){var l;if(l=b.call(this)||this,typeof(s=O({},Ql,s)).multi!="boolean")throw new U(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "`.concat(s.multi,'".'));if(!Ol.has(s.type))throw new U(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "`.concat(s.type,'".'));if(typeof s.allowSelfLoops!="boolean")throw new U(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "`.concat(s.allowSelfLoops,'".'));var u=s.type==="mixed"?Ns:s.type==="directed"?Ps:Vs;K(W(l),"NodeDataClass",u);var E="geid_"+Xl()+"_",m=0;return K(W(l),"_attributes",{}),K(W(l),"_nodes",new Map),K(W(l),"_edges",new Map),K(W(l),"_directedSize",0),K(W(l),"_undirectedSize",0),K(W(l),"_directedSelfLoopCount",0),K(W(l),"_undirectedSelfLoopCount",0),K(W(l),"_edgeKeyGenerator",function(){var $;do $=E+m++;while(l._edges.has($));return $}),K(W(l),"_options",s),cs.forEach(function($){return K(W(l),$,l[$])}),d(W(l),"order",function(){return l._nodes.size}),d(W(l),"size",function(){return l._edges.size}),d(W(l),"directedSize",function(){return l._directedSize}),d(W(l),"undirectedSize",function(){return l._undirectedSize}),d(W(l),"selfLoopCount",function(){return l._directedSelfLoopCount+l._undirectedSelfLoopCount}),d(W(l),"directedSelfLoopCount",function(){return l._directedSelfLoopCount}),d(W(l),"undirectedSelfLoopCount",function(){return l._undirectedSelfLoopCount}),d(W(l),"multi",l._options.multi),d(W(l),"type",l._options.type),d(W(l),"allowSelfLoops",l._options.allowSelfLoops),d(W(l),"implementation",function(){return"graphology"}),l}q(g,b);var f=g.prototype;return f._resetInstanceCounters=function(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0},f.hasNode=function(s){return this._nodes.has(""+s)},f.hasDirectedEdge=function(s,l){if(this.type==="undirected")return!1;if(arguments.length===1){var u=""+s,E=this._edges.get(u);return!!E&&!E.undirected}if(arguments.length===2){s=""+s,l=""+l;var m=this._nodes.get(s);return!!m&&m.out.hasOwnProperty(l)}throw new U("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},f.hasUndirectedEdge=function(s,l){if(this.type==="directed")return!1;if(arguments.length===1){var u=""+s,E=this._edges.get(u);return!!E&&E.undirected}if(arguments.length===2){s=""+s,l=""+l;var m=this._nodes.get(s);return!!m&&m.undirected.hasOwnProperty(l)}throw new U("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},f.hasEdge=function(s,l){if(arguments.length===1){var u=""+s;return this._edges.has(u)}if(arguments.length===2){s=""+s,l=""+l;var E=this._nodes.get(s);return!!E&&(E.out!==void 0&&E.out.hasOwnProperty(l)||E.undirected!==void 0&&E.undirected.hasOwnProperty(l))}throw new U("Graph.hasEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},f.directedEdge=function(s,l){if(this.type!=="undirected"){if(s=""+s,l=""+l,this.multi)throw new J("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");var u=this._nodes.get(s);if(!u)throw new R('Graph.directedEdge: could not find the "'.concat(s,'" source node in the graph.'));if(!this._nodes.has(l))throw new R('Graph.directedEdge: could not find the "'.concat(l,'" target node in the graph.'));var E=u.out&&u.out[l]||void 0;return E?E.key:void 0}},f.undirectedEdge=function(s,l){if(this.type!=="directed"){if(s=""+s,l=""+l,this.multi)throw new J("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");var u=this._nodes.get(s);if(!u)throw new R('Graph.undirectedEdge: could not find the "'.concat(s,'" source node in the graph.'));if(!this._nodes.has(l))throw new R('Graph.undirectedEdge: could not find the "'.concat(l,'" target node in the graph.'));var E=u.undirected&&u.undirected[l]||void 0;return E?E.key:void 0}},f.edge=function(s,l){if(this.multi)throw new J("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");s=""+s,l=""+l;var u=this._nodes.get(s);if(!u)throw new R('Graph.edge: could not find the "'.concat(s,'" source node in the graph.'));if(!this._nodes.has(l))throw new R('Graph.edge: could not find the "'.concat(l,'" target node in the graph.'));var E=u.out&&u.out[l]||u.undirected&&u.undirected[l]||void 0;if(E)return E.key},f.areDirectedNeighbors=function(s,l){s=""+s,l=""+l;var u=this._nodes.get(s);if(!u)throw new R('Graph.areDirectedNeighbors: could not find the "'.concat(s,'" node in the graph.'));return this.type!=="undirected"&&((l in u.in)||(l in u.out))},f.areOutNeighbors=function(s,l){s=""+s,l=""+l;var u=this._nodes.get(s);if(!u)throw new R('Graph.areOutNeighbors: could not find the "'.concat(s,'" node in the graph.'));return this.type!=="undirected"&&l in u.out},f.areInNeighbors=function(s,l){s=""+s,l=""+l;var u=this._nodes.get(s);if(!u)throw new R('Graph.areInNeighbors: could not find the "'.concat(s,'" node in the graph.'));return this.type!=="undirected"&&l in u.in},f.areUndirectedNeighbors=function(s,l){s=""+s,l=""+l;var u=this._nodes.get(s);if(!u)throw new R('Graph.areUndirectedNeighbors: could not find the "'.concat(s,'" node in the graph.'));return this.type!=="directed"&&l in u.undirected},f.areNeighbors=function(s,l){s=""+s,l=""+l;var u=this._nodes.get(s);if(!u)throw new R('Graph.areNeighbors: could not find the "'.concat(s,'" node in the graph.'));return this.type!=="undirected"&&((l in u.in)||(l in u.out))||this.type!=="directed"&&l in u.undirected},f.areInboundNeighbors=function(s,l){s=""+s,l=""+l;var u=this._nodes.get(s);if(!u)throw new R('Graph.areInboundNeighbors: could not find the "'.concat(s,'" node in the graph.'));return this.type!=="undirected"&&l in u.in||this.type!=="directed"&&l in u.undirected},f.areOutboundNeighbors=function(s,l){s=""+s,l=""+l;var u=this._nodes.get(s);if(!u)throw new R('Graph.areOutboundNeighbors: could not find the "'.concat(s,'" node in the graph.'));return this.type!=="undirected"&&l in u.out||this.type!=="directed"&&l in u.undirected},f.inDegree=function(s){s=""+s;var l=this._nodes.get(s);if(!l)throw new R('Graph.inDegree: could not find the "'.concat(s,'" node in the graph.'));return this.type==="undirected"?0:l.inDegree},f.outDegree=function(s){s=""+s;var l=this._nodes.get(s);if(!l)throw new R('Graph.outDegree: could not find the "'.concat(s,'" node in the graph.'));return this.type==="undirected"?0:l.outDegree},f.directedDegree=function(s){s=""+s;var l=this._nodes.get(s);if(!l)throw new R('Graph.directedDegree: could not find the "'.concat(s,'" node in the graph.'));return this.type==="undirected"?0:l.inDegree+l.outDegree},f.undirectedDegree=function(s){s=""+s;var l=this._nodes.get(s);if(!l)throw new R('Graph.undirectedDegree: could not find the "'.concat(s,'" node in the graph.'));return this.type==="directed"?0:l.undirectedDegree},f.inboundDegree=function(s){s=""+s;var l=this._nodes.get(s);if(!l)throw new R('Graph.inboundDegree: could not find the "'.concat(s,'" node in the graph.'));var u=0;return this.type!=="directed"&&(u+=l.undirectedDegree),this.type!=="undirected"&&(u+=l.inDegree),u},f.outboundDegree=function(s){s=""+s;var l=this._nodes.get(s);if(!l)throw new R('Graph.outboundDegree: could not find the "'.concat(s,'" node in the graph.'));var u=0;return this.type!=="directed"&&(u+=l.undirectedDegree),this.type!=="undirected"&&(u+=l.outDegree),u},f.degree=function(s){s=""+s;var l=this._nodes.get(s);if(!l)throw new R('Graph.degree: could not find the "'.concat(s,'" node in the graph.'));var u=0;return this.type!=="directed"&&(u+=l.undirectedDegree),this.type!=="undirected"&&(u+=l.inDegree+l.outDegree),u},f.inDegreeWithoutSelfLoops=function(s){s=""+s;var l=this._nodes.get(s);if(!l)throw new R('Graph.inDegreeWithoutSelfLoops: could not find the "'.concat(s,'" node in the graph.'));return this.type==="undirected"?0:l.inDegree-l.directedLoops},f.outDegreeWithoutSelfLoops=function(s){s=""+s;var l=this._nodes.get(s);if(!l)throw new R('Graph.outDegreeWithoutSelfLoops: could not find the "'.concat(s,'" node in the graph.'));return this.type==="undirected"?0:l.outDegree-l.directedLoops},f.directedDegreeWithoutSelfLoops=function(s){s=""+s;var l=this._nodes.get(s);if(!l)throw new R('Graph.directedDegreeWithoutSelfLoops: could not find the "'.concat(s,'" node in the graph.'));return this.type==="undirected"?0:l.inDegree+l.outDegree-2*l.directedLoops},f.undirectedDegreeWithoutSelfLoops=function(s){s=""+s;var l=this._nodes.get(s);if(!l)throw new R('Graph.undirectedDegreeWithoutSelfLoops: could not find the "'.concat(s,'" node in the graph.'));return this.type==="directed"?0:l.undirectedDegree-2*l.undirectedLoops},f.inboundDegreeWithoutSelfLoops=function(s){s=""+s;var l=this._nodes.get(s);if(!l)throw new R('Graph.inboundDegreeWithoutSelfLoops: could not find the "'.concat(s,'" node in the graph.'));var u=0,E=0;return this.type!=="directed"&&(u+=l.undirectedDegree,E+=2*l.undirectedLoops),this.type!=="undirected"&&(u+=l.inDegree,E+=l.directedLoops),u-E},f.outboundDegreeWithoutSelfLoops=function(s){s=""+s;var l=this._nodes.get(s);if(!l)throw new R('Graph.outboundDegreeWithoutSelfLoops: could not find the "'.concat(s,'" node in the graph.'));var u=0,E=0;return this.type!=="directed"&&(u+=l.undirectedDegree,E+=2*l.undirectedLoops),this.type!=="undirected"&&(u+=l.outDegree,E+=l.directedLoops),u-E},f.degreeWithoutSelfLoops=function(s){s=""+s;var l=this._nodes.get(s);if(!l)throw new R('Graph.degreeWithoutSelfLoops: could not find the "'.concat(s,'" node in the graph.'));var u=0,E=0;return this.type!=="directed"&&(u+=l.undirectedDegree,E+=2*l.undirectedLoops),this.type!=="undirected"&&(u+=l.inDegree+l.outDegree,E+=2*l.directedLoops),u-E},f.source=function(s){s=""+s;var l=this._edges.get(s);if(!l)throw new R('Graph.source: could not find the "'.concat(s,'" edge in the graph.'));return l.source.key},f.target=function(s){s=""+s;var l=this._edges.get(s);if(!l)throw new R('Graph.target: could not find the "'.concat(s,'" edge in the graph.'));return l.target.key},f.extremities=function(s){s=""+s;var l=this._edges.get(s);if(!l)throw new R('Graph.extremities: could not find the "'.concat(s,'" edge in the graph.'));return[l.source.key,l.target.key]},f.opposite=function(s,l){s=""+s,l=""+l;var u=this._edges.get(l);if(!u)throw new R('Graph.opposite: could not find the "'.concat(l,'" edge in the graph.'));var E=u.source.key,m=u.target.key;if(s===E)return m;if(s===m)return E;throw new R('Graph.opposite: the "'.concat(s,'" node is not attached to the "').concat(l,'" edge (').concat(E,", ").concat(m,")."))},f.hasExtremity=function(s,l){s=""+s,l=""+l;var u=this._edges.get(s);if(!u)throw new R('Graph.hasExtremity: could not find the "'.concat(s,'" edge in the graph.'));return u.source.key===l||u.target.key===l},f.isUndirected=function(s){s=""+s;var l=this._edges.get(s);if(!l)throw new R('Graph.isUndirected: could not find the "'.concat(s,'" edge in the graph.'));return l.undirected},f.isDirected=function(s){s=""+s;var l=this._edges.get(s);if(!l)throw new R('Graph.isDirected: could not find the "'.concat(s,'" edge in the graph.'));return!l.undirected},f.isSelfLoop=function(s){s=""+s;var l=this._edges.get(s);if(!l)throw new R('Graph.isSelfLoop: could not find the "'.concat(s,'" edge in the graph.'));return l.source===l.target},f.addNode=function(s,l){var u=function(E,m,$){if($&&!P($))throw new U('Graph.addNode: invalid attributes. Expecting an object but got "'.concat($,'"'));if(m=""+m,$=$||{},E._nodes.has(m))throw new J('Graph.addNode: the "'.concat(m,'" node already exist in the graph.'));var M=new E.NodeDataClass(m,$);return E._nodes.set(m,M),E.emit("nodeAdded",{key:m,attributes:$}),M}(this,s,l);return u.key},f.mergeNode=function(s,l){if(l&&!P(l))throw new U('Graph.mergeNode: invalid attributes. Expecting an object but got "'.concat(l,'"'));s=""+s,l=l||{};var u=this._nodes.get(s);return u?(l&&(O(u.attributes,l),this.emit("nodeAttributesUpdated",{type:"merge",key:s,attributes:u.attributes,data:l})),[s,!1]):(u=new this.NodeDataClass(s,l),this._nodes.set(s,u),this.emit("nodeAdded",{key:s,attributes:l}),[s,!0])},f.updateNode=function(s,l){if(l&&typeof l!="function")throw new U('Graph.updateNode: invalid updater function. Expecting a function but got "'.concat(l,'"'));s=""+s;var u=this._nodes.get(s);if(u){if(l){var E=u.attributes;u.attributes=l(E),this.emit("nodeAttributesUpdated",{type:"replace",key:s,attributes:u.attributes})}return[s,!1]}var m=l?l({}):{};return u=new this.NodeDataClass(s,m),this._nodes.set(s,u),this.emit("nodeAdded",{key:s,attributes:m}),[s,!0]},f.dropNode=function(s){s=""+s;var l,u=this._nodes.get(s);if(!u)throw new R('Graph.dropNode: could not find the "'.concat(s,'" node in the graph.'));if(this.type!=="undirected"){for(var E in u.out){l=u.out[E];do $s(this,l),l=l.next;while(l)}for(var m in u.in){l=u.in[m];do $s(this,l),l=l.next;while(l)}}if(this.type!=="directed")for(var $ in u.undirected){l=u.undirected[$];do $s(this,l),l=l.next;while(l)}this._nodes.delete(s),this.emit("nodeDropped",{key:s,attributes:u.attributes})},f.dropEdge=function(s){var l;if(arguments.length>1){var u=""+arguments[0],E=""+arguments[1];if(!(l=A(this,u,E,this.type)))throw new R('Graph.dropEdge: could not find the "'.concat(u,'" -> "').concat(E,'" edge in the graph.'))}else if(s=""+s,!(l=this._edges.get(s)))throw new R('Graph.dropEdge: could not find the "'.concat(s,'" edge in the graph.'));return $s(this,l),this},f.dropDirectedEdge=function(s,l){if(arguments.length<2)throw new J("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new J("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");var u=A(this,s=""+s,l=""+l,"directed");if(!u)throw new R('Graph.dropDirectedEdge: could not find a "'.concat(s,'" -> "').concat(l,'" edge in the graph.'));return $s(this,u),this},f.dropUndirectedEdge=function(s,l){if(arguments.length<2)throw new J("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new J("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");var u=A(this,s,l,"undirected");if(!u)throw new R('Graph.dropUndirectedEdge: could not find a "'.concat(s,'" -> "').concat(l,'" edge in the graph.'));return $s(this,u),this},f.clear=function(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")},f.clearEdges=function(){for(var s,l=this._nodes.values();(s=l.next()).done!==!0;)s.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")},f.getAttribute=function(s){return this._attributes[s]},f.getAttributes=function(){return this._attributes},f.hasAttribute=function(s){return this._attributes.hasOwnProperty(s)},f.setAttribute=function(s,l){return this._attributes[s]=l,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:s}),this},f.updateAttribute=function(s,l){if(typeof l!="function")throw new U("Graph.updateAttribute: updater should be a function.");var u=this._attributes[s];return this._attributes[s]=l(u),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:s}),this},f.removeAttribute=function(s){return delete this._attributes[s],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:s}),this},f.replaceAttributes=function(s){if(!P(s))throw new U("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=s,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this},f.mergeAttributes=function(s){if(!P(s))throw new U("Graph.mergeAttributes: provided attributes are not a plain object.");return O(this._attributes,s),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:s}),this},f.updateAttributes=function(s){if(typeof s!="function")throw new U("Graph.updateAttributes: provided updater is not a function.");return this._attributes=s(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this},f.updateEachNodeAttributes=function(s,l){if(typeof s!="function")throw new U("Graph.updateEachNodeAttributes: expecting an updater function.");if(l&&!us(l))throw new U("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");for(var u,E,m=this._nodes.values();(u=m.next()).done!==!0;)(E=u.value).attributes=s(E.key,E.attributes);this.emit("eachNodeAttributesUpdated",{hints:l||null})},f.updateEachEdgeAttributes=function(s,l){if(typeof s!="function")throw new U("Graph.updateEachEdgeAttributes: expecting an updater function.");if(l&&!us(l))throw new U("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");for(var u,E,m,$,M=this._edges.values();(u=M.next()).done!==!0;)m=(E=u.value).source,$=E.target,E.attributes=s(E.key,E.attributes,m.key,$.key,m.attributes,$.attributes,E.undirected);this.emit("eachEdgeAttributesUpdated",{hints:l||null})},f.forEachAdjacencyEntry=function(s){if(typeof s!="function")throw new U("Graph.forEachAdjacencyEntry: expecting a callback.");Ds(!1,!1,!1,this,s)},f.forEachAdjacencyEntryWithOrphans=function(s){if(typeof s!="function")throw new U("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");Ds(!1,!1,!0,this,s)},f.forEachAssymetricAdjacencyEntry=function(s){if(typeof s!="function")throw new U("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");Ds(!1,!0,!1,this,s)},f.forEachAssymetricAdjacencyEntryWithOrphans=function(s){if(typeof s!="function")throw new U("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");Ds(!1,!0,!0,this,s)},f.nodes=function(){return typeof Array.from=="function"?Array.from(this._nodes.keys()):js(this._nodes.keys(),this._nodes.size)},f.forEachNode=function(s){if(typeof s!="function")throw new U("Graph.forEachNode: expecting a callback.");for(var l,u,E=this._nodes.values();(l=E.next()).done!==!0;)s((u=l.value).key,u.attributes)},f.findNode=function(s){if(typeof s!="function")throw new U("Graph.findNode: expecting a callback.");for(var l,u,E=this._nodes.values();(l=E.next()).done!==!0;)if(s((u=l.value).key,u.attributes))return u.key},f.mapNodes=function(s){if(typeof s!="function")throw new U("Graph.mapNode: expecting a callback.");for(var l,u,E=this._nodes.values(),m=new Array(this.order),$=0;(l=E.next()).done!==!0;)u=l.value,m[$++]=s(u.key,u.attributes);return m},f.someNode=function(s){if(typeof s!="function")throw new U("Graph.someNode: expecting a callback.");for(var l,u,E=this._nodes.values();(l=E.next()).done!==!0;)if(s((u=l.value).key,u.attributes))return!0;return!1},f.everyNode=function(s){if(typeof s!="function")throw new U("Graph.everyNode: expecting a callback.");for(var l,u,E=this._nodes.values();(l=E.next()).done!==!0;)if(!s((u=l.value).key,u.attributes))return!1;return!0},f.filterNodes=function(s){if(typeof s!="function")throw new U("Graph.filterNodes: expecting a callback.");for(var l,u,E=this._nodes.values(),m=[];(l=E.next()).done!==!0;)s((u=l.value).key,u.attributes)&&m.push(u.key);return m},f.reduceNodes=function(s,l){if(typeof s!="function")throw new U("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new U("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");for(var u,E,m=l,$=this._nodes.values();(u=$.next()).done!==!0;)m=s(m,(E=u.value).key,E.attributes);return m},f.nodeEntries=function(){var s=this._nodes.values();return new c(function(){var l=s.next();if(l.done)return l;var u=l.value;return{value:{node:u.key,attributes:u.attributes},done:!1}})},f.export=function(){var s=this,l=new Array(this._nodes.size),u=0;this._nodes.forEach(function(m,$){l[u++]=function(M,x){var y={key:M};return a(x.attributes)||(y.attributes=O({},x.attributes)),y}($,m)});var E=new Array(this._edges.size);return u=0,this._edges.forEach(function(m,$){E[u++]=function(M,x,y){var k={key:x,source:y.source.key,target:y.target.key};return a(y.attributes)||(k.attributes=O({},y.attributes)),M==="mixed"&&y.undirected&&(k.undirected=!0),k}(s.type,$,m)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:l,edges:E}},f.import=function(s){var l,u,E,m,$,M=this,x=arguments.length>1&&arguments[1]!==void 0&&arguments[1];if(s instanceof g)return s.forEachNode(function(o,e){x?M.mergeNode(o,e):M.addNode(o,e)}),s.forEachEdge(function(o,e,Us,Hs,dl,Il,Fs){x?Fs?M.mergeUndirectedEdgeWithKey(o,Us,Hs,e):M.mergeDirectedEdgeWithKey(o,Us,Hs,e):Fs?M.addUndirectedEdgeWithKey(o,Us,Hs,e):M.addDirectedEdgeWithKey(o,Us,Hs,e)}),this;if(!P(s))throw new U("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(s.attributes){if(!P(s.attributes))throw new U("Graph.import: invalid attributes. Expecting a plain object.");x?this.mergeAttributes(s.attributes):this.replaceAttributes(s.attributes)}if(s.nodes){if(E=s.nodes,!Array.isArray(E))throw new U("Graph.import: invalid nodes. Expecting an array.");for(l=0,u=E.length;l<u;l++){hl(m=E[l]);var y=m,k=y.key,C=y.attributes;x?this.mergeNode(k,C):this.addNode(k,C)}}if(s.edges){var X=!1;if(this.type==="undirected"&&(X=!0),E=s.edges,!Array.isArray(E))throw new U("Graph.import: invalid edges. Expecting an array.");for(l=0,u=E.length;l<u;l++){Jl($=E[l]);var V=$,S=V.source,z=V.target,w=V.attributes,F=V.undirected,n=F===void 0?X:F;"key"in $?(x?n?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:n?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey).call(this,$.key,S,z,w):(x?n?this.mergeUndirectedEdge:this.mergeDirectedEdge:n?this.addUndirectedEdge:this.addDirectedEdge).call(this,S,z,w)}}return this},f.nullCopy=function(s){var l=new g(O({},this._options,s));return l.replaceAttributes(O({},this.getAttributes())),l},f.emptyCopy=function(s){var l=this.nullCopy(s);return this._nodes.forEach(function(u,E){var m=O({},u.attributes);u=new l.NodeDataClass(E,m),l._nodes.set(E,u)}),l},f.copy=function(s){if(typeof(s=s||{}).type=="string"&&s.type!==this.type&&s.type!=="mixed")throw new J('Graph.copy: cannot create an incompatible copy from "'.concat(this.type,'" type to "').concat(s.type,'" because this would mean losing information about the current graph.'));if(typeof s.multi=="boolean"&&s.multi!==this.multi&&s.multi!==!0)throw new J("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if(typeof s.allowSelfLoops=="boolean"&&s.allowSelfLoops!==this.allowSelfLoops&&s.allowSelfLoops!==!0)throw new J("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");for(var l,u,E=this.emptyCopy(s),m=this._edges.values();(l=m.next()).done!==!0;)Gs(E,"copy",!1,(u=l.value).undirected,u.key,u.source.key,u.target.key,O({},u.attributes));return E},f.toJSON=function(){return this.export()},f.toString=function(){return"[object Graph]"},f.inspect=function(){var s=this,l={};this._nodes.forEach(function(M,x){l[x]=M.attributes});var u={},E={};this._edges.forEach(function(M,x){var y,k=M.undirected?"--":"->",C="",X=M.source.key,V=M.target.key;M.undirected&&X>V&&(y=X,X=V,V=y);var S="(".concat(X,")").concat(k,"(").concat(V,")");x.startsWith("geid_")?s.multi&&(E[S]===void 0?E[S]=0:E[S]++,C+="".concat(E[S],". ")):C+="[".concat(x,"]: "),u[C+=S]=M.attributes});var m={};for(var $ in this)this.hasOwnProperty($)&&!cs.has($)&&typeof this[$]!="function"&&D($)!=="symbol"&&(m[$]=this[$]);return m.attributes=this._attributes,m.nodes=l,m.edges=u,K(m,"constructor",this.constructor),m},g}(ls.exports.EventEmitter);typeof Symbol!="undefined"&&(_.prototype[Symbol.for("nodejs.util.inspect.custom")]=_.prototype.inspect),[{name:function(b){return"".concat(b,"Edge")},generateKey:!0},{name:function(b){return"".concat(b,"DirectedEdge")},generateKey:!0,type:"directed"},{name:function(b){return"".concat(b,"UndirectedEdge")},generateKey:!0,type:"undirected"},{name:function(b){return"".concat(b,"EdgeWithKey")}},{name:function(b){return"".concat(b,"DirectedEdgeWithKey")},type:"directed"},{name:function(b){return"".concat(b,"UndirectedEdgeWithKey")},type:"undirected"}].forEach(function(b){["add","merge","update"].forEach(function(g){var f=b.name(g),s=g==="add"?Gs:Zl;b.generateKey?_.prototype[f]=function(l,u,E){return s(this,f,!0,(b.type||this.type)==="undirected",null,l,u,E,g==="update")}:_.prototype[f]=function(l,u,E,m){return s(this,f,!1,(b.type||this.type)==="undirected",l,u,E,m,g==="update")}})}),function(b){El.forEach(function(g){var{name:f,attacher:s}=g;s(b,f("Node"),0),s(b,f("Source"),1),s(b,f("Target"),2),s(b,f("Opposite"),3)})}(_),function(b){ml.forEach(function(g){var{name:f,attacher:s}=g;s(b,f("Edge"),"mixed"),s(b,f("DirectedEdge"),"directed"),s(b,f("UndirectedEdge"),"undirected")})}(_),function(b){xl.forEach(function(g){(function(f,s){var{name:l,type:u,direction:E}=s;f.prototype[l]=function(m,$){if(u!=="mixed"&&this.type!=="mixed"&&u!==this.type)return[];if(!arguments.length)return Cl(this,u);if(arguments.length===1){m=""+m;var M=this._nodes.get(m);if(M===void 0)throw new R("Graph.".concat(l,': could not find the "').concat(m,'" node in the graph.'));return Dl(this.multi,u==="mixed"?this.type:u,E,M)}if(arguments.length===2){m=""+m,$=""+$;var x=this._nodes.get(m);if(!x)throw new R("Graph.".concat(l,':  could not find the "').concat(m,'" source node in the graph.'));if(!this._nodes.has($))throw new R("Graph.".concat(l,':  could not find the "').concat($,'" target node in the graph.'));return Hl(u,this.multi,E,x,$)}throw new U("Graph.".concat(l,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."))}})(b,g),function(f,s){var{name:l,type:u,direction:E}=s,m="forEach"+l[0].toUpperCase()+l.slice(1,-1);f.prototype[m]=function(y,k,C){if(u==="mixed"||this.type==="mixed"||u===this.type){if(arguments.length===1)return _s(!1,this,u,C=y);if(arguments.length===2){y=""+y,C=k;var X=this._nodes.get(y);if(X===void 0)throw new R("Graph.".concat(m,': could not find the "').concat(y,'" node in the graph.'));return hs(!1,this.multi,u==="mixed"?this.type:u,E,X,C)}if(arguments.length===3){y=""+y,k=""+k;var V=this._nodes.get(y);if(!V)throw new R("Graph.".concat(m,':  could not find the "').concat(y,'" source node in the graph.'));if(!this._nodes.has(k))throw new R("Graph.".concat(m,':  could not find the "').concat(k,'" target node in the graph.'));return Js(!1,u,this.multi,E,V,k,C)}throw new U("Graph.".concat(m,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."))}};var $="map"+l[0].toUpperCase()+l.slice(1);f.prototype[$]=function(){var y,k=Array.prototype.slice.call(arguments),C=k.pop();if(k.length===0){var X=0;u!=="directed"&&(X+=this.undirectedSize),u!=="undirected"&&(X+=this.directedSize),y=new Array(X);var V=0;k.push(function(S,z,w,F,n,o,e){y[V++]=C(S,z,w,F,n,o,e)})}else y=[],k.push(function(S,z,w,F,n,o,e){y.push(C(S,z,w,F,n,o,e))});return this[m].apply(this,k),y};var M="filter"+l[0].toUpperCase()+l.slice(1);f.prototype[M]=function(){var y=Array.prototype.slice.call(arguments),k=y.pop(),C=[];return y.push(function(X,V,S,z,w,F,n){k(X,V,S,z,w,F,n)&&C.push(X)}),this[m].apply(this,y),C};var x="reduce"+l[0].toUpperCase()+l.slice(1);f.prototype[x]=function(){var y,k,C=Array.prototype.slice.call(arguments);if(C.length<2||C.length>4)throw new U("Graph.".concat(x,": invalid number of arguments (expecting 2, 3 or 4 and got ").concat(C.length,")."));if(typeof C[C.length-1]=="function"&&typeof C[C.length-2]!="function")throw new U("Graph.".concat(x,": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));C.length===2?(y=C[0],k=C[1],C=[]):C.length===3?(y=C[1],k=C[2],C=[C[0]]):C.length===4&&(y=C[2],k=C[3],C=[C[0],C[1]]);var X=k;return C.push(function(V,S,z,w,F,n,o){X=y(X,V,S,z,w,F,n,o)}),this[m].apply(this,C),X}}(b,g),function(f,s){var{name:l,type:u,direction:E}=s,m="find"+l[0].toUpperCase()+l.slice(1,-1);f.prototype[m]=function(x,y,k){if(u!=="mixed"&&this.type!=="mixed"&&u!==this.type)return!1;if(arguments.length===1)return _s(!0,this,u,k=x);if(arguments.length===2){x=""+x,k=y;var C=this._nodes.get(x);if(C===void 0)throw new R("Graph.".concat(m,': could not find the "').concat(x,'" node in the graph.'));return hs(!0,this.multi,u==="mixed"?this.type:u,E,C,k)}if(arguments.length===3){x=""+x,y=""+y;var X=this._nodes.get(x);if(!X)throw new R("Graph.".concat(m,':  could not find the "').concat(x,'" source node in the graph.'));if(!this._nodes.has(y))throw new R("Graph.".concat(m,':  could not find the "').concat(y,'" target node in the graph.'));return Js(!0,u,this.multi,E,X,y,k)}throw new U("Graph.".concat(m,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."))};var $="some"+l[0].toUpperCase()+l.slice(1,-1);f.prototype[$]=function(){var x=Array.prototype.slice.call(arguments),y=x.pop();return x.push(function(k,C,X,V,S,z,w){return y(k,C,X,V,S,z,w)}),!!this[m].apply(this,x)};var M="every"+l[0].toUpperCase()+l.slice(1,-1);f.prototype[M]=function(){var x=Array.prototype.slice.call(arguments),y=x.pop();return x.push(function(k,C,X,V,S,z,w){return!y(k,C,X,V,S,z,w)}),!this[m].apply(this,x)}}(b,g),function(f,s){var{name:l,type:u,direction:E}=s,m=l.slice(0,-1)+"Entries";f.prototype[m]=function($,M){if(u!=="mixed"&&this.type!=="mixed"&&u!==this.type)return c.empty();if(!arguments.length)return Tl(this,u);if(arguments.length===1){$=""+$;var x=this._nodes.get($);if(!x)throw new R("Graph.".concat(m,': could not find the "').concat($,'" node in the graph.'));return Ul(u,E,x)}if(arguments.length===2){$=""+$,M=""+M;var y=this._nodes.get($);if(!y)throw new R("Graph.".concat(m,':  could not find the "').concat($,'" source node in the graph.'));if(!this._nodes.has(M))throw new R("Graph.".concat(m,':  could not find the "').concat(M,'" target node in the graph.'));return vl(u,E,y,M)}throw new U("Graph.".concat(m,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."))}}(b,g)})}(_),function(b){ql.forEach(function(g){Yl(b,g),function(f,s){var{name:l,type:u,direction:E}=s,m="forEach"+l[0].toUpperCase()+l.slice(1,-1);f.prototype[m]=function(y,k){if(u==="mixed"||this.type==="mixed"||u===this.type){y=""+y;var C=this._nodes.get(y);if(C===void 0)throw new R("Graph.".concat(m,': could not find the "').concat(y,'" node in the graph.'));Xs(!1,u==="mixed"?this.type:u,E,C,k)}};var $="map"+l[0].toUpperCase()+l.slice(1);f.prototype[$]=function(y,k){var C=[];return this[m](y,function(X,V){C.push(k(X,V))}),C};var M="filter"+l[0].toUpperCase()+l.slice(1);f.prototype[M]=function(y,k){var C=[];return this[m](y,function(X,V){k(X,V)&&C.push(X)}),C};var x="reduce"+l[0].toUpperCase()+l.slice(1);f.prototype[x]=function(y,k,C){if(arguments.length<3)throw new U("Graph.".concat(x,": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));var X=C;return this[m](y,function(V,S){X=k(X,V,S)}),X}}(b,g),function(f,s){var{name:l,type:u,direction:E}=s,m=l[0].toUpperCase()+l.slice(1,-1),$="find"+m;f.prototype[$]=function(y,k){if(u==="mixed"||this.type==="mixed"||u===this.type){y=""+y;var C=this._nodes.get(y);if(C===void 0)throw new R("Graph.".concat($,': could not find the "').concat(y,'" node in the graph.'));return Xs(!0,u==="mixed"?this.type:u,E,C,k)}};var M="some"+m;f.prototype[M]=function(y,k){return!!this[$](y,k)};var x="every"+m;f.prototype[x]=function(y,k){return!this[$](y,function(C,X){return!k(C,X)})}}(b,g),Wl(b,g)})}(_);var ws=function(b){function g(f){var s=O({type:"directed"},f);if("multi"in s&&s.multi!==!1)throw new U("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(s.type!=="directed")throw new U('DirectedGraph.from: inconsistent "'+s.type+'" type in given options!');return b.call(this,s)||this}return q(g,b),g}(_),zs=function(b){function g(f){var s=O({type:"undirected"},f);if("multi"in s&&s.multi!==!1)throw new U("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(s.type!=="undirected")throw new U('UndirectedGraph.from: inconsistent "'+s.type+'" type in given options!');return b.call(this,s)||this}return q(g,b),g}(_),ds=function(b){function g(f){var s=O({multi:!0},f);if("multi"in s&&s.multi!==!0)throw new U("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");return b.call(this,s)||this}return q(g,b),g}(_),Is=function(b){function g(f){var s=O({type:"directed",multi:!0},f);if("multi"in s&&s.multi!==!0)throw new U("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(s.type!=="directed")throw new U('MultiDirectedGraph.from: inconsistent "'+s.type+'" type in given options!');return b.call(this,s)||this}return q(g,b),g}(_),Bs=function(b){function g(f){var s=O({type:"undirected",multi:!0},f);if("multi"in s&&s.multi!==!0)throw new U("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(s.type!=="undirected")throw new U('MultiUndirectedGraph.from: inconsistent "'+s.type+'" type in given options!');return b.call(this,s)||this}return q(g,b),g}(_);function ys(b){b.from=function(g,f){var s=O({},g.options,f),l=new b(s);return l.import(g),l}}return ys(_),ys(ws),ys(zs),ys(ds),ys(Is),ys(Bs),_.Graph=_,_.DirectedGraph=ws,_.UndirectedGraph=zs,_.MultiGraph=ds,_.MultiDirectedGraph=Is,_.MultiUndirectedGraph=Bs,_.InvalidArgumentsGraphError=U,_.NotFoundGraphError=R,_.UsageGraphError=J,_})});function as(D,q){D=D.trim(),D=D.replace(/<!--[\s\S]*?-->/g,"");let Y={declaration:void 0,root:void 0};Y.declaration=W();let H=D.match(/<!\[CDATA\[[\s\S]*?\]\]>/gm);if(H)for(let v of H)D=D.replace(v,h(v));let Q=O(D);if(Q)if(Q.children.length===1&&typeof Q.children[0]!=="string")Y.root=Q.children[0];else throw new Error("XML源码不符合规范：有不止1个根节点");if(Y.root&&q===!0)I(Y.root);return Y;function h(v){return`<![CDATA[${v.split("<![CDATA[")[1].split("]]>")[0].replace(/</,"[_*[$(<)$]*_]").replace(/>/,"[_*[$(>)$]*_]").replace(/\//,"[_*[$(/)$]*_]").replace(/\\/,"[_*[$(LS)$]*_]")}]]>`}function j(v){let Z=v.match(/<!\[CDATA\[[\s\S]*?\]\]>/gm);if(Z)for(let L of Z){let T=L.split("<![CDATA[")[1].split("]]>")[0].replace(/\[_\*\[\$\(<\)\$\]\*\_]/,"<").replace(/\[_\*\[\$\(>\)\$\]\*_]/,">").replace(/\[_\*\[\$\(\/\)\$\]\*_]/,"/").replace(/\[_\*\[\$\(LS\)\$\]\*_]/,"\\");v=v.replace(L,`<![CDATA[${T}]]>`)}return v}function W(){let v="",Z=D.match(/^<\?xml[\s\S]*\?>/m);if(!Z)return;else v=Z[0],D=D.slice(v.length);let L={name:""};if(i(v,L),L.attributes)return{attributes:L.attributes};return}function O(v){let Z=[],L=!0;while(L){let T=K(v);if(!T)L=!1;else{let N="",p=void 0;if(T.type==="selfClose")N=T.str,p=A(N,T.name,!0);if(T.type==="normal")N=T.strs.outer,p=A(T.strs,T.name,!1);if(p)Z.push(p);v=v.replace(N,"")}}if(v=v.replace(/[\r\n]/g,"").trim(),Z.length===0)return;else return{children:Z,strLeft:v}}function A(v,Z,L){let T={name:Z};if(L===!0)P(v,T);else a(v,T);return T}function P(v,Z){i(v,Z)}function a(v,Z){i(v.attrs,Z);let L=v.inner;if(L.match(/<(?<tag>[\w:]+)([^<^>])*?\/>/m)||L.match(/<(?<tag>[\w:]+)[\s\S]*?>[\s\S]*?<\/\k<tag>*?>/m)){let T=O(L);if(T){if(T.children&&T.children.length>0)Z.children=T.children;if(T.strLeft!=="")T.strLeft=T.strLeft.replace(/[\r\n]/g,"").trim(),Z.content=j(T.strLeft)}}else if(L!=="")L=L.replace(/[\r\n]/g,"").trim(),Z.content=j(L)}function K(v){let Z=v.match(/<([\w-:.]+)\s*/m);if(!Z)return;else{let L=Z[1],T=d(v,L);if(T)return{type:"selfClose",name:L,str:T};let N=us(v,L);if(N)return{type:"normal",name:L,strs:N};return}}function d(v,Z){let L=new RegExp(`<${Z}[^<^>]*?/>`,"m"),T=v.match(L);if(!T)return;else return T[0]}function us(v,Z){let T=new RegExp(`<${Z}([\\s\\S]*?)>([\\s\\S]*?)</${Z}>`,"gm").exec(v);if(!T)return;else return{outer:T[0],attrs:T[1],inner:T[2]}}function i(v,Z){let L=!0;while(L){let T=v.match(/([\w:-]+)\s*=\s*("[^"]*"|'[^']*'|\w+)\s*/);if(!T)L=!1;else{if(!Z.attributes)Z.attributes={};Z.attributes[T[1]]=ls(T[2]),v=v.replace(T[0],"")}}}function ls(v){return v.replace(/^['"]|['"]$/g,"")}function I(v,Z){let L={};if(Z)for(let T of Object.keys(Z))L[T]=Z[T];if(v.attributes){let T=Object.keys(v.attributes);for(let N of T){if(N==="xmlns")L._=v.attributes[N];if(N.indexOf("xmlns:")===0){let p=N.replace("xmlns:","");L[p]=v.attributes[N]}}}if(v.name.indexOf(":")<0){if(L._)v.name=L._+v.name}else if(v.name.indexOf(":")>0&&v.name.split(":")[0]!=="http"&&v.name.split(":")[0]!=="https"){let T=v.name.split(":")[0];if(L[T])v.name=v.name.replace(`${T}:`,`${L[T]}`)}if(v.children)for(let T of v.children)I(T,L)}}var _l=async(D)=>{try{let q=await fetch(D);if(!q.ok)throw new Error(`Network response was not ok, status: ${q.status}`);return await q.text()}catch(q){console.error("There was a problem with the fetch operation:",q)}},is=async(D)=>{let q=await _l(D);if(!q)throw new Error("Could not get XML contents.");return as(q)};var ns=Pl(rs(),1),es=(D)=>{let q=new ns.default({multi:!0}),Y={};for(let H of D){let{id:Q,source:h,target:j,value:W,edge:O,style:A}=H.attributes||{},P=A&&A.startsWith("edgeLabel");if(!O&&!P&&W!==void 0&&h===void 0&&j===void 0)q.addNode(Q,{label:W,style:A})}for(let H of D){let{id:Q,source:h,target:j,value:W,edge:O}=H.attributes||{};if(O&&h!==void 0&&j!==void 0){if(W!==null)q.addEdgeWithKey(Q,h,j,{label:W});else q.addEdgeWithKey(Q,h,j);Y[Q]=Q}}for(let H of D){let{parent:Q,value:h,style:j}=H.attributes||{};if(j&&j.startsWith("edgeLabel")&&Q!==void 0&&h!==void 0&&Q in Y)q.setEdgeAttribute(Q,"label",h),console.log(Q,h)}return q};var Zs=(D)=>{let q=[["amp","&"],["apos","'"],["#x27","'"],["#x2F","/"],["#39","'"],["#47","/"],["lt","<"],["gt",">"],["nbsp"," "],["quot",'"']];for(var Y=0,H=q.length;Y<H;++Y)D=D.replace(new RegExp("&"+q[Y][0]+";","g"),q[Y][1]);return D};var Cs=(D)=>Zs(D.trim()).replace(/<\/?div>/g,`
`).replaceAll("<br>",`
`),ts=(D)=>{let Y=/image=([^;]+)/.exec(D),H=Y?Y[1]:null;if(!H)return"";let h=/alt=([^;]+)/.exec(D),j=h?h[1]:"Zark image",W="",A=/zarbAssetWidth=([^;]+)/.exec(D),P=A?A[1]:null;return W+=`width: ${P};`,`<img src="${H.startsWith("https://")?H:"https://"+H}" alt="${j}" style="${W}">`},sl=(D)=>{let q={},Y=D.split(`
`);for(let H=0;H<Y.length;H++){let Q=Y[H].trim();if(Q==="")continue;let h=Q.split(":");if(h.length!==2){console.warn(`Hey Squambo, line ${H} of the following dict string has an invalid syntax!`,D);continue}let[j,W]=h;j=j.trim(),W=W.trim();let O=W==="true",A=parseFloat(W);if(O||W==="false")q[j]=O;else if(!Number.isNaN(A))q[j]=A;else q[j]=W}return q},vs=(D,q)=>{let Y=document.createElement("button");return Y.style.display="block",Y.tabIndex=0,Y.innerHTML=`&gt; ${D}`,Y.className="zark-option",Y.addEventListener("click",q),Y},Sl=(D)=>{let q={">":(Y,H)=>Y>H,"<":(Y,H)=>Y<H,"<=":(Y,H)=>Y>=H,">=":(Y,H)=>Y<=H,"==":(Y,H)=>Y==H,"=":(Y,H)=>Y==H,"===":(Y,H)=>Y==H,":":(Y,H)=>Y==H};for(let Y of Object.keys(q).sort((H,Q)=>Q.length-H.length)){let H=D.split(Y);if(H.length<2)continue;let[Q,h]=[H[0],parseFloat(H[1])];if(Number.isNaN(h))continue;let j=q[Y];return{left:Q,right:h,func:j}}},cl=(D)=>{D=Cs(D);let q=(j)=>!0,Y=D,H=/\[!if:(?<conditionText>.*?)\]/,h=D.match(H)?.groups?.conditionText;if(h){Y=D.replace(H,"");let j=h.indexOf("items:");if(console.log({itemCheckIndex:j,optionText:Y,conditionText:h}),j>=0)q=(W)=>{return h.substring(j+6)in W.items};else q=(W)=>{let O=Sl(h);if(O===void 0)return console.warn("Squambo, a conditional expression failed to parse:",h),!1;let{left:A,right:P,func:a}=O;return console.log({left:W.player[A],right:P,func:a}),a(W.player[A],P)}}return{condition:q,optionText:Y}},ll=(D)=>{let q=document.getElementById("game-container"),Y=document.getElementById("current-node"),H=document.getElementById("value"),Q=document.getElementById("decisions"),h={currentNode:[...D.nodes()][0],items:{},equppedItems:[],player:{health:100,get attack(){return Object.values(h.items).reduce((W,O)=>W+(typeof O.attack==="number"&&O.attack||0),0)}},enemy:void 0,enemyJustDefeated:!1,pacifist:!1},j={};return D.forEachNode((W,O)=>{let{label:A,style:P}=O;if(!A||!P)return;if(!(P.indexOf("rhombus")>=0&&A.indexOf("GOTO:")<0))return;let K=Cs(A);j[K]=W}),function W(){if(!q||!Y||!H||!Q)throw new Error("Did not find expected DOM elements.");console.log(h);let O=D.getNodeAttribute(h.currentNode,"label"),A=D.getNodeAttribute(h.currentNode,"style"),P=!0,a=!1;if(A.indexOf("rhombus")>=0)P=!1,a=!0;let K=Zs(O),d=O.indexOf("GOTO:");if(d>=0){let L=Cs(O.substring(d+5)).trim(),T=L in j&&j[L];if(T&&D.hasNode(T)){h.currentNode=T,W();return}else console.log(`Psst, hey Squambo. The user just tried to go to "${L}", which gave node "${T}".`)}let us=O.indexOf("ITEM:");if(us>=0){let L=sl(Cs(O.substring(us+5)));K=`You got a ${L.name.toUpperCase()}.<br>`,K+='<div class="zarkbox">';for(let T in L)K+=`${T.toUpperCase()}: ${L[T]}<br>`;K+="</div>",h.items[L.name]=L,console.log(h.items,h.player.attack)}let i=h.enemy,ls=O.indexOf("ENEMY:");if(i===void 0&&!h.enemyJustDefeated&&!h.pacifist&&ls>=0)i=sl(Cs(O.substring(ls+6))),h.enemy=i;if(h.enemyJustDefeated=!1,i!==void 0){let L=!0,T=void 0,N=!1,p=void 0,r=0,gs=!1,bs=function(G,fs){if(G===void 0)return!1;if(T===void 0&&fs!==void 0)T=fs;fs??=0,r=(fs-(T??fs))/1000;let xs=document.getElementById("time");if(xs)xs.innerHTML=`<div>game time: ${r.toFixed(2)}</div> <div>last dodged time: ${p}</div> <div>time til next hit: ${Math.max(0,2-r%3).toFixed(2)}</div><hr>`;let Ms=h.player;if(K="",console.log(p),G?.health>0&&Math.floor(r)%3===2){if(!N){if(p===void 0||Math.abs(p-r)>0.5)K="You got hit!",h.player.health-=G.attack,L=!0,N=!0;else if(p!==void 0)p=void 0,K="Excellent dodge!<br>",L=!0,N=!0,gs=!0}}else if(N)N=!1,L=!0,gs=!1;if(!L){requestAnimationFrame((c)=>bs(G,c));return}L=!1;let B=!0;if(Q.innerHTML="",N&&!gs);else if(h.player.health<=0)K+="You died!";else if(G.health<=0){K+=`Excellent, you defeated the ${G.name}`;let c=vs("Continue...",()=>{h.enemy=G=void 0,h.enemyJustDefeated=!0,W()});Q.appendChild(c),B=!1}else{K+=`Holy shit it's a fuckign ${G.name.toUpperCase()}.<br>`,K+='<div class="zarkbox">';for(let Es in G)K+=`${Es.toUpperCase()}: ${G[Es]}<br>`;K+="</div>",K+='<div class="zarkbox">',K+="YOU<br>";for(let Es in Ms)K+=`${Es.toUpperCase()}: ${Ms[Es]}<br>`;K+="</div>";let c=vs("ATTACK",()=>{G.health-=h.player.attack,console.log("attack",G.health),L=!0});Q.appendChild(c);let Ls=vs("DODGE",()=>{p=r,console.log({dodgedT:p,t:r})});Q.appendChild(Ls)}return H.innerHTML=K,H.innerHTML+=ts(A),H.innerHTML+='<div id="time"></div>',requestAnimationFrame((c)=>bs(G,c)),B};if(bs(i))return}if(P)H.innerHTML=K,H.innerHTML+=ts(A);let I=Array.from(D.outNeighbors(h.currentNode)),v=D.outEdges(h.currentNode);if(I.length===0){H.innerHTML+="<p>[That's all for now.]</p>",Q.innerHTML="";return}Q.innerHTML="<p>Decisions:</p>";let Z=!0;if(v.forEach((L)=>{let T=D.getEdgeAttributes(L),N=D.target(L),p="label"in T&&T.label,r=p?T.label:N,{optionText:gs,condition:bs}=cl(r);if(!bs(h))return;Z=Z&&!p;let G=vs(gs,()=>{h.currentNode=N,W()});Q.appendChild(G)}),Z){let L=Math.floor(Math.random()*I.length),T=I[L];if(a){h.currentNode=T,W();return}Q.innerHTML="<p>Decisions:</p>";let N=document.createElement("button");N.tabIndex=0,N.innerHTML="&gt; The only option is to continue...",N.addEventListener("click",()=>{h.currentNode=T,W()}),Q.appendChild(N)}}};var pl="assets/ZARK.drawio.xml",Gl=await is(pl),bl=Gl.root?.children[0].children[0].children[0].children;if(!bl)throw new Error("The tree did not have the expected format.");var wl=es(bl),zl=ll(wl);zl();
