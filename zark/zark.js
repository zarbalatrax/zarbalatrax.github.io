var x0=Object.create;var{getPrototypeOf:g0,defineProperty:FE,getOwnPropertyNames:G0}=Object;var v0=Object.prototype.hasOwnProperty;var w0=(K,V,v)=>{v=K!=null?x0(g0(K)):{};let x=V||!K||!K.__esModule?FE(v,"default",{value:K,enumerable:!0}):v;for(let S of G0(K))if(!v0.call(x,S))FE(x,S,{get:()=>K[S],enumerable:!0});return x};var S0=(K,V)=>()=>(V||K((V={exports:{}}).exports,V),V.exports);var oE=S0((PE,KE)=>{(function(K,V){typeof PE=="object"&&typeof KE!="undefined"?KE.exports=V():typeof define=="function"&&define.amd?define(V):(K=typeof globalThis!="undefined"?globalThis:K||self).graphology=V()})(PE,function(){function K($){return K=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(M){return typeof M}:function(M){return M&&typeof Symbol=="function"&&M.constructor===Symbol&&M!==Symbol.prototype?"symbol":typeof M},K($)}function V($,M){$.prototype=Object.create(M.prototype),$.prototype.constructor=$,x($,M)}function v($){return v=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(M){return M.__proto__||Object.getPrototypeOf(M)},v($)}function x($,M){return x=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(b,E){return b.__proto__=E,b},x($,M)}function S(){if(typeof Reflect=="undefined"||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch($){return!1}}function w($,M,b){return w=S()?Reflect.construct.bind():function(E,L,R){var W=[null];W.push.apply(W,L);var D=new(Function.bind.apply(E,W));return R&&x(D,R.prototype),D},w.apply(null,arguments)}function h($){var M=typeof Map=="function"?new Map:void 0;return h=function(b){if(b===null||(E=b,Function.toString.call(E).indexOf("[native code]")===-1))return b;var E;if(typeof b!="function")throw new TypeError("Super expression must either be null or a function");if(M!==void 0){if(M.has(b))return M.get(b);M.set(b,L)}function L(){return w(b,arguments,v(this).constructor)}return L.prototype=Object.create(b.prototype,{constructor:{value:L,enumerable:!1,writable:!0,configurable:!0}}),x(L,b)},h($)}function _($){if($===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return $}var k=function(){for(var $=arguments[0],M=1,b=arguments.length;M<b;M++)if(arguments[M])for(var E in arguments[M])$[E]=arguments[M][E];return $};function y($,M,b,E){var L=$._nodes.get(M),R=null;return L?R=E==="mixed"?L.out&&L.out[b]||L.undirected&&L.undirected[b]:E==="directed"?L.out&&L.out[b]:L.undirected&&L.undirected[b]:R}function G($){return K($)==="object"&&$!==null}function r($){var M;for(M in $)return!1;return!0}function f($,M,b){Object.defineProperty($,M,{enumerable:!1,configurable:!1,writable:!0,value:b})}function I($,M,b){var E={enumerable:!0,configurable:!0};typeof b=="function"?E.get=b:(E.value=b,E.writable=!1),Object.defineProperty($,M,E)}function EE($){return!!G($)&&!($.attributes&&!Array.isArray($.attributes))}typeof Object.assign=="function"&&(k=Object.assign);var u,p={exports:{}},s=typeof Reflect=="object"?Reflect:null,P=s&&typeof s.apply=="function"?s.apply:function($,M,b){return Function.prototype.apply.call($,M,b)};u=s&&typeof s.ownKeys=="function"?s.ownKeys:Object.getOwnPropertySymbols?function($){return Object.getOwnPropertyNames($).concat(Object.getOwnPropertySymbols($))}:function($){return Object.getOwnPropertyNames($)};var A=Number.isNaN||function($){return $!=$};function Y(){Y.init.call(this)}p.exports=Y,p.exports.once=function($,M){return new Promise(function(b,E){function L(W){$.removeListener(M,R),E(W)}function R(){typeof $.removeListener=="function"&&$.removeListener("error",L),b([].slice.call(arguments))}yE($,M,R,{once:!0}),M!=="error"&&function(W,D,U){typeof W.on=="function"&&yE(W,"error",D,U)}($,L,{once:!0})})},Y.EventEmitter=Y,Y.prototype._events=void 0,Y.prototype._eventsCount=0,Y.prototype._maxListeners=void 0;var j=10;function l($){if(typeof $!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof $)}function n($){return $._maxListeners===void 0?Y.defaultMaxListeners:$._maxListeners}function TE($,M,b,E){var L,R,W,D;if(l(b),(R=$._events)===void 0?(R=$._events=Object.create(null),$._eventsCount=0):(R.newListener!==void 0&&($.emit("newListener",M,b.listener?b.listener:b),R=$._events),W=R[M]),W===void 0)W=R[M]=b,++$._eventsCount;else if(typeof W=="function"?W=R[M]=E?[b,W]:[W,b]:E?W.unshift(b):W.push(b),(L=n($))>0&&W.length>L&&!W.warned){W.warned=!0;var U=new Error("Possible EventEmitter memory leak detected. "+W.length+" "+String(M)+" listeners added. Use emitter.setMaxListeners() to increase limit");U.name="MaxListenersExceededWarning",U.emitter=$,U.type=M,U.count=W.length,D=U,console&&console.warn&&console.warn(D)}return $}function eE(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function VE($,M,b){var E={fired:!1,wrapFn:void 0,target:$,type:M,listener:b},L=eE.bind(E);return L.listener=b,E.wrapFn=L,L}function _E($,M,b){var E=$._events;if(E===void 0)return[];var L=E[M];return L===void 0?[]:typeof L=="function"?b?[L.listener||L]:[L]:b?function(R){for(var W=new Array(R.length),D=0;D<W.length;++D)W[D]=R[D].listener||R[D];return W}(L):kE(L,L.length)}function AE($){var M=this._events;if(M!==void 0){var b=M[$];if(typeof b=="function")return 1;if(b!==void 0)return b.length}return 0}function kE($,M){for(var b=new Array(M),E=0;E<M;++E)b[E]=$[E];return b}function yE($,M,b,E){if(typeof $.on=="function")E.once?$.once(M,b):$.on(M,b);else{if(typeof $.addEventListener!="function")throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof $);$.addEventListener(M,function L(R){E.once&&$.removeEventListener(M,L),b(R)})}}function i($){if(typeof $!="function")throw new Error("obliterator/iterator: expecting a function!");this.next=$}Object.defineProperty(Y,"defaultMaxListeners",{enumerable:!0,get:function(){return j},set:function($){if(typeof $!="number"||$<0||A($))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+$+".");j=$}}),Y.init=function(){this._events!==void 0&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},Y.prototype.setMaxListeners=function($){if(typeof $!="number"||$<0||A($))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+$+".");return this._maxListeners=$,this},Y.prototype.getMaxListeners=function(){return n(this)},Y.prototype.emit=function($){for(var M=[],b=1;b<arguments.length;b++)M.push(arguments[b]);var E=$==="error",L=this._events;if(L!==void 0)E=E&&L.error===void 0;else if(!E)return!1;if(E){var R;if(M.length>0&&(R=M[0]),R instanceof Error)throw R;var W=new Error("Unhandled error."+(R?" ("+R.message+")":""));throw W.context=R,W}var D=L[$];if(D===void 0)return!1;if(typeof D=="function")P(D,this,M);else{var U=D.length,H=kE(D,U);for(b=0;b<U;++b)P(H[b],this,M)}return!0},Y.prototype.addListener=function($,M){return TE(this,$,M,!1)},Y.prototype.on=Y.prototype.addListener,Y.prototype.prependListener=function($,M){return TE(this,$,M,!0)},Y.prototype.once=function($,M){return l(M),this.on($,VE(this,$,M)),this},Y.prototype.prependOnceListener=function($,M){return l(M),this.prependListener($,VE(this,$,M)),this},Y.prototype.removeListener=function($,M){var b,E,L,R,W;if(l(M),(E=this._events)===void 0)return this;if((b=E[$])===void 0)return this;if(b===M||b.listener===M)--this._eventsCount==0?this._events=Object.create(null):(delete E[$],E.removeListener&&this.emit("removeListener",$,b.listener||M));else if(typeof b!="function"){for(L=-1,R=b.length-1;R>=0;R--)if(b[R]===M||b[R].listener===M){W=b[R].listener,L=R;break}if(L<0)return this;L===0?b.shift():function(D,U){for(;U+1<D.length;U++)D[U]=D[U+1];D.pop()}(b,L),b.length===1&&(E[$]=b[0]),E.removeListener!==void 0&&this.emit("removeListener",$,W||M)}return this},Y.prototype.off=Y.prototype.removeListener,Y.prototype.removeAllListeners=function($){var M,b,E;if((b=this._events)===void 0)return this;if(b.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):b[$]!==void 0&&(--this._eventsCount==0?this._events=Object.create(null):delete b[$]),this;if(arguments.length===0){var L,R=Object.keys(b);for(E=0;E<R.length;++E)(L=R[E])!=="removeListener"&&this.removeAllListeners(L);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(typeof(M=b[$])=="function")this.removeListener($,M);else if(M!==void 0)for(E=M.length-1;E>=0;E--)this.removeListener($,M[E]);return this},Y.prototype.listeners=function($){return _E(this,$,!0)},Y.prototype.rawListeners=function($){return _E(this,$,!1)},Y.listenerCount=function($,M){return typeof $.listenerCount=="function"?$.listenerCount(M):AE.call($,M)},Y.prototype.listenerCount=AE,Y.prototype.eventNames=function(){return this._eventsCount>0?u(this._events):[]},typeof Symbol!="undefined"&&(i.prototype[Symbol.iterator]=function(){return this}),i.of=function(){var $=arguments,M=$.length,b=0;return new i(function(){return b>=M?{done:!0}:{done:!1,value:$[b++]}})},i.empty=function(){return new i(function(){return{done:!0}})},i.fromSequence=function($){var M=0,b=$.length;return new i(function(){return M>=b?{done:!0}:{done:!1,value:$[M++]}})},i.is=function($){return $ instanceof i||typeof $=="object"&&$!==null&&typeof $.next=="function"};var F=i,qE={};qE.ARRAY_BUFFER_SUPPORT=typeof ArrayBuffer!="undefined",qE.SYMBOL_SUPPORT=typeof Symbol!="undefined";var tE=F,xE=qE,E0=xE.ARRAY_BUFFER_SUPPORT,L0=xE.SYMBOL_SUPPORT,gE=function($){var M=function(b){return typeof b=="string"||Array.isArray(b)||E0&&ArrayBuffer.isView(b)?tE.fromSequence(b):typeof b!="object"||b===null?null:L0&&typeof b[Symbol.iterator]=="function"?b[Symbol.iterator]():typeof b.next=="function"?b:null}($);if(!M)throw new Error("obliterator: target is not iterable nor a valid iterator.");return M},$0=gE,GE=function($,M){for(var b,E=arguments.length>1?M:1/0,L=E!==1/0?new Array(E):[],R=0,W=$0($);;){if(R===E)return L;if((b=W.next()).done)return R!==M&&(L.length=R),L;L[R++]=b.value}},HE=function($){function M(b){var E;return(E=$.call(this)||this).name="GraphError",E.message=b,E}return V(M,$),M}(h(Error)),C=function($){function M(b){var E;return(E=$.call(this,b)||this).name="InvalidArgumentsGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(_(E),M.prototype.constructor),E}return V(M,$),M}(HE),Q=function($){function M(b){var E;return(E=$.call(this,b)||this).name="NotFoundGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(_(E),M.prototype.constructor),E}return V(M,$),M}(HE),O=function($){function M(b){var E;return(E=$.call(this,b)||this).name="UsageGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(_(E),M.prototype.constructor),E}return V(M,$),M}(HE);function vE($,M){this.key=$,this.attributes=M,this.clear()}function wE($,M){this.key=$,this.attributes=M,this.clear()}function SE($,M){this.key=$,this.attributes=M,this.clear()}function LE($,M,b,E,L){this.key=M,this.attributes=L,this.undirected=$,this.source=b,this.target=E}vE.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}},wE.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}},SE.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}},LE.prototype.attach=function(){var $="out",M="in";this.undirected&&($=M="undirected");var b=this.source.key,E=this.target.key;this.source[$][E]=this,this.undirected&&b===E||(this.target[M][b]=this)},LE.prototype.attachMulti=function(){var $="out",M="in",b=this.source.key,E=this.target.key;this.undirected&&($=M="undirected");var L=this.source[$],R=L[E];if(R===void 0)return L[E]=this,void(this.undirected&&b===E||(this.target[M][b]=this));R.previous=this,this.next=R,L[E]=this,this.target[M][b]=this},LE.prototype.detach=function(){var $=this.source.key,M=this.target.key,b="out",E="in";this.undirected&&(b=E="undirected"),delete this.source[b][M],delete this.target[E][$]},LE.prototype.detachMulti=function(){var $=this.source.key,M=this.target.key,b="out",E="in";this.undirected&&(b=E="undirected"),this.previous===void 0?this.next===void 0?(delete this.source[b][M],delete this.target[E][$]):(this.next.previous=void 0,this.source[b][M]=this.next,this.target[E][$]=this.next):(this.previous.next=this.next,this.next!==void 0&&(this.next.previous=this.previous))};function e($,M,b,E,L,R,W){var D,U,H,q;if(E=""+E,b===0){if(!(D=$._nodes.get(E)))throw new Q("Graph.".concat(M,': could not find the "').concat(E,'" node in the graph.'));H=L,q=R}else if(b===3){if(L=""+L,!(U=$._edges.get(L)))throw new Q("Graph.".concat(M,': could not find the "').concat(L,'" edge in the graph.'));var X=U.source.key,Z=U.target.key;if(E===X)D=U.target;else{if(E!==Z)throw new Q("Graph.".concat(M,': the "').concat(E,'" node is not attached to the "').concat(L,'" edge (').concat(X,", ").concat(Z,")."));D=U.source}H=R,q=W}else{if(!(U=$._edges.get(E)))throw new Q("Graph.".concat(M,': could not find the "').concat(E,'" edge in the graph.'));D=b===1?U.source:U.target,H=L,q=R}return[D,H,q]}var b0=[{name:function($){return"get".concat($,"Attribute")},attacher:function($,M,b){$.prototype[M]=function(E,L,R){var W=e(this,M,b,E,L,R),D=W[0],U=W[1];return D.attributes[U]}}},{name:function($){return"get".concat($,"Attributes")},attacher:function($,M,b){$.prototype[M]=function(E,L){return e(this,M,b,E,L)[0].attributes}}},{name:function($){return"has".concat($,"Attribute")},attacher:function($,M,b){$.prototype[M]=function(E,L,R){var W=e(this,M,b,E,L,R),D=W[0],U=W[1];return D.attributes.hasOwnProperty(U)}}},{name:function($){return"set".concat($,"Attribute")},attacher:function($,M,b){$.prototype[M]=function(E,L,R,W){var D=e(this,M,b,E,L,R,W),U=D[0],H=D[1],q=D[2];return U.attributes[H]=q,this.emit("nodeAttributesUpdated",{key:U.key,type:"set",attributes:U.attributes,name:H}),this}}},{name:function($){return"update".concat($,"Attribute")},attacher:function($,M,b){$.prototype[M]=function(E,L,R,W){var D=e(this,M,b,E,L,R,W),U=D[0],H=D[1],q=D[2];if(typeof q!="function")throw new C("Graph.".concat(M,": updater should be a function."));var X=U.attributes,Z=q(X[H]);return X[H]=Z,this.emit("nodeAttributesUpdated",{key:U.key,type:"set",attributes:U.attributes,name:H}),this}}},{name:function($){return"remove".concat($,"Attribute")},attacher:function($,M,b){$.prototype[M]=function(E,L,R){var W=e(this,M,b,E,L,R),D=W[0],U=W[1];return delete D.attributes[U],this.emit("nodeAttributesUpdated",{key:D.key,type:"remove",attributes:D.attributes,name:U}),this}}},{name:function($){return"replace".concat($,"Attributes")},attacher:function($,M,b){$.prototype[M]=function(E,L,R){var W=e(this,M,b,E,L,R),D=W[0],U=W[1];if(!G(U))throw new C("Graph.".concat(M,": provided attributes are not a plain object."));return D.attributes=U,this.emit("nodeAttributesUpdated",{key:D.key,type:"replace",attributes:D.attributes}),this}}},{name:function($){return"merge".concat($,"Attributes")},attacher:function($,M,b){$.prototype[M]=function(E,L,R){var W=e(this,M,b,E,L,R),D=W[0],U=W[1];if(!G(U))throw new C("Graph.".concat(M,": provided attributes are not a plain object."));return k(D.attributes,U),this.emit("nodeAttributesUpdated",{key:D.key,type:"merge",attributes:D.attributes,data:U}),this}}},{name:function($){return"update".concat($,"Attributes")},attacher:function($,M,b){$.prototype[M]=function(E,L,R){var W=e(this,M,b,E,L,R),D=W[0],U=W[1];if(typeof U!="function")throw new C("Graph.".concat(M,": provided updater is not a function."));return D.attributes=U(D.attributes),this.emit("nodeAttributesUpdated",{key:D.key,type:"update",attributes:D.attributes}),this}}}],R0=[{name:function($){return"get".concat($,"Attribute")},attacher:function($,M,b){$.prototype[M]=function(E,L){var R;if(this.type!=="mixed"&&b!=="mixed"&&b!==this.type)throw new O("Graph.".concat(M,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new O("Graph.".concat(M,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var W=""+E,D=""+L;if(L=arguments[2],!(R=y(this,W,D,b)))throw new Q("Graph.".concat(M,': could not find an edge for the given path ("').concat(W,'" - "').concat(D,'").'))}else{if(b!=="mixed")throw new O("Graph.".concat(M,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(E=""+E,!(R=this._edges.get(E)))throw new Q("Graph.".concat(M,': could not find the "').concat(E,'" edge in the graph.'))}return R.attributes[L]}}},{name:function($){return"get".concat($,"Attributes")},attacher:function($,M,b){$.prototype[M]=function(E){var L;if(this.type!=="mixed"&&b!=="mixed"&&b!==this.type)throw new O("Graph.".concat(M,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>1){if(this.multi)throw new O("Graph.".concat(M,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var R=""+E,W=""+arguments[1];if(!(L=y(this,R,W,b)))throw new Q("Graph.".concat(M,': could not find an edge for the given path ("').concat(R,'" - "').concat(W,'").'))}else{if(b!=="mixed")throw new O("Graph.".concat(M,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(E=""+E,!(L=this._edges.get(E)))throw new Q("Graph.".concat(M,': could not find the "').concat(E,'" edge in the graph.'))}return L.attributes}}},{name:function($){return"has".concat($,"Attribute")},attacher:function($,M,b){$.prototype[M]=function(E,L){var R;if(this.type!=="mixed"&&b!=="mixed"&&b!==this.type)throw new O("Graph.".concat(M,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new O("Graph.".concat(M,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var W=""+E,D=""+L;if(L=arguments[2],!(R=y(this,W,D,b)))throw new Q("Graph.".concat(M,': could not find an edge for the given path ("').concat(W,'" - "').concat(D,'").'))}else{if(b!=="mixed")throw new O("Graph.".concat(M,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(E=""+E,!(R=this._edges.get(E)))throw new Q("Graph.".concat(M,': could not find the "').concat(E,'" edge in the graph.'))}return R.attributes.hasOwnProperty(L)}}},{name:function($){return"set".concat($,"Attribute")},attacher:function($,M,b){$.prototype[M]=function(E,L,R){var W;if(this.type!=="mixed"&&b!=="mixed"&&b!==this.type)throw new O("Graph.".concat(M,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>3){if(this.multi)throw new O("Graph.".concat(M,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var D=""+E,U=""+L;if(L=arguments[2],R=arguments[3],!(W=y(this,D,U,b)))throw new Q("Graph.".concat(M,': could not find an edge for the given path ("').concat(D,'" - "').concat(U,'").'))}else{if(b!=="mixed")throw new O("Graph.".concat(M,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(E=""+E,!(W=this._edges.get(E)))throw new Q("Graph.".concat(M,': could not find the "').concat(E,'" edge in the graph.'))}return W.attributes[L]=R,this.emit("edgeAttributesUpdated",{key:W.key,type:"set",attributes:W.attributes,name:L}),this}}},{name:function($){return"update".concat($,"Attribute")},attacher:function($,M,b){$.prototype[M]=function(E,L,R){var W;if(this.type!=="mixed"&&b!=="mixed"&&b!==this.type)throw new O("Graph.".concat(M,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>3){if(this.multi)throw new O("Graph.".concat(M,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var D=""+E,U=""+L;if(L=arguments[2],R=arguments[3],!(W=y(this,D,U,b)))throw new Q("Graph.".concat(M,': could not find an edge for the given path ("').concat(D,'" - "').concat(U,'").'))}else{if(b!=="mixed")throw new O("Graph.".concat(M,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(E=""+E,!(W=this._edges.get(E)))throw new Q("Graph.".concat(M,': could not find the "').concat(E,'" edge in the graph.'))}if(typeof R!="function")throw new C("Graph.".concat(M,": updater should be a function."));return W.attributes[L]=R(W.attributes[L]),this.emit("edgeAttributesUpdated",{key:W.key,type:"set",attributes:W.attributes,name:L}),this}}},{name:function($){return"remove".concat($,"Attribute")},attacher:function($,M,b){$.prototype[M]=function(E,L){var R;if(this.type!=="mixed"&&b!=="mixed"&&b!==this.type)throw new O("Graph.".concat(M,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new O("Graph.".concat(M,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var W=""+E,D=""+L;if(L=arguments[2],!(R=y(this,W,D,b)))throw new Q("Graph.".concat(M,': could not find an edge for the given path ("').concat(W,'" - "').concat(D,'").'))}else{if(b!=="mixed")throw new O("Graph.".concat(M,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(E=""+E,!(R=this._edges.get(E)))throw new Q("Graph.".concat(M,': could not find the "').concat(E,'" edge in the graph.'))}return delete R.attributes[L],this.emit("edgeAttributesUpdated",{key:R.key,type:"remove",attributes:R.attributes,name:L}),this}}},{name:function($){return"replace".concat($,"Attributes")},attacher:function($,M,b){$.prototype[M]=function(E,L){var R;if(this.type!=="mixed"&&b!=="mixed"&&b!==this.type)throw new O("Graph.".concat(M,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new O("Graph.".concat(M,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var W=""+E,D=""+L;if(L=arguments[2],!(R=y(this,W,D,b)))throw new Q("Graph.".concat(M,': could not find an edge for the given path ("').concat(W,'" - "').concat(D,'").'))}else{if(b!=="mixed")throw new O("Graph.".concat(M,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(E=""+E,!(R=this._edges.get(E)))throw new Q("Graph.".concat(M,': could not find the "').concat(E,'" edge in the graph.'))}if(!G(L))throw new C("Graph.".concat(M,": provided attributes are not a plain object."));return R.attributes=L,this.emit("edgeAttributesUpdated",{key:R.key,type:"replace",attributes:R.attributes}),this}}},{name:function($){return"merge".concat($,"Attributes")},attacher:function($,M,b){$.prototype[M]=function(E,L){var R;if(this.type!=="mixed"&&b!=="mixed"&&b!==this.type)throw new O("Graph.".concat(M,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new O("Graph.".concat(M,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var W=""+E,D=""+L;if(L=arguments[2],!(R=y(this,W,D,b)))throw new Q("Graph.".concat(M,': could not find an edge for the given path ("').concat(W,'" - "').concat(D,'").'))}else{if(b!=="mixed")throw new O("Graph.".concat(M,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(E=""+E,!(R=this._edges.get(E)))throw new Q("Graph.".concat(M,': could not find the "').concat(E,'" edge in the graph.'))}if(!G(L))throw new C("Graph.".concat(M,": provided attributes are not a plain object."));return k(R.attributes,L),this.emit("edgeAttributesUpdated",{key:R.key,type:"merge",attributes:R.attributes,data:L}),this}}},{name:function($){return"update".concat($,"Attributes")},attacher:function($,M,b){$.prototype[M]=function(E,L){var R;if(this.type!=="mixed"&&b!=="mixed"&&b!==this.type)throw new O("Graph.".concat(M,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new O("Graph.".concat(M,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var W=""+E,D=""+L;if(L=arguments[2],!(R=y(this,W,D,b)))throw new Q("Graph.".concat(M,': could not find an edge for the given path ("').concat(W,'" - "').concat(D,'").'))}else{if(b!=="mixed")throw new O("Graph.".concat(M,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(E=""+E,!(R=this._edges.get(E)))throw new Q("Graph.".concat(M,': could not find the "').concat(E,'" edge in the graph.'))}if(typeof L!="function")throw new C("Graph.".concat(M,": provided updater is not a function."));return R.attributes=L(R.attributes),this.emit("edgeAttributesUpdated",{key:R.key,type:"update",attributes:R.attributes}),this}}}],M0=F,W0=gE,t=function(){var $=arguments,M=null,b=-1;return new M0(function(){for(var E=null;;){if(M===null){if(++b>=$.length)return{done:!0};M=W0($[b])}if((E=M.next()).done!==!0)break;M=null}return E})},D0=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function U0($,M,b,E){var L=!1;for(var R in M)if(R!==E){var W=M[R];if(L=b(W.key,W.attributes,W.source.key,W.target.key,W.source.attributes,W.target.attributes,W.undirected),$&&L)return W.key}}function X0($,M,b,E){var L,R,W,D=!1;for(var U in M)if(U!==E){L=M[U];do{if(R=L.source,W=L.target,D=b(L.key,L.attributes,R.key,W.key,R.attributes,W.attributes,L.undirected),$&&D)return L.key;L=L.next}while(L!==void 0)}}function QE($,M){var b,E=Object.keys($),L=E.length,R=0;return new F(function(){do if(b)b=b.next;else{if(R>=L)return{done:!0};var W=E[R++];if(W===M){b=void 0;continue}b=$[W]}while(!b);return{done:!1,value:{edge:b.key,attributes:b.attributes,source:b.source.key,target:b.target.key,sourceAttributes:b.source.attributes,targetAttributes:b.target.attributes,undirected:b.undirected}}})}function q0($,M,b,E){var L=M[b];if(L){var{source:R,target:W}=L;return E(L.key,L.attributes,R.key,W.key,R.attributes,W.attributes,L.undirected)&&$?L.key:void 0}}function H0($,M,b,E){var L=M[b];if(L){var R=!1;do{if(R=E(L.key,L.attributes,L.source.key,L.target.key,L.source.attributes,L.target.attributes,L.undirected),$&&R)return L.key;L=L.next}while(L!==void 0)}}function ZE($,M){var b=$[M];return b.next!==void 0?new F(function(){if(!b)return{done:!0};var E={edge:b.key,attributes:b.attributes,source:b.source.key,target:b.target.key,sourceAttributes:b.source.attributes,targetAttributes:b.target.attributes,undirected:b.undirected};return b=b.next,{done:!1,value:E}}):F.of({edge:b.key,attributes:b.attributes,source:b.source.key,target:b.target.key,sourceAttributes:b.source.attributes,targetAttributes:b.target.attributes,undirected:b.undirected})}function Q0($,M){if($.size===0)return[];if(M==="mixed"||M===$.type)return typeof Array.from=="function"?Array.from($._edges.keys()):GE($._edges.keys(),$._edges.size);for(var b,E,L=M==="undirected"?$.undirectedSize:$.directedSize,R=new Array(L),W=M==="undirected",D=$._edges.values(),U=0;(b=D.next()).done!==!0;)(E=b.value).undirected===W&&(R[U++]=E.key);return R}function NE($,M,b,E){if(M.size!==0){for(var L,R,W=b!=="mixed"&&b!==M.type,D=b==="undirected",U=!1,H=M._edges.values();(L=H.next()).done!==!0;)if(R=L.value,!W||R.undirected===D){var q=R,X=q.key,Z=q.attributes,J=q.source,T=q.target;if(U=E(X,Z,J.key,T.key,J.attributes,T.attributes,R.undirected),$&&U)return X}}}function Z0($,M){if($.size===0)return F.empty();var b=M!=="mixed"&&M!==$.type,E=M==="undirected",L=$._edges.values();return new F(function(){for(var R,W;;){if((R=L.next()).done)return R;if(W=R.value,!b||W.undirected===E)break}return{value:{edge:W.key,attributes:W.attributes,source:W.source.key,target:W.target.key,sourceAttributes:W.source.attributes,targetAttributes:W.target.attributes,undirected:W.undirected},done:!1}})}function JE($,M,b,E,L,R){var W,D=M?X0:U0;if(b!=="undirected"){if(E!=="out"&&(W=D($,L.in,R),$&&W))return W;if(E!=="in"&&(W=D($,L.out,R,E?void 0:L.key),$&&W))return W}if(b!=="directed"&&(W=D($,L.undirected,R),$&&W))return W}function J0($,M,b,E){var L=[];return JE(!1,$,M,b,E,function(R){L.push(R)}),L}function Y0($,M,b){var E=F.empty();return $!=="undirected"&&(M!=="out"&&b.in!==void 0&&(E=t(E,QE(b.in))),M!=="in"&&b.out!==void 0&&(E=t(E,QE(b.out,M?void 0:b.key)))),$!=="directed"&&b.undirected!==void 0&&(E=t(E,QE(b.undirected))),E}function YE($,M,b,E,L,R,W){var D,U=b?H0:q0;if(M!=="undirected"){if(L.in!==void 0&&E!=="out"&&(D=U($,L.in,R,W),$&&D))return D;if(L.out!==void 0&&E!=="in"&&(E||L.key!==R)&&(D=U($,L.out,R,W),$&&D))return D}if(M!=="directed"&&L.undirected!==void 0&&(D=U($,L.undirected,R,W),$&&D))return D}function C0($,M,b,E,L){var R=[];return YE(!1,$,M,b,E,L,function(W){R.push(W)}),R}function P0($,M,b,E){var L=F.empty();return $!=="undirected"&&(b.in!==void 0&&M!=="out"&&(E in b.in)&&(L=t(L,ZE(b.in,E))),b.out!==void 0&&M!=="in"&&(E in b.out)&&(M||b.key!==E)&&(L=t(L,ZE(b.out,E)))),$!=="directed"&&b.undirected!==void 0&&E in b.undirected&&(L=t(L,ZE(b.undirected,E))),L}var K0=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function WE(){this.A=null,this.B=null}function RE($,M,b,E,L){for(var R in E){var W=E[R],D=W.source,U=W.target,H=D===b?U:D;if(!M||!M.has(H.key)){var q=L(H.key,H.attributes);if($&&q)return H.key}}}function CE($,M,b,E,L){if(M!=="mixed"){if(M==="undirected")return RE($,null,E,E.undirected,L);if(typeof b=="string")return RE($,null,E,E[b],L)}var R,W=new WE;if(M!=="undirected"){if(b!=="out"){if(R=RE($,null,E,E.in,L),$&&R)return R;W.wrap(E.in)}if(b!=="in"){if(R=RE($,W,E,E.out,L),$&&R)return R;W.wrap(E.out)}}if(M!=="directed"&&(R=RE($,W,E,E.undirected,L),$&&R))return R}function ME($,M,b){var E=Object.keys(b),L=E.length,R=0;return new F(function(){var W=null;do{if(R>=L)return $&&$.wrap(b),{done:!0};var D=b[E[R++]],U=D.source,H=D.target;W=U===M?H:U,$&&$.has(W.key)&&(W=null)}while(W===null);return{done:!1,value:{neighbor:W.key,attributes:W.attributes}}})}function j0($,M){var{name:b,type:E,direction:L}=M;$.prototype[b]=function(R){if(E!=="mixed"&&this.type!=="mixed"&&E!==this.type)return[];R=""+R;var W=this._nodes.get(R);if(W===void 0)throw new Q("Graph.".concat(b,': could not find the "').concat(R,'" node in the graph.'));return function(D,U,H){if(D!=="mixed"){if(D==="undirected")return Object.keys(H.undirected);if(typeof U=="string")return Object.keys(H[U])}var q=[];return CE(!1,D,U,H,function(X){q.push(X)}),q}(E==="mixed"?this.type:E,L,W)}}function O0($,M){var{name:b,type:E,direction:L}=M,R=b.slice(0,-1)+"Entries";$.prototype[R]=function(W){if(E!=="mixed"&&this.type!=="mixed"&&E!==this.type)return F.empty();W=""+W;var D=this._nodes.get(W);if(D===void 0)throw new Q("Graph.".concat(R,': could not find the "').concat(W,'" node in the graph.'));return function(U,H,q){if(U!=="mixed"){if(U==="undirected")return ME(null,q,q.undirected);if(typeof H=="string")return ME(null,q,q[H])}var X=F.empty(),Z=new WE;return U!=="undirected"&&(H!=="out"&&(X=t(X,ME(Z,q,q.in))),H!=="in"&&(X=t(X,ME(Z,q,q.out)))),U!=="directed"&&(X=t(X,ME(Z,q,q.undirected))),X}(E==="mixed"?this.type:E,L,D)}}function DE($,M,b,E,L){for(var R,W,D,U,H,q,X,Z=E._nodes.values(),J=E.type;(R=Z.next()).done!==!0;){var T=!1;if(W=R.value,J!=="undirected")for(D in U=W.out){H=U[D];do{if(q=H.target,T=!0,X=L(W.key,q.key,W.attributes,q.attributes,H.key,H.attributes,H.undirected),$&&X)return H;H=H.next}while(H)}if(J!=="directed"){for(D in U=W.undirected)if(!(M&&W.key>D)){H=U[D];do{if((q=H.target).key!==D&&(q=H.source),T=!0,X=L(W.key,q.key,W.attributes,q.attributes,H.key,H.attributes,H.undirected),$&&X)return H;H=H.next}while(H)}}if(b&&!T&&(X=L(W.key,null,W.attributes,null,null,null,null),$&&X))return null}}function T0($){if(!G($))throw new C('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in $))throw new C("Graph.import: serialized node is missing its key.");if("attributes"in $&&(!G($.attributes)||$.attributes===null))throw new C("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function V0($){if(!G($))throw new C('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in $))throw new C("Graph.import: serialized edge is missing its source.");if(!("target"in $))throw new C("Graph.import: serialized edge is missing its target.");if("attributes"in $&&(!G($.attributes)||$.attributes===null))throw new C("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in $&&typeof $.undirected!="boolean")throw new C("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}WE.prototype.wrap=function($){this.A===null?this.A=$:this.B===null&&(this.B=$)},WE.prototype.has=function($){return this.A!==null&&$ in this.A||this.B!==null&&$ in this.B};var zE,_0=(zE=255&Math.floor(256*Math.random()),function(){return zE++}),A0=new Set(["directed","undirected","mixed"]),hE=new Set(["domain","_events","_eventsCount","_maxListeners"]),k0={allowSelfLoops:!0,multi:!1,type:"mixed"};function fE($,M,b){var E=new $.NodeDataClass(M,b);return $._nodes.set(M,E),$.emit("nodeAdded",{key:M,attributes:b}),E}function IE($,M,b,E,L,R,W,D){if(!E&&$.type==="undirected")throw new O("Graph.".concat(M,": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead."));if(E&&$.type==="directed")throw new O("Graph.".concat(M,": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead."));if(D&&!G(D))throw new C("Graph.".concat(M,': invalid attributes. Expecting an object but got "').concat(D,'"'));if(R=""+R,W=""+W,D=D||{},!$.allowSelfLoops&&R===W)throw new O("Graph.".concat(M,': source & target are the same ("').concat(R,`"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`));var U=$._nodes.get(R),H=$._nodes.get(W);if(!U)throw new Q("Graph.".concat(M,': source node "').concat(R,'" not found.'));if(!H)throw new Q("Graph.".concat(M,': target node "').concat(W,'" not found.'));var q={key:null,undirected:E,source:R,target:W,attributes:D};if(b)L=$._edgeKeyGenerator();else if(L=""+L,$._edges.has(L))throw new O("Graph.".concat(M,': the "').concat(L,'" edge already exists in the graph.'));if(!$.multi&&(E?U.undirected[W]!==void 0:U.out[W]!==void 0))throw new O("Graph.".concat(M,': an edge linking "').concat(R,'" to "').concat(W,`" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`));var X=new LE(E,L,U,H,D);$._edges.set(L,X);var Z=R===W;return E?(U.undirectedDegree++,H.undirectedDegree++,Z&&(U.undirectedLoops++,$._undirectedSelfLoopCount++)):(U.outDegree++,H.inDegree++,Z&&(U.directedLoops++,$._directedSelfLoopCount++)),$.multi?X.attachMulti():X.attach(),E?$._undirectedSize++:$._directedSize++,q.key=L,$.emit("edgeAdded",q),L}function y0($,M,b,E,L,R,W,D,U){if(!E&&$.type==="undirected")throw new O("Graph.".concat(M,": you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead."));if(E&&$.type==="directed")throw new O("Graph.".concat(M,": you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead."));if(D){if(U){if(typeof D!="function")throw new C("Graph.".concat(M,': invalid updater function. Expecting a function but got "').concat(D,'"'))}else if(!G(D))throw new C("Graph.".concat(M,': invalid attributes. Expecting an object but got "').concat(D,'"'))}var H;if(R=""+R,W=""+W,U&&(H=D,D=void 0),!$.allowSelfLoops&&R===W)throw new O("Graph.".concat(M,': source & target are the same ("').concat(R,`"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`));var q,X,Z=$._nodes.get(R),J=$._nodes.get(W);if(!b&&(q=$._edges.get(L))){if(!(q.source.key===R&&q.target.key===W||E&&q.source.key===W&&q.target.key===R))throw new O("Graph.".concat(M,': inconsistency detected when attempting to merge the "').concat(L,'" edge with "').concat(R,'" source & "').concat(W,'" target vs. ("').concat(q.source.key,'", "').concat(q.target.key,'").'));X=q}if(X||$.multi||!Z||(X=E?Z.undirected[W]:Z.out[W]),X){var T=[X.key,!1,!1,!1];if(U?!H:!D)return T;if(U){var g=X.attributes;X.attributes=H(g),$.emit("edgeAttributesUpdated",{type:"replace",key:X.key,attributes:X.attributes})}else k(X.attributes,D),$.emit("edgeAttributesUpdated",{type:"merge",key:X.key,attributes:X.attributes,data:D});return T}D=D||{},U&&H&&(D=H(D));var z={key:null,undirected:E,source:R,target:W,attributes:D};if(b)L=$._edgeKeyGenerator();else if(L=""+L,$._edges.has(L))throw new O("Graph.".concat(M,': the "').concat(L,'" edge already exists in the graph.'));var B=!1,m=!1;Z||(Z=fE($,R,{}),B=!0,R===W&&(J=Z,m=!0)),J||(J=fE($,W,{}),m=!0),q=new LE(E,L,Z,J,D),$._edges.set(L,q);var c=R===W;return E?(Z.undirectedDegree++,J.undirectedDegree++,c&&(Z.undirectedLoops++,$._undirectedSelfLoopCount++)):(Z.outDegree++,J.inDegree++,c&&(Z.directedLoops++,$._directedSelfLoopCount++)),$.multi?q.attachMulti():q.attach(),E?$._undirectedSize++:$._directedSize++,z.key=L,$.emit("edgeAdded",z),[L,!0,B,m]}function $E($,M){$._edges.delete(M.key);var{source:b,target:E,attributes:L,undirected:R}=M,W=b===E;R?(b.undirectedDegree--,E.undirectedDegree--,W&&(b.undirectedLoops--,$._undirectedSelfLoopCount--)):(b.outDegree--,E.inDegree--,W&&(b.directedLoops--,$._directedSelfLoopCount--)),$.multi?M.detachMulti():M.detach(),R?$._undirectedSize--:$._directedSize--,$.emit("edgeDropped",{key:M.key,attributes:L,source:b.key,target:E.key,undirected:R})}var N=function($){function M(E){var L;if(L=$.call(this)||this,typeof(E=k({},k0,E)).multi!="boolean")throw new C(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "`.concat(E.multi,'".'));if(!A0.has(E.type))throw new C(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "`.concat(E.type,'".'));if(typeof E.allowSelfLoops!="boolean")throw new C(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "`.concat(E.allowSelfLoops,'".'));var R=E.type==="mixed"?vE:E.type==="directed"?wE:SE;f(_(L),"NodeDataClass",R);var W="geid_"+_0()+"_",D=0;return f(_(L),"_attributes",{}),f(_(L),"_nodes",new Map),f(_(L),"_edges",new Map),f(_(L),"_directedSize",0),f(_(L),"_undirectedSize",0),f(_(L),"_directedSelfLoopCount",0),f(_(L),"_undirectedSelfLoopCount",0),f(_(L),"_edgeKeyGenerator",function(){var U;do U=W+D++;while(L._edges.has(U));return U}),f(_(L),"_options",E),hE.forEach(function(U){return f(_(L),U,L[U])}),I(_(L),"order",function(){return L._nodes.size}),I(_(L),"size",function(){return L._edges.size}),I(_(L),"directedSize",function(){return L._directedSize}),I(_(L),"undirectedSize",function(){return L._undirectedSize}),I(_(L),"selfLoopCount",function(){return L._directedSelfLoopCount+L._undirectedSelfLoopCount}),I(_(L),"directedSelfLoopCount",function(){return L._directedSelfLoopCount}),I(_(L),"undirectedSelfLoopCount",function(){return L._undirectedSelfLoopCount}),I(_(L),"multi",L._options.multi),I(_(L),"type",L._options.type),I(_(L),"allowSelfLoops",L._options.allowSelfLoops),I(_(L),"implementation",function(){return"graphology"}),L}V(M,$);var b=M.prototype;return b._resetInstanceCounters=function(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0},b.hasNode=function(E){return this._nodes.has(""+E)},b.hasDirectedEdge=function(E,L){if(this.type==="undirected")return!1;if(arguments.length===1){var R=""+E,W=this._edges.get(R);return!!W&&!W.undirected}if(arguments.length===2){E=""+E,L=""+L;var D=this._nodes.get(E);return!!D&&D.out.hasOwnProperty(L)}throw new C("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},b.hasUndirectedEdge=function(E,L){if(this.type==="directed")return!1;if(arguments.length===1){var R=""+E,W=this._edges.get(R);return!!W&&W.undirected}if(arguments.length===2){E=""+E,L=""+L;var D=this._nodes.get(E);return!!D&&D.undirected.hasOwnProperty(L)}throw new C("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},b.hasEdge=function(E,L){if(arguments.length===1){var R=""+E;return this._edges.has(R)}if(arguments.length===2){E=""+E,L=""+L;var W=this._nodes.get(E);return!!W&&(W.out!==void 0&&W.out.hasOwnProperty(L)||W.undirected!==void 0&&W.undirected.hasOwnProperty(L))}throw new C("Graph.hasEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},b.directedEdge=function(E,L){if(this.type!=="undirected"){if(E=""+E,L=""+L,this.multi)throw new O("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");var R=this._nodes.get(E);if(!R)throw new Q('Graph.directedEdge: could not find the "'.concat(E,'" source node in the graph.'));if(!this._nodes.has(L))throw new Q('Graph.directedEdge: could not find the "'.concat(L,'" target node in the graph.'));var W=R.out&&R.out[L]||void 0;return W?W.key:void 0}},b.undirectedEdge=function(E,L){if(this.type!=="directed"){if(E=""+E,L=""+L,this.multi)throw new O("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");var R=this._nodes.get(E);if(!R)throw new Q('Graph.undirectedEdge: could not find the "'.concat(E,'" source node in the graph.'));if(!this._nodes.has(L))throw new Q('Graph.undirectedEdge: could not find the "'.concat(L,'" target node in the graph.'));var W=R.undirected&&R.undirected[L]||void 0;return W?W.key:void 0}},b.edge=function(E,L){if(this.multi)throw new O("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");E=""+E,L=""+L;var R=this._nodes.get(E);if(!R)throw new Q('Graph.edge: could not find the "'.concat(E,'" source node in the graph.'));if(!this._nodes.has(L))throw new Q('Graph.edge: could not find the "'.concat(L,'" target node in the graph.'));var W=R.out&&R.out[L]||R.undirected&&R.undirected[L]||void 0;if(W)return W.key},b.areDirectedNeighbors=function(E,L){E=""+E,L=""+L;var R=this._nodes.get(E);if(!R)throw new Q('Graph.areDirectedNeighbors: could not find the "'.concat(E,'" node in the graph.'));return this.type!=="undirected"&&((L in R.in)||(L in R.out))},b.areOutNeighbors=function(E,L){E=""+E,L=""+L;var R=this._nodes.get(E);if(!R)throw new Q('Graph.areOutNeighbors: could not find the "'.concat(E,'" node in the graph.'));return this.type!=="undirected"&&L in R.out},b.areInNeighbors=function(E,L){E=""+E,L=""+L;var R=this._nodes.get(E);if(!R)throw new Q('Graph.areInNeighbors: could not find the "'.concat(E,'" node in the graph.'));return this.type!=="undirected"&&L in R.in},b.areUndirectedNeighbors=function(E,L){E=""+E,L=""+L;var R=this._nodes.get(E);if(!R)throw new Q('Graph.areUndirectedNeighbors: could not find the "'.concat(E,'" node in the graph.'));return this.type!=="directed"&&L in R.undirected},b.areNeighbors=function(E,L){E=""+E,L=""+L;var R=this._nodes.get(E);if(!R)throw new Q('Graph.areNeighbors: could not find the "'.concat(E,'" node in the graph.'));return this.type!=="undirected"&&((L in R.in)||(L in R.out))||this.type!=="directed"&&L in R.undirected},b.areInboundNeighbors=function(E,L){E=""+E,L=""+L;var R=this._nodes.get(E);if(!R)throw new Q('Graph.areInboundNeighbors: could not find the "'.concat(E,'" node in the graph.'));return this.type!=="undirected"&&L in R.in||this.type!=="directed"&&L in R.undirected},b.areOutboundNeighbors=function(E,L){E=""+E,L=""+L;var R=this._nodes.get(E);if(!R)throw new Q('Graph.areOutboundNeighbors: could not find the "'.concat(E,'" node in the graph.'));return this.type!=="undirected"&&L in R.out||this.type!=="directed"&&L in R.undirected},b.inDegree=function(E){E=""+E;var L=this._nodes.get(E);if(!L)throw new Q('Graph.inDegree: could not find the "'.concat(E,'" node in the graph.'));return this.type==="undirected"?0:L.inDegree},b.outDegree=function(E){E=""+E;var L=this._nodes.get(E);if(!L)throw new Q('Graph.outDegree: could not find the "'.concat(E,'" node in the graph.'));return this.type==="undirected"?0:L.outDegree},b.directedDegree=function(E){E=""+E;var L=this._nodes.get(E);if(!L)throw new Q('Graph.directedDegree: could not find the "'.concat(E,'" node in the graph.'));return this.type==="undirected"?0:L.inDegree+L.outDegree},b.undirectedDegree=function(E){E=""+E;var L=this._nodes.get(E);if(!L)throw new Q('Graph.undirectedDegree: could not find the "'.concat(E,'" node in the graph.'));return this.type==="directed"?0:L.undirectedDegree},b.inboundDegree=function(E){E=""+E;var L=this._nodes.get(E);if(!L)throw new Q('Graph.inboundDegree: could not find the "'.concat(E,'" node in the graph.'));var R=0;return this.type!=="directed"&&(R+=L.undirectedDegree),this.type!=="undirected"&&(R+=L.inDegree),R},b.outboundDegree=function(E){E=""+E;var L=this._nodes.get(E);if(!L)throw new Q('Graph.outboundDegree: could not find the "'.concat(E,'" node in the graph.'));var R=0;return this.type!=="directed"&&(R+=L.undirectedDegree),this.type!=="undirected"&&(R+=L.outDegree),R},b.degree=function(E){E=""+E;var L=this._nodes.get(E);if(!L)throw new Q('Graph.degree: could not find the "'.concat(E,'" node in the graph.'));var R=0;return this.type!=="directed"&&(R+=L.undirectedDegree),this.type!=="undirected"&&(R+=L.inDegree+L.outDegree),R},b.inDegreeWithoutSelfLoops=function(E){E=""+E;var L=this._nodes.get(E);if(!L)throw new Q('Graph.inDegreeWithoutSelfLoops: could not find the "'.concat(E,'" node in the graph.'));return this.type==="undirected"?0:L.inDegree-L.directedLoops},b.outDegreeWithoutSelfLoops=function(E){E=""+E;var L=this._nodes.get(E);if(!L)throw new Q('Graph.outDegreeWithoutSelfLoops: could not find the "'.concat(E,'" node in the graph.'));return this.type==="undirected"?0:L.outDegree-L.directedLoops},b.directedDegreeWithoutSelfLoops=function(E){E=""+E;var L=this._nodes.get(E);if(!L)throw new Q('Graph.directedDegreeWithoutSelfLoops: could not find the "'.concat(E,'" node in the graph.'));return this.type==="undirected"?0:L.inDegree+L.outDegree-2*L.directedLoops},b.undirectedDegreeWithoutSelfLoops=function(E){E=""+E;var L=this._nodes.get(E);if(!L)throw new Q('Graph.undirectedDegreeWithoutSelfLoops: could not find the "'.concat(E,'" node in the graph.'));return this.type==="directed"?0:L.undirectedDegree-2*L.undirectedLoops},b.inboundDegreeWithoutSelfLoops=function(E){E=""+E;var L=this._nodes.get(E);if(!L)throw new Q('Graph.inboundDegreeWithoutSelfLoops: could not find the "'.concat(E,'" node in the graph.'));var R=0,W=0;return this.type!=="directed"&&(R+=L.undirectedDegree,W+=2*L.undirectedLoops),this.type!=="undirected"&&(R+=L.inDegree,W+=L.directedLoops),R-W},b.outboundDegreeWithoutSelfLoops=function(E){E=""+E;var L=this._nodes.get(E);if(!L)throw new Q('Graph.outboundDegreeWithoutSelfLoops: could not find the "'.concat(E,'" node in the graph.'));var R=0,W=0;return this.type!=="directed"&&(R+=L.undirectedDegree,W+=2*L.undirectedLoops),this.type!=="undirected"&&(R+=L.outDegree,W+=L.directedLoops),R-W},b.degreeWithoutSelfLoops=function(E){E=""+E;var L=this._nodes.get(E);if(!L)throw new Q('Graph.degreeWithoutSelfLoops: could not find the "'.concat(E,'" node in the graph.'));var R=0,W=0;return this.type!=="directed"&&(R+=L.undirectedDegree,W+=2*L.undirectedLoops),this.type!=="undirected"&&(R+=L.inDegree+L.outDegree,W+=2*L.directedLoops),R-W},b.source=function(E){E=""+E;var L=this._edges.get(E);if(!L)throw new Q('Graph.source: could not find the "'.concat(E,'" edge in the graph.'));return L.source.key},b.target=function(E){E=""+E;var L=this._edges.get(E);if(!L)throw new Q('Graph.target: could not find the "'.concat(E,'" edge in the graph.'));return L.target.key},b.extremities=function(E){E=""+E;var L=this._edges.get(E);if(!L)throw new Q('Graph.extremities: could not find the "'.concat(E,'" edge in the graph.'));return[L.source.key,L.target.key]},b.opposite=function(E,L){E=""+E,L=""+L;var R=this._edges.get(L);if(!R)throw new Q('Graph.opposite: could not find the "'.concat(L,'" edge in the graph.'));var W=R.source.key,D=R.target.key;if(E===W)return D;if(E===D)return W;throw new Q('Graph.opposite: the "'.concat(E,'" node is not attached to the "').concat(L,'" edge (').concat(W,", ").concat(D,")."))},b.hasExtremity=function(E,L){E=""+E,L=""+L;var R=this._edges.get(E);if(!R)throw new Q('Graph.hasExtremity: could not find the "'.concat(E,'" edge in the graph.'));return R.source.key===L||R.target.key===L},b.isUndirected=function(E){E=""+E;var L=this._edges.get(E);if(!L)throw new Q('Graph.isUndirected: could not find the "'.concat(E,'" edge in the graph.'));return L.undirected},b.isDirected=function(E){E=""+E;var L=this._edges.get(E);if(!L)throw new Q('Graph.isDirected: could not find the "'.concat(E,'" edge in the graph.'));return!L.undirected},b.isSelfLoop=function(E){E=""+E;var L=this._edges.get(E);if(!L)throw new Q('Graph.isSelfLoop: could not find the "'.concat(E,'" edge in the graph.'));return L.source===L.target},b.addNode=function(E,L){var R=function(W,D,U){if(U&&!G(U))throw new C('Graph.addNode: invalid attributes. Expecting an object but got "'.concat(U,'"'));if(D=""+D,U=U||{},W._nodes.has(D))throw new O('Graph.addNode: the "'.concat(D,'" node already exist in the graph.'));var H=new W.NodeDataClass(D,U);return W._nodes.set(D,H),W.emit("nodeAdded",{key:D,attributes:U}),H}(this,E,L);return R.key},b.mergeNode=function(E,L){if(L&&!G(L))throw new C('Graph.mergeNode: invalid attributes. Expecting an object but got "'.concat(L,'"'));E=""+E,L=L||{};var R=this._nodes.get(E);return R?(L&&(k(R.attributes,L),this.emit("nodeAttributesUpdated",{type:"merge",key:E,attributes:R.attributes,data:L})),[E,!1]):(R=new this.NodeDataClass(E,L),this._nodes.set(E,R),this.emit("nodeAdded",{key:E,attributes:L}),[E,!0])},b.updateNode=function(E,L){if(L&&typeof L!="function")throw new C('Graph.updateNode: invalid updater function. Expecting a function but got "'.concat(L,'"'));E=""+E;var R=this._nodes.get(E);if(R){if(L){var W=R.attributes;R.attributes=L(W),this.emit("nodeAttributesUpdated",{type:"replace",key:E,attributes:R.attributes})}return[E,!1]}var D=L?L({}):{};return R=new this.NodeDataClass(E,D),this._nodes.set(E,R),this.emit("nodeAdded",{key:E,attributes:D}),[E,!0]},b.dropNode=function(E){E=""+E;var L,R=this._nodes.get(E);if(!R)throw new Q('Graph.dropNode: could not find the "'.concat(E,'" node in the graph.'));if(this.type!=="undirected"){for(var W in R.out){L=R.out[W];do $E(this,L),L=L.next;while(L)}for(var D in R.in){L=R.in[D];do $E(this,L),L=L.next;while(L)}}if(this.type!=="directed")for(var U in R.undirected){L=R.undirected[U];do $E(this,L),L=L.next;while(L)}this._nodes.delete(E),this.emit("nodeDropped",{key:E,attributes:R.attributes})},b.dropEdge=function(E){var L;if(arguments.length>1){var R=""+arguments[0],W=""+arguments[1];if(!(L=y(this,R,W,this.type)))throw new Q('Graph.dropEdge: could not find the "'.concat(R,'" -> "').concat(W,'" edge in the graph.'))}else if(E=""+E,!(L=this._edges.get(E)))throw new Q('Graph.dropEdge: could not find the "'.concat(E,'" edge in the graph.'));return $E(this,L),this},b.dropDirectedEdge=function(E,L){if(arguments.length<2)throw new O("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new O("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");var R=y(this,E=""+E,L=""+L,"directed");if(!R)throw new Q('Graph.dropDirectedEdge: could not find a "'.concat(E,'" -> "').concat(L,'" edge in the graph.'));return $E(this,R),this},b.dropUndirectedEdge=function(E,L){if(arguments.length<2)throw new O("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new O("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");var R=y(this,E,L,"undirected");if(!R)throw new Q('Graph.dropUndirectedEdge: could not find a "'.concat(E,'" -> "').concat(L,'" edge in the graph.'));return $E(this,R),this},b.clear=function(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")},b.clearEdges=function(){for(var E,L=this._nodes.values();(E=L.next()).done!==!0;)E.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")},b.getAttribute=function(E){return this._attributes[E]},b.getAttributes=function(){return this._attributes},b.hasAttribute=function(E){return this._attributes.hasOwnProperty(E)},b.setAttribute=function(E,L){return this._attributes[E]=L,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:E}),this},b.updateAttribute=function(E,L){if(typeof L!="function")throw new C("Graph.updateAttribute: updater should be a function.");var R=this._attributes[E];return this._attributes[E]=L(R),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:E}),this},b.removeAttribute=function(E){return delete this._attributes[E],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:E}),this},b.replaceAttributes=function(E){if(!G(E))throw new C("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=E,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this},b.mergeAttributes=function(E){if(!G(E))throw new C("Graph.mergeAttributes: provided attributes are not a plain object.");return k(this._attributes,E),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:E}),this},b.updateAttributes=function(E){if(typeof E!="function")throw new C("Graph.updateAttributes: provided updater is not a function.");return this._attributes=E(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this},b.updateEachNodeAttributes=function(E,L){if(typeof E!="function")throw new C("Graph.updateEachNodeAttributes: expecting an updater function.");if(L&&!EE(L))throw new C("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");for(var R,W,D=this._nodes.values();(R=D.next()).done!==!0;)(W=R.value).attributes=E(W.key,W.attributes);this.emit("eachNodeAttributesUpdated",{hints:L||null})},b.updateEachEdgeAttributes=function(E,L){if(typeof E!="function")throw new C("Graph.updateEachEdgeAttributes: expecting an updater function.");if(L&&!EE(L))throw new C("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");for(var R,W,D,U,H=this._edges.values();(R=H.next()).done!==!0;)D=(W=R.value).source,U=W.target,W.attributes=E(W.key,W.attributes,D.key,U.key,D.attributes,U.attributes,W.undirected);this.emit("eachEdgeAttributesUpdated",{hints:L||null})},b.forEachAdjacencyEntry=function(E){if(typeof E!="function")throw new C("Graph.forEachAdjacencyEntry: expecting a callback.");DE(!1,!1,!1,this,E)},b.forEachAdjacencyEntryWithOrphans=function(E){if(typeof E!="function")throw new C("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");DE(!1,!1,!0,this,E)},b.forEachAssymetricAdjacencyEntry=function(E){if(typeof E!="function")throw new C("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");DE(!1,!0,!1,this,E)},b.forEachAssymetricAdjacencyEntryWithOrphans=function(E){if(typeof E!="function")throw new C("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");DE(!1,!0,!0,this,E)},b.nodes=function(){return typeof Array.from=="function"?Array.from(this._nodes.keys()):GE(this._nodes.keys(),this._nodes.size)},b.forEachNode=function(E){if(typeof E!="function")throw new C("Graph.forEachNode: expecting a callback.");for(var L,R,W=this._nodes.values();(L=W.next()).done!==!0;)E((R=L.value).key,R.attributes)},b.findNode=function(E){if(typeof E!="function")throw new C("Graph.findNode: expecting a callback.");for(var L,R,W=this._nodes.values();(L=W.next()).done!==!0;)if(E((R=L.value).key,R.attributes))return R.key},b.mapNodes=function(E){if(typeof E!="function")throw new C("Graph.mapNode: expecting a callback.");for(var L,R,W=this._nodes.values(),D=new Array(this.order),U=0;(L=W.next()).done!==!0;)R=L.value,D[U++]=E(R.key,R.attributes);return D},b.someNode=function(E){if(typeof E!="function")throw new C("Graph.someNode: expecting a callback.");for(var L,R,W=this._nodes.values();(L=W.next()).done!==!0;)if(E((R=L.value).key,R.attributes))return!0;return!1},b.everyNode=function(E){if(typeof E!="function")throw new C("Graph.everyNode: expecting a callback.");for(var L,R,W=this._nodes.values();(L=W.next()).done!==!0;)if(!E((R=L.value).key,R.attributes))return!1;return!0},b.filterNodes=function(E){if(typeof E!="function")throw new C("Graph.filterNodes: expecting a callback.");for(var L,R,W=this._nodes.values(),D=[];(L=W.next()).done!==!0;)E((R=L.value).key,R.attributes)&&D.push(R.key);return D},b.reduceNodes=function(E,L){if(typeof E!="function")throw new C("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new C("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");for(var R,W,D=L,U=this._nodes.values();(R=U.next()).done!==!0;)D=E(D,(W=R.value).key,W.attributes);return D},b.nodeEntries=function(){var E=this._nodes.values();return new F(function(){var L=E.next();if(L.done)return L;var R=L.value;return{value:{node:R.key,attributes:R.attributes},done:!1}})},b.export=function(){var E=this,L=new Array(this._nodes.size),R=0;this._nodes.forEach(function(D,U){L[R++]=function(H,q){var X={key:H};return r(q.attributes)||(X.attributes=k({},q.attributes)),X}(U,D)});var W=new Array(this._edges.size);return R=0,this._edges.forEach(function(D,U){W[R++]=function(H,q,X){var Z={key:q,source:X.source.key,target:X.target.key};return r(X.attributes)||(Z.attributes=k({},X.attributes)),H==="mixed"&&X.undirected&&(Z.undirected=!0),Z}(E.type,U,D)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:L,edges:W}},b.import=function(E){var L,R,W,D,U,H=this,q=arguments.length>1&&arguments[1]!==void 0&&arguments[1];if(E instanceof M)return E.forEachNode(function(d,a){q?H.mergeNode(d,a):H.addNode(d,a)}),E.forEachEdge(function(d,a,UE,XE,m0,p0,uE){q?uE?H.mergeUndirectedEdgeWithKey(d,UE,XE,a):H.mergeDirectedEdgeWithKey(d,UE,XE,a):uE?H.addUndirectedEdgeWithKey(d,UE,XE,a):H.addDirectedEdgeWithKey(d,UE,XE,a)}),this;if(!G(E))throw new C("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(E.attributes){if(!G(E.attributes))throw new C("Graph.import: invalid attributes. Expecting a plain object.");q?this.mergeAttributes(E.attributes):this.replaceAttributes(E.attributes)}if(E.nodes){if(W=E.nodes,!Array.isArray(W))throw new C("Graph.import: invalid nodes. Expecting an array.");for(L=0,R=W.length;L<R;L++){T0(D=W[L]);var X=D,Z=X.key,J=X.attributes;q?this.mergeNode(Z,J):this.addNode(Z,J)}}if(E.edges){var T=!1;if(this.type==="undirected"&&(T=!0),W=E.edges,!Array.isArray(W))throw new C("Graph.import: invalid edges. Expecting an array.");for(L=0,R=W.length;L<R;L++){V0(U=W[L]);var g=U,z=g.source,B=g.target,m=g.attributes,c=g.undirected,o=c===void 0?T:c;"key"in U?(q?o?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:o?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey).call(this,U.key,z,B,m):(q?o?this.mergeUndirectedEdge:this.mergeDirectedEdge:o?this.addUndirectedEdge:this.addDirectedEdge).call(this,z,B,m)}}return this},b.nullCopy=function(E){var L=new M(k({},this._options,E));return L.replaceAttributes(k({},this.getAttributes())),L},b.emptyCopy=function(E){var L=this.nullCopy(E);return this._nodes.forEach(function(R,W){var D=k({},R.attributes);R=new L.NodeDataClass(W,D),L._nodes.set(W,R)}),L},b.copy=function(E){if(typeof(E=E||{}).type=="string"&&E.type!==this.type&&E.type!=="mixed")throw new O('Graph.copy: cannot create an incompatible copy from "'.concat(this.type,'" type to "').concat(E.type,'" because this would mean losing information about the current graph.'));if(typeof E.multi=="boolean"&&E.multi!==this.multi&&E.multi!==!0)throw new O("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if(typeof E.allowSelfLoops=="boolean"&&E.allowSelfLoops!==this.allowSelfLoops&&E.allowSelfLoops!==!0)throw new O("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");for(var L,R,W=this.emptyCopy(E),D=this._edges.values();(L=D.next()).done!==!0;)IE(W,"copy",!1,(R=L.value).undirected,R.key,R.source.key,R.target.key,k({},R.attributes));return W},b.toJSON=function(){return this.export()},b.toString=function(){return"[object Graph]"},b.inspect=function(){var E=this,L={};this._nodes.forEach(function(H,q){L[q]=H.attributes});var R={},W={};this._edges.forEach(function(H,q){var X,Z=H.undirected?"--":"->",J="",T=H.source.key,g=H.target.key;H.undirected&&T>g&&(X=T,T=g,g=X);var z="(".concat(T,")").concat(Z,"(").concat(g,")");q.startsWith("geid_")?E.multi&&(W[z]===void 0?W[z]=0:W[z]++,J+="".concat(W[z],". ")):J+="[".concat(q,"]: "),R[J+=z]=H.attributes});var D={};for(var U in this)this.hasOwnProperty(U)&&!hE.has(U)&&typeof this[U]!="function"&&K(U)!=="symbol"&&(D[U]=this[U]);return D.attributes=this._attributes,D.nodes=L,D.edges=R,f(D,"constructor",this.constructor),D},M}(p.exports.EventEmitter);typeof Symbol!="undefined"&&(N.prototype[Symbol.for("nodejs.util.inspect.custom")]=N.prototype.inspect),[{name:function($){return"".concat($,"Edge")},generateKey:!0},{name:function($){return"".concat($,"DirectedEdge")},generateKey:!0,type:"directed"},{name:function($){return"".concat($,"UndirectedEdge")},generateKey:!0,type:"undirected"},{name:function($){return"".concat($,"EdgeWithKey")}},{name:function($){return"".concat($,"DirectedEdgeWithKey")},type:"directed"},{name:function($){return"".concat($,"UndirectedEdgeWithKey")},type:"undirected"}].forEach(function($){["add","merge","update"].forEach(function(M){var b=$.name(M),E=M==="add"?IE:y0;$.generateKey?N.prototype[b]=function(L,R,W){return E(this,b,!0,($.type||this.type)==="undirected",null,L,R,W,M==="update")}:N.prototype[b]=function(L,R,W,D){return E(this,b,!1,($.type||this.type)==="undirected",L,R,W,D,M==="update")}})}),function($){b0.forEach(function(M){var{name:b,attacher:E}=M;E($,b("Node"),0),E($,b("Source"),1),E($,b("Target"),2),E($,b("Opposite"),3)})}(N),function($){R0.forEach(function(M){var{name:b,attacher:E}=M;E($,b("Edge"),"mixed"),E($,b("DirectedEdge"),"directed"),E($,b("UndirectedEdge"),"undirected")})}(N),function($){D0.forEach(function(M){(function(b,E){var{name:L,type:R,direction:W}=E;b.prototype[L]=function(D,U){if(R!=="mixed"&&this.type!=="mixed"&&R!==this.type)return[];if(!arguments.length)return Q0(this,R);if(arguments.length===1){D=""+D;var H=this._nodes.get(D);if(H===void 0)throw new Q("Graph.".concat(L,': could not find the "').concat(D,'" node in the graph.'));return J0(this.multi,R==="mixed"?this.type:R,W,H)}if(arguments.length===2){D=""+D,U=""+U;var q=this._nodes.get(D);if(!q)throw new Q("Graph.".concat(L,':  could not find the "').concat(D,'" source node in the graph.'));if(!this._nodes.has(U))throw new Q("Graph.".concat(L,':  could not find the "').concat(U,'" target node in the graph.'));return C0(R,this.multi,W,q,U)}throw new C("Graph.".concat(L,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."))}})($,M),function(b,E){var{name:L,type:R,direction:W}=E,D="forEach"+L[0].toUpperCase()+L.slice(1,-1);b.prototype[D]=function(X,Z,J){if(R==="mixed"||this.type==="mixed"||R===this.type){if(arguments.length===1)return NE(!1,this,R,J=X);if(arguments.length===2){X=""+X,J=Z;var T=this._nodes.get(X);if(T===void 0)throw new Q("Graph.".concat(D,': could not find the "').concat(X,'" node in the graph.'));return JE(!1,this.multi,R==="mixed"?this.type:R,W,T,J)}if(arguments.length===3){X=""+X,Z=""+Z;var g=this._nodes.get(X);if(!g)throw new Q("Graph.".concat(D,':  could not find the "').concat(X,'" source node in the graph.'));if(!this._nodes.has(Z))throw new Q("Graph.".concat(D,':  could not find the "').concat(Z,'" target node in the graph.'));return YE(!1,R,this.multi,W,g,Z,J)}throw new C("Graph.".concat(D,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."))}};var U="map"+L[0].toUpperCase()+L.slice(1);b.prototype[U]=function(){var X,Z=Array.prototype.slice.call(arguments),J=Z.pop();if(Z.length===0){var T=0;R!=="directed"&&(T+=this.undirectedSize),R!=="undirected"&&(T+=this.directedSize),X=new Array(T);var g=0;Z.push(function(z,B,m,c,o,d,a){X[g++]=J(z,B,m,c,o,d,a)})}else X=[],Z.push(function(z,B,m,c,o,d,a){X.push(J(z,B,m,c,o,d,a))});return this[D].apply(this,Z),X};var H="filter"+L[0].toUpperCase()+L.slice(1);b.prototype[H]=function(){var X=Array.prototype.slice.call(arguments),Z=X.pop(),J=[];return X.push(function(T,g,z,B,m,c,o){Z(T,g,z,B,m,c,o)&&J.push(T)}),this[D].apply(this,X),J};var q="reduce"+L[0].toUpperCase()+L.slice(1);b.prototype[q]=function(){var X,Z,J=Array.prototype.slice.call(arguments);if(J.length<2||J.length>4)throw new C("Graph.".concat(q,": invalid number of arguments (expecting 2, 3 or 4 and got ").concat(J.length,")."));if(typeof J[J.length-1]=="function"&&typeof J[J.length-2]!="function")throw new C("Graph.".concat(q,": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));J.length===2?(X=J[0],Z=J[1],J=[]):J.length===3?(X=J[1],Z=J[2],J=[J[0]]):J.length===4&&(X=J[2],Z=J[3],J=[J[0],J[1]]);var T=Z;return J.push(function(g,z,B,m,c,o,d){T=X(T,g,z,B,m,c,o,d)}),this[D].apply(this,J),T}}($,M),function(b,E){var{name:L,type:R,direction:W}=E,D="find"+L[0].toUpperCase()+L.slice(1,-1);b.prototype[D]=function(q,X,Z){if(R!=="mixed"&&this.type!=="mixed"&&R!==this.type)return!1;if(arguments.length===1)return NE(!0,this,R,Z=q);if(arguments.length===2){q=""+q,Z=X;var J=this._nodes.get(q);if(J===void 0)throw new Q("Graph.".concat(D,': could not find the "').concat(q,'" node in the graph.'));return JE(!0,this.multi,R==="mixed"?this.type:R,W,J,Z)}if(arguments.length===3){q=""+q,X=""+X;var T=this._nodes.get(q);if(!T)throw new Q("Graph.".concat(D,':  could not find the "').concat(q,'" source node in the graph.'));if(!this._nodes.has(X))throw new Q("Graph.".concat(D,':  could not find the "').concat(X,'" target node in the graph.'));return YE(!0,R,this.multi,W,T,X,Z)}throw new C("Graph.".concat(D,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."))};var U="some"+L[0].toUpperCase()+L.slice(1,-1);b.prototype[U]=function(){var q=Array.prototype.slice.call(arguments),X=q.pop();return q.push(function(Z,J,T,g,z,B,m){return X(Z,J,T,g,z,B,m)}),!!this[D].apply(this,q)};var H="every"+L[0].toUpperCase()+L.slice(1,-1);b.prototype[H]=function(){var q=Array.prototype.slice.call(arguments),X=q.pop();return q.push(function(Z,J,T,g,z,B,m){return!X(Z,J,T,g,z,B,m)}),!this[D].apply(this,q)}}($,M),function(b,E){var{name:L,type:R,direction:W}=E,D=L.slice(0,-1)+"Entries";b.prototype[D]=function(U,H){if(R!=="mixed"&&this.type!=="mixed"&&R!==this.type)return F.empty();if(!arguments.length)return Z0(this,R);if(arguments.length===1){U=""+U;var q=this._nodes.get(U);if(!q)throw new Q("Graph.".concat(D,': could not find the "').concat(U,'" node in the graph.'));return Y0(R,W,q)}if(arguments.length===2){U=""+U,H=""+H;var X=this._nodes.get(U);if(!X)throw new Q("Graph.".concat(D,':  could not find the "').concat(U,'" source node in the graph.'));if(!this._nodes.has(H))throw new Q("Graph.".concat(D,':  could not find the "').concat(H,'" target node in the graph.'));return P0(R,W,X,H)}throw new C("Graph.".concat(D,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."))}}($,M)})}(N),function($){K0.forEach(function(M){j0($,M),function(b,E){var{name:L,type:R,direction:W}=E,D="forEach"+L[0].toUpperCase()+L.slice(1,-1);b.prototype[D]=function(X,Z){if(R==="mixed"||this.type==="mixed"||R===this.type){X=""+X;var J=this._nodes.get(X);if(J===void 0)throw new Q("Graph.".concat(D,': could not find the "').concat(X,'" node in the graph.'));CE(!1,R==="mixed"?this.type:R,W,J,Z)}};var U="map"+L[0].toUpperCase()+L.slice(1);b.prototype[U]=function(X,Z){var J=[];return this[D](X,function(T,g){J.push(Z(T,g))}),J};var H="filter"+L[0].toUpperCase()+L.slice(1);b.prototype[H]=function(X,Z){var J=[];return this[D](X,function(T,g){Z(T,g)&&J.push(T)}),J};var q="reduce"+L[0].toUpperCase()+L.slice(1);b.prototype[q]=function(X,Z,J){if(arguments.length<3)throw new C("Graph.".concat(q,": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));var T=J;return this[D](X,function(g,z){T=Z(T,g,z)}),T}}($,M),function(b,E){var{name:L,type:R,direction:W}=E,D=L[0].toUpperCase()+L.slice(1,-1),U="find"+D;b.prototype[U]=function(X,Z){if(R==="mixed"||this.type==="mixed"||R===this.type){X=""+X;var J=this._nodes.get(X);if(J===void 0)throw new Q("Graph.".concat(U,': could not find the "').concat(X,'" node in the graph.'));return CE(!0,R==="mixed"?this.type:R,W,J,Z)}};var H="some"+D;b.prototype[H]=function(X,Z){return!!this[U](X,Z)};var q="every"+D;b.prototype[q]=function(X,Z){return!this[U](X,function(J,T){return!Z(J,T)})}}($,M),O0($,M)})}(N);var lE=function($){function M(b){var E=k({type:"directed"},b);if("multi"in E&&E.multi!==!1)throw new C("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(E.type!=="directed")throw new C('DirectedGraph.from: inconsistent "'+E.type+'" type in given options!');return $.call(this,E)||this}return V(M,$),M}(N),mE=function($){function M(b){var E=k({type:"undirected"},b);if("multi"in E&&E.multi!==!1)throw new C("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(E.type!=="undirected")throw new C('UndirectedGraph.from: inconsistent "'+E.type+'" type in given options!');return $.call(this,E)||this}return V(M,$),M}(N),pE=function($){function M(b){var E=k({multi:!0},b);if("multi"in E&&E.multi!==!0)throw new C("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");return $.call(this,E)||this}return V(M,$),M}(N),sE=function($){function M(b){var E=k({type:"directed",multi:!0},b);if("multi"in E&&E.multi!==!0)throw new C("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(E.type!=="directed")throw new C('MultiDirectedGraph.from: inconsistent "'+E.type+'" type in given options!');return $.call(this,E)||this}return V(M,$),M}(N),BE=function($){function M(b){var E=k({type:"undirected",multi:!0},b);if("multi"in E&&E.multi!==!0)throw new C("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(E.type!=="undirected")throw new C('MultiUndirectedGraph.from: inconsistent "'+E.type+'" type in given options!');return $.call(this,E)||this}return V(M,$),M}(N);function bE($){$.from=function(M,b){var E=k({},M.options,b),L=new $(E);return L.import(M),L}}return bE(N),bE(lE),bE(mE),bE(pE),bE(sE),bE(BE),N.Graph=N,N.DirectedGraph=lE,N.UndirectedGraph=mE,N.MultiGraph=pE,N.MultiDirectedGraph=sE,N.MultiUndirectedGraph=BE,N.InvalidArgumentsGraphError=C,N.NotFoundGraphError=Q,N.UsageGraphError=O,N})});function cE(K,V){K=K.trim(),K=K.replace(/<!--[\s\S]*?-->/g,"");let v={declaration:void 0,root:void 0};v.declaration=_();let x=K.match(/<!\[CDATA\[[\s\S]*?\]\]>/gm);if(x)for(let P of x)K=K.replace(P,w(P));let S=k(K);if(S)if(S.children.length===1&&typeof S.children[0]!=="string")v.root=S.children[0];else throw new Error("XML源码不符合规范：有不止1个根节点");if(v.root&&V===!0)s(v.root);return v;function w(P){return`<![CDATA[${P.split("<![CDATA[")[1].split("]]>")[0].replace(/</,"[_*[$(<)$]*_]").replace(/>/,"[_*[$(>)$]*_]").replace(/\//,"[_*[$(/)$]*_]").replace(/\\/,"[_*[$(LS)$]*_]")}]]>`}function h(P){let A=P.match(/<!\[CDATA\[[\s\S]*?\]\]>/gm);if(A)for(let Y of A){let j=Y.split("<![CDATA[")[1].split("]]>")[0].replace(/\[_\*\[\$\(<\)\$\]\*\_]/,"<").replace(/\[_\*\[\$\(>\)\$\]\*_]/,">").replace(/\[_\*\[\$\(\/\)\$\]\*_]/,"/").replace(/\[_\*\[\$\(LS\)\$\]\*_]/,"\\");P=P.replace(Y,`<![CDATA[${j}]]>`)}return P}function _(){let P="",A=K.match(/^<\?xml[\s\S]*\?>/m);if(!A)return;else P=A[0],K=K.slice(P.length);let Y={name:""};if(u(P,Y),Y.attributes)return{attributes:Y.attributes};return}function k(P){let A=[],Y=!0;while(Y){let j=f(P);if(!j)Y=!1;else{let l="",n=void 0;if(j.type==="selfClose")l=j.str,n=y(l,j.name,!0);if(j.type==="normal")l=j.strs.outer,n=y(j.strs,j.name,!1);if(n)A.push(n);P=P.replace(l,"")}}if(P=P.replace(/[\r\n]/g,"").trim(),A.length===0)return;else return{children:A,strLeft:P}}function y(P,A,Y){let j={name:A};if(Y===!0)G(P,j);else r(P,j);return j}function G(P,A){u(P,A)}function r(P,A){u(P.attrs,A);let Y=P.inner;if(Y.match(/<(?<tag>[\w:]+)([^<^>])*?\/>/m)||Y.match(/<(?<tag>[\w:]+)[\s\S]*?>[\s\S]*?<\/\k<tag>*?>/m)){let j=k(Y);if(j){if(j.children&&j.children.length>0)A.children=j.children;if(j.strLeft!=="")j.strLeft=j.strLeft.replace(/[\r\n]/g,"").trim(),A.content=h(j.strLeft)}}else if(Y!=="")Y=Y.replace(/[\r\n]/g,"").trim(),A.content=h(Y)}function f(P){let A=P.match(/<([\w-:.]+)\s*/m);if(!A)return;else{let Y=A[1],j=I(P,Y);if(j)return{type:"selfClose",name:Y,str:j};let l=EE(P,Y);if(l)return{type:"normal",name:Y,strs:l};return}}function I(P,A){let Y=new RegExp(`<${A}[^<^>]*?/>`,"m"),j=P.match(Y);if(!j)return;else return j[0]}function EE(P,A){let j=new RegExp(`<${A}([\\s\\S]*?)>([\\s\\S]*?)</${A}>`,"gm").exec(P);if(!j)return;else return{outer:j[0],attrs:j[1],inner:j[2]}}function u(P,A){let Y=!0;while(Y){let j=P.match(/([\w:-]+)\s*=\s*("[^"]*"|'[^']*'|\w+)\s*/);if(!j)Y=!1;else{if(!A.attributes)A.attributes={};A.attributes[j[1]]=p(j[2]),P=P.replace(j[0],"")}}}function p(P){return P.replace(/^['"]|['"]$/g,"")}function s(P,A){let Y={};if(A)for(let j of Object.keys(A))Y[j]=A[j];if(P.attributes){let j=Object.keys(P.attributes);for(let l of j){if(l==="xmlns")Y._=P.attributes[l];if(l.indexOf("xmlns:")===0){let n=l.replace("xmlns:","");Y[n]=P.attributes[l]}}}if(P.name.indexOf(":")<0){if(Y._)P.name=Y._+P.name}else if(P.name.indexOf(":")>0&&P.name.split(":")[0]!=="http"&&P.name.split(":")[0]!=="https"){let j=P.name.split(":")[0];if(Y[j])P.name=P.name.replace(`${j}:`,`${Y[j]}`)}if(P.children)for(let j of P.children)s(j,Y)}}var N0=async(K)=>{try{let V=await fetch(K);if(!V.ok)throw new Error(`Network response was not ok, status: ${V.status}`);return await V.text()}catch(V){console.error("There was a problem with the fetch operation:",V)}},dE=async(K)=>{let V=await N0(K);if(!V)throw new Error("Could not get XML contents.");return cE(V)};var aE=w0(oE(),1),iE=(K)=>{let V=new aE.default,v={};for(let x of K){let{id:S,source:w,target:h,value:_,edge:k,style:y}=x.attributes||{},G=y&&y.startsWith("edgeLabel");if(!k&&!G&&_!==void 0&&w===void 0&&h===void 0)V.addNode(S,{label:_,style:y})}for(let x of K){let{id:S,source:w,target:h,value:_,edge:k}=x.attributes||{};if(k&&w!==void 0&&h!==void 0)if(v[S]=[w,h],_!==null)V.addEdge(w,h,{label:_});else V.addEdge(w,h)}for(let x of K){let{parent:S,value:w,style:h}=x.attributes||{};if(h&&h.startsWith("edgeLabel")&&S!==void 0&&w!==void 0&&S in v){let[k,y]=v[S];V.setEdgeAttribute(k,y,"label",w)}}return V};var jE=(K)=>{let V=[["amp","&"],["apos","'"],["#x27","'"],["#x2F","/"],["#39","'"],["#47","/"],["lt","<"],["gt",">"],["nbsp"," "],["quot",'"']];for(var v=0,x=V.length;v<x;++v)K=K.replace(new RegExp("&"+V[v][0]+";","g"),V[v][1]);return K};var OE=(K)=>jE(K.trim()).replace(/<\/?div>|<br>/g,""),z0=(K)=>{let v=/image=([^;]+)/.exec(K),x=v?v[1]:null;if(!x)return"";let w=/alt=([^;]+)/.exec(K),h=w?w[1]:"Zark image",_="",y=/zarbAssetWidth=([^;]+)/.exec(K),G=y?y[1]:null;return _+=`width: ${G};`,`<img src="${x.startsWith("https://")?x:"https://"+x}" alt="${h}" style="${_}">`},rE=(K)=>{let V=document.getElementById("game-container"),v=document.getElementById("current-node"),x=document.getElementById("value"),S=document.getElementById("decisions"),w=[...K.nodes()][0],h={};return K.forEachNode((_,k)=>{let{label:y,style:G}=k;if(!y||!G)return;if(!(G.indexOf("rhombus")>=0&&y.indexOf("GOTO:")<0))return;let f=OE(y);h[f]=_}),function _(){if(!V||!v||!x||!S)throw new Error("Did not find expected DOM elements.");let k=K.getNodeAttribute(w,"label"),y=K.getNodeAttribute(w,"style"),G=!0,r=!1;if(y.indexOf("rhombus")>=0)G=!1,r=!0;let f=k.indexOf("GOTO:");if(f>=0){let u=OE(k.substring(f+5)),p=u in h&&h[u];if(p&&K.hasNode(p)){w=p,_();return}else console.log(`Psst, hey Squambo. The user just tried to go to ${u}, which gave node "${p}".`)}if(G)x.innerHTML=jE(k),x.innerHTML+=z0(y);let I=Array.from(K.outNeighbors(w));if(I.length===0){x.innerHTML+="<p>[That's all for now.]</p>",S.innerHTML="";return}S.innerHTML="<p>Decisions:</p>";let EE=!0;if(I.forEach((u)=>{let p=K.getEdgeAttributes(w,u),s="label"in p&&p.label,P=s?p.label:u;EE=EE&&!s;let A=document.createElement("button"),Y=OE(P);A.style.display="block",A.tabIndex=0,A.innerHTML=`&gt; ${Y}`,A.addEventListener("click",()=>{w=u,_()}),S.appendChild(A)}),EE){let u=Math.floor(Math.random()*I.length),p=I[u];if(r){w=p,_();return}S.innerHTML="<p>Decisions:</p>";let s=document.createElement("button");s.tabIndex=0,s.innerHTML="&gt; The only option is to continue...",s.addEventListener("click",()=>{w=p,_()}),S.appendChild(s)}}};var h0="assets/ZARK.drawio.xml",f0=await dE(h0),nE=f0.root?.children[0].children[0].children[0].children;if(!nE)throw new Error("The tree did not have the expected format.");var I0=iE(nE),l0=rE(I0);l0();
