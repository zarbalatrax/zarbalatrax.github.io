var IX=Object.create;var{getPrototypeOf:xX,defineProperty:a7,getOwnPropertyNames:BX}=Object;var fX=Object.prototype.hasOwnProperty;var FX=(U,L,A)=>{A=U!=null?IX(xX(U)):{};let D=L||!U||!U.__esModule?a7(A,"default",{value:U,enumerable:!0}):A;for(let C of BX(U))if(!fX.call(D,C))a7(D,C,{get:()=>U[C],enumerable:!0});return D};var bX=(U,L)=>()=>(L||U((L={exports:{}}).exports,L),L.exports);var e7=bX((T7,N7)=>{(function(U,L){typeof T7=="object"&&typeof N7!="undefined"?N7.exports=L():typeof define=="function"&&define.amd?define(L):(U=typeof globalThis!="undefined"?globalThis:U||self).graphology=L()})(T7,function(){function U(Q){return U=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(Z){return typeof Z}:function(Z){return Z&&typeof Symbol=="function"&&Z.constructor===Symbol&&Z!==Symbol.prototype?"symbol":typeof Z},U(Q)}function L(Q,Z){Q.prototype=Object.create(Z.prototype),Q.prototype.constructor=Q,D(Q,Z)}function A(Q){return A=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(Z){return Z.__proto__||Object.getPrototypeOf(Z)},A(Q)}function D(Q,Z){return D=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(J,X){return J.__proto__=X,J},D(Q,Z)}function C(){if(typeof Reflect=="undefined"||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(Q){return!1}}function v(Q,Z,J){return v=C()?Reflect.construct.bind():function(X,q,Y){var $=[null];$.push.apply($,q);var K=new(Function.bind.apply(X,$));return Y&&D(K,Y.prototype),K},v.apply(null,arguments)}function x(Q){var Z=typeof Map=="function"?new Map:void 0;return x=function(J){if(J===null||(X=J,Function.toString.call(X).indexOf("[native code]")===-1))return J;var X;if(typeof J!="function")throw new TypeError("Super expression must either be null or a function");if(Z!==void 0){if(Z.has(J))return Z.get(J);Z.set(J,q)}function q(){return v(J,arguments,A(this).constructor)}return q.prototype=Object.create(J.prototype,{constructor:{value:q,enumerable:!1,writable:!0,configurable:!0}}),D(q,J)},x(Q)}function S(Q){if(Q===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return Q}var G=function(){for(var Q=arguments[0],Z=1,J=arguments.length;Z<J;Z++)if(arguments[Z])for(var X in arguments[Z])Q[X]=arguments[Z][X];return Q};function I(Q,Z,J,X){var q=Q._nodes.get(Z),Y=null;return q?Y=X==="mixed"?q.out&&q.out[J]||q.undirected&&q.undirected[J]:X==="directed"?q.out&&q.out[J]:q.undirected&&q.undirected[J]:Y}function f(Q){return U(Q)==="object"&&Q!==null}function i(Q){var Z;for(Z in Q)return!1;return!0}function N(Q,Z,J){Object.defineProperty(Q,Z,{enumerable:!1,configurable:!1,writable:!0,value:J})}function m(Q,Z,J){var X={enumerable:!0,configurable:!0};typeof J=="function"?X.get=J:(X.value=J,X.writable=!1),Object.defineProperty(Q,Z,X)}function j7(Q){return!!f(Q)&&!(Q.attributes&&!Array.isArray(Q.attributes))}typeof Object.assign=="function"&&(G=Object.assign);var a,Z7={exports:{}},c=typeof Reflect=="object"?Reflect:null,z=c&&typeof c.apply=="function"?c.apply:function(Q,Z,J){return Function.prototype.apply.call(Q,Z,J)};a=c&&typeof c.ownKeys=="function"?c.ownKeys:Object.getOwnPropertySymbols?function(Q){return Object.getOwnPropertyNames(Q).concat(Object.getOwnPropertySymbols(Q))}:function(Q){return Object.getOwnPropertyNames(Q)};var T=Number.isNaN||function(Q){return Q!=Q};function P(){P.init.call(this)}Z7.exports=P,Z7.exports.once=function(Q,Z){return new Promise(function(J,X){function q($){Q.removeListener(Z,Y),X($)}function Y(){typeof Q.removeListener=="function"&&Q.removeListener("error",q),J([].slice.call(arguments))}P7(Q,Z,Y,{once:!0}),Z!=="error"&&function($,K,j){typeof $.on=="function"&&P7($,"error",K,j)}(Q,q,{once:!0})})},P.EventEmitter=P,P.prototype._events=void 0,P.prototype._eventsCount=0,P.prototype._maxListeners=void 0;var H=10;function B(Q){if(typeof Q!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof Q)}function l(Q){return Q._maxListeners===void 0?P.defaultMaxListeners:Q._maxListeners}function n(Q,Z,J,X){var q,Y,$,K;if(B(J),(Y=Q._events)===void 0?(Y=Q._events=Object.create(null),Q._eventsCount=0):(Y.newListener!==void 0&&(Q.emit("newListener",Z,J.listener?J.listener:J),Y=Q._events),$=Y[Z]),$===void 0)$=Y[Z]=J,++Q._eventsCount;else if(typeof $=="function"?$=Y[Z]=X?[J,$]:[$,J]:X?$.unshift(J):$.push(J),(q=l(Q))>0&&$.length>q&&!$.warned){$.warned=!0;var j=new Error("Possible EventEmitter memory leak detected. "+$.length+" "+String(Z)+" listeners added. Use emitter.setMaxListeners() to increase limit");j.name="MaxListenersExceededWarning",j.emitter=Q,j.type=Z,j.count=$.length,K=j,console&&console.warn&&console.warn(K)}return Q}function X7(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function q7(Q,Z,J){var X={fired:!1,wrapFn:void 0,target:Q,type:Z,listener:J},q=X7.bind(X);return q.listener=J,X.wrapFn=q,q}function $7(Q,Z,J){var X=Q._events;if(X===void 0)return[];var q=X[Z];return q===void 0?[]:typeof q=="function"?J?[q.listener||q]:[q]:J?function(Y){for(var $=new Array(Y.length),K=0;K<$.length;++K)$[K]=Y[K].listener||Y[K];return $}(q):K7(q,q.length)}function p(Q){var Z=this._events;if(Z!==void 0){var J=Z[Q];if(typeof J=="function")return 1;if(J!==void 0)return J.length}return 0}function K7(Q,Z){for(var J=new Array(Z),X=0;X<Z;++X)J[X]=Q[X];return J}function P7(Q,Z,J,X){if(typeof Q.on=="function")X.once?Q.once(Z,J):Q.on(Z,J);else{if(typeof Q.addEventListener!="function")throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof Q);Q.addEventListener(Z,function q(Y){X.once&&Q.removeEventListener(Z,q),J(Y)})}}function s(Q){if(typeof Q!="function")throw new Error("obliterator/iterator: expecting a function!");this.next=Q}Object.defineProperty(P,"defaultMaxListeners",{enumerable:!0,get:function(){return H},set:function(Q){if(typeof Q!="number"||Q<0||T(Q))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+Q+".");H=Q}}),P.init=function(){this._events!==void 0&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},P.prototype.setMaxListeners=function(Q){if(typeof Q!="number"||Q<0||T(Q))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+Q+".");return this._maxListeners=Q,this},P.prototype.getMaxListeners=function(){return l(this)},P.prototype.emit=function(Q){for(var Z=[],J=1;J<arguments.length;J++)Z.push(arguments[J]);var X=Q==="error",q=this._events;if(q!==void 0)X=X&&q.error===void 0;else if(!X)return!1;if(X){var Y;if(Z.length>0&&(Y=Z[0]),Y instanceof Error)throw Y;var $=new Error("Unhandled error."+(Y?" ("+Y.message+")":""));throw $.context=Y,$}var K=q[Q];if(K===void 0)return!1;if(typeof K=="function")z(K,this,Z);else{var j=K.length,_=K7(K,j);for(J=0;J<j;++J)z(_[J],this,Z)}return!0},P.prototype.addListener=function(Q,Z){return n(this,Q,Z,!1)},P.prototype.on=P.prototype.addListener,P.prototype.prependListener=function(Q,Z){return n(this,Q,Z,!0)},P.prototype.once=function(Q,Z){return B(Z),this.on(Q,q7(this,Q,Z)),this},P.prototype.prependOnceListener=function(Q,Z){return B(Z),this.prependListener(Q,q7(this,Q,Z)),this},P.prototype.removeListener=function(Q,Z){var J,X,q,Y,$;if(B(Z),(X=this._events)===void 0)return this;if((J=X[Q])===void 0)return this;if(J===Z||J.listener===Z)--this._eventsCount==0?this._events=Object.create(null):(delete X[Q],X.removeListener&&this.emit("removeListener",Q,J.listener||Z));else if(typeof J!="function"){for(q=-1,Y=J.length-1;Y>=0;Y--)if(J[Y]===Z||J[Y].listener===Z){$=J[Y].listener,q=Y;break}if(q<0)return this;q===0?J.shift():function(K,j){for(;j+1<K.length;j++)K[j]=K[j+1];K.pop()}(J,q),J.length===1&&(X[Q]=J[0]),X.removeListener!==void 0&&this.emit("removeListener",Q,$||Z)}return this},P.prototype.off=P.prototype.removeListener,P.prototype.removeAllListeners=function(Q){var Z,J,X;if((J=this._events)===void 0)return this;if(J.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):J[Q]!==void 0&&(--this._eventsCount==0?this._events=Object.create(null):delete J[Q]),this;if(arguments.length===0){var q,Y=Object.keys(J);for(X=0;X<Y.length;++X)(q=Y[X])!=="removeListener"&&this.removeAllListeners(q);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(typeof(Z=J[Q])=="function")this.removeListener(Q,Z);else if(Z!==void 0)for(X=Z.length-1;X>=0;X--)this.removeListener(Q,Z[X]);return this},P.prototype.listeners=function(Q){return $7(this,Q,!0)},P.prototype.rawListeners=function(Q){return $7(this,Q,!1)},P.listenerCount=function(Q,Z){return typeof Q.listenerCount=="function"?Q.listenerCount(Z):p.call(Q,Z)},P.prototype.listenerCount=p,P.prototype.eventNames=function(){return this._eventsCount>0?a(this._events):[]},typeof Symbol!="undefined"&&(s.prototype[Symbol.iterator]=function(){return this}),s.of=function(){var Q=arguments,Z=Q.length,J=0;return new s(function(){return J>=Z?{done:!0}:{done:!1,value:Q[J++]}})},s.empty=function(){return new s(function(){return{done:!0}})},s.fromSequence=function(Q){var Z=0,J=Q.length;return new s(function(){return Z>=J?{done:!0}:{done:!1,value:Q[Z++]}})},s.is=function(Q){return Q instanceof s||typeof Q=="object"&&Q!==null&&typeof Q.next=="function"};var h=s,e={};e.ARRAY_BUFFER_SUPPORT=typeof ArrayBuffer!="undefined",e.SYMBOL_SUPPORT=typeof Symbol!="undefined";var E7=h,U7=e,Q7=U7.ARRAY_BUFFER_SUPPORT,ZX=U7.SYMBOL_SUPPORT,B7=function(Q){var Z=function(J){return typeof J=="string"||Array.isArray(J)||Q7&&ArrayBuffer.isView(J)?E7.fromSequence(J):typeof J!="object"||J===null?null:ZX&&typeof J[Symbol.iterator]=="function"?J[Symbol.iterator]():typeof J.next=="function"?J:null}(Q);if(!Z)throw new Error("obliterator: target is not iterable nor a valid iterator.");return Z},$X=B7,f7=function(Q,Z){for(var J,X=arguments.length>1?Z:1/0,q=X!==1/0?new Array(X):[],Y=0,$=$X(Q);;){if(Y===X)return q;if((J=$.next()).done)return Y!==Z&&(q.length=Y),q;q[Y++]=J.value}},S7=function(Q){function Z(J){var X;return(X=Q.call(this)||this).name="GraphError",X.message=J,X}return L(Z,Q),Z}(x(Error)),M=function(Q){function Z(J){var X;return(X=Q.call(this,J)||this).name="InvalidArgumentsGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(S(X),Z.prototype.constructor),X}return L(Z,Q),Z}(S7),E=function(Q){function Z(J){var X;return(X=Q.call(this,J)||this).name="NotFoundGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(S(X),Z.prototype.constructor),X}return L(Z,Q),Z}(S7),w=function(Q){function Z(J){var X;return(X=Q.call(this,J)||this).name="UsageGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(S(X),Z.prototype.constructor),X}return L(Z,Q),Z}(S7);function F7(Q,Z){this.key=Q,this.attributes=Z,this.clear()}function b7(Q,Z){this.key=Q,this.attributes=Z,this.clear()}function y7(Q,Z){this.key=Q,this.attributes=Z,this.clear()}function V7(Q,Z,J,X,q){this.key=Z,this.attributes=q,this.undirected=Q,this.source=J,this.target=X}F7.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}},b7.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}},y7.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}},V7.prototype.attach=function(){var Q="out",Z="in";this.undirected&&(Q=Z="undirected");var J=this.source.key,X=this.target.key;this.source[Q][X]=this,this.undirected&&J===X||(this.target[Z][J]=this)},V7.prototype.attachMulti=function(){var Q="out",Z="in",J=this.source.key,X=this.target.key;this.undirected&&(Q=Z="undirected");var q=this.source[Q],Y=q[X];if(Y===void 0)return q[X]=this,void(this.undirected&&J===X||(this.target[Z][J]=this));Y.previous=this,this.next=Y,q[X]=this,this.target[Z][J]=this},V7.prototype.detach=function(){var Q=this.source.key,Z=this.target.key,J="out",X="in";this.undirected&&(J=X="undirected"),delete this.source[J][Z],delete this.target[X][Q]},V7.prototype.detachMulti=function(){var Q=this.source.key,Z=this.target.key,J="out",X="in";this.undirected&&(J=X="undirected"),this.previous===void 0?this.next===void 0?(delete this.source[J][Z],delete this.target[X][Q]):(this.next.previous=void 0,this.source[J][Z]=this.next,this.target[X][Q]=this.next):(this.previous.next=this.next,this.next!==void 0&&(this.next.previous=this.previous))};function J7(Q,Z,J,X,q,Y,$){var K,j,_,W;if(X=""+X,J===0){if(!(K=Q._nodes.get(X)))throw new E("Graph.".concat(Z,': could not find the "').concat(X,'" node in the graph.'));_=q,W=Y}else if(J===3){if(q=""+q,!(j=Q._edges.get(q)))throw new E("Graph.".concat(Z,': could not find the "').concat(q,'" edge in the graph.'));var V=j.source.key,R=j.target.key;if(X===V)K=j.target;else{if(X!==R)throw new E("Graph.".concat(Z,': the "').concat(X,'" node is not attached to the "').concat(q,'" edge (').concat(V,", ").concat(R,")."));K=j.source}_=Y,W=$}else{if(!(j=Q._edges.get(X)))throw new E("Graph.".concat(Z,': could not find the "').concat(X,'" edge in the graph.'));K=J===1?j.source:j.target,_=q,W=Y}return[K,_,W]}var KX=[{name:function(Q){return"get".concat(Q,"Attribute")},attacher:function(Q,Z,J){Q.prototype[Z]=function(X,q,Y){var $=J7(this,Z,J,X,q,Y),K=$[0],j=$[1];return K.attributes[j]}}},{name:function(Q){return"get".concat(Q,"Attributes")},attacher:function(Q,Z,J){Q.prototype[Z]=function(X,q){return J7(this,Z,J,X,q)[0].attributes}}},{name:function(Q){return"has".concat(Q,"Attribute")},attacher:function(Q,Z,J){Q.prototype[Z]=function(X,q,Y){var $=J7(this,Z,J,X,q,Y),K=$[0],j=$[1];return K.attributes.hasOwnProperty(j)}}},{name:function(Q){return"set".concat(Q,"Attribute")},attacher:function(Q,Z,J){Q.prototype[Z]=function(X,q,Y,$){var K=J7(this,Z,J,X,q,Y,$),j=K[0],_=K[1],W=K[2];return j.attributes[_]=W,this.emit("nodeAttributesUpdated",{key:j.key,type:"set",attributes:j.attributes,name:_}),this}}},{name:function(Q){return"update".concat(Q,"Attribute")},attacher:function(Q,Z,J){Q.prototype[Z]=function(X,q,Y,$){var K=J7(this,Z,J,X,q,Y,$),j=K[0],_=K[1],W=K[2];if(typeof W!="function")throw new M("Graph.".concat(Z,": updater should be a function."));var V=j.attributes,R=W(V[_]);return V[_]=R,this.emit("nodeAttributesUpdated",{key:j.key,type:"set",attributes:j.attributes,name:_}),this}}},{name:function(Q){return"remove".concat(Q,"Attribute")},attacher:function(Q,Z,J){Q.prototype[Z]=function(X,q,Y){var $=J7(this,Z,J,X,q,Y),K=$[0],j=$[1];return delete K.attributes[j],this.emit("nodeAttributesUpdated",{key:K.key,type:"remove",attributes:K.attributes,name:j}),this}}},{name:function(Q){return"replace".concat(Q,"Attributes")},attacher:function(Q,Z,J){Q.prototype[Z]=function(X,q,Y){var $=J7(this,Z,J,X,q,Y),K=$[0],j=$[1];if(!f(j))throw new M("Graph.".concat(Z,": provided attributes are not a plain object."));return K.attributes=j,this.emit("nodeAttributesUpdated",{key:K.key,type:"replace",attributes:K.attributes}),this}}},{name:function(Q){return"merge".concat(Q,"Attributes")},attacher:function(Q,Z,J){Q.prototype[Z]=function(X,q,Y){var $=J7(this,Z,J,X,q,Y),K=$[0],j=$[1];if(!f(j))throw new M("Graph.".concat(Z,": provided attributes are not a plain object."));return G(K.attributes,j),this.emit("nodeAttributesUpdated",{key:K.key,type:"merge",attributes:K.attributes,data:j}),this}}},{name:function(Q){return"update".concat(Q,"Attributes")},attacher:function(Q,Z,J){Q.prototype[Z]=function(X,q,Y){var $=J7(this,Z,J,X,q,Y),K=$[0],j=$[1];if(typeof j!="function")throw new M("Graph.".concat(Z,": provided updater is not a function."));return K.attributes=j(K.attributes),this.emit("nodeAttributesUpdated",{key:K.key,type:"update",attributes:K.attributes}),this}}}],jX=[{name:function(Q){return"get".concat(Q,"Attribute")},attacher:function(Q,Z,J){Q.prototype[Z]=function(X,q){var Y;if(this.type!=="mixed"&&J!=="mixed"&&J!==this.type)throw new w("Graph.".concat(Z,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new w("Graph.".concat(Z,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var $=""+X,K=""+q;if(q=arguments[2],!(Y=I(this,$,K,J)))throw new E("Graph.".concat(Z,': could not find an edge for the given path ("').concat($,'" - "').concat(K,'").'))}else{if(J!=="mixed")throw new w("Graph.".concat(Z,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(X=""+X,!(Y=this._edges.get(X)))throw new E("Graph.".concat(Z,': could not find the "').concat(X,'" edge in the graph.'))}return Y.attributes[q]}}},{name:function(Q){return"get".concat(Q,"Attributes")},attacher:function(Q,Z,J){Q.prototype[Z]=function(X){var q;if(this.type!=="mixed"&&J!=="mixed"&&J!==this.type)throw new w("Graph.".concat(Z,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>1){if(this.multi)throw new w("Graph.".concat(Z,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var Y=""+X,$=""+arguments[1];if(!(q=I(this,Y,$,J)))throw new E("Graph.".concat(Z,': could not find an edge for the given path ("').concat(Y,'" - "').concat($,'").'))}else{if(J!=="mixed")throw new w("Graph.".concat(Z,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(X=""+X,!(q=this._edges.get(X)))throw new E("Graph.".concat(Z,': could not find the "').concat(X,'" edge in the graph.'))}return q.attributes}}},{name:function(Q){return"has".concat(Q,"Attribute")},attacher:function(Q,Z,J){Q.prototype[Z]=function(X,q){var Y;if(this.type!=="mixed"&&J!=="mixed"&&J!==this.type)throw new w("Graph.".concat(Z,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new w("Graph.".concat(Z,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var $=""+X,K=""+q;if(q=arguments[2],!(Y=I(this,$,K,J)))throw new E("Graph.".concat(Z,': could not find an edge for the given path ("').concat($,'" - "').concat(K,'").'))}else{if(J!=="mixed")throw new w("Graph.".concat(Z,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(X=""+X,!(Y=this._edges.get(X)))throw new E("Graph.".concat(Z,': could not find the "').concat(X,'" edge in the graph.'))}return Y.attributes.hasOwnProperty(q)}}},{name:function(Q){return"set".concat(Q,"Attribute")},attacher:function(Q,Z,J){Q.prototype[Z]=function(X,q,Y){var $;if(this.type!=="mixed"&&J!=="mixed"&&J!==this.type)throw new w("Graph.".concat(Z,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>3){if(this.multi)throw new w("Graph.".concat(Z,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var K=""+X,j=""+q;if(q=arguments[2],Y=arguments[3],!($=I(this,K,j,J)))throw new E("Graph.".concat(Z,': could not find an edge for the given path ("').concat(K,'" - "').concat(j,'").'))}else{if(J!=="mixed")throw new w("Graph.".concat(Z,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(X=""+X,!($=this._edges.get(X)))throw new E("Graph.".concat(Z,': could not find the "').concat(X,'" edge in the graph.'))}return $.attributes[q]=Y,this.emit("edgeAttributesUpdated",{key:$.key,type:"set",attributes:$.attributes,name:q}),this}}},{name:function(Q){return"update".concat(Q,"Attribute")},attacher:function(Q,Z,J){Q.prototype[Z]=function(X,q,Y){var $;if(this.type!=="mixed"&&J!=="mixed"&&J!==this.type)throw new w("Graph.".concat(Z,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>3){if(this.multi)throw new w("Graph.".concat(Z,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var K=""+X,j=""+q;if(q=arguments[2],Y=arguments[3],!($=I(this,K,j,J)))throw new E("Graph.".concat(Z,': could not find an edge for the given path ("').concat(K,'" - "').concat(j,'").'))}else{if(J!=="mixed")throw new w("Graph.".concat(Z,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(X=""+X,!($=this._edges.get(X)))throw new E("Graph.".concat(Z,': could not find the "').concat(X,'" edge in the graph.'))}if(typeof Y!="function")throw new M("Graph.".concat(Z,": updater should be a function."));return $.attributes[q]=Y($.attributes[q]),this.emit("edgeAttributesUpdated",{key:$.key,type:"set",attributes:$.attributes,name:q}),this}}},{name:function(Q){return"remove".concat(Q,"Attribute")},attacher:function(Q,Z,J){Q.prototype[Z]=function(X,q){var Y;if(this.type!=="mixed"&&J!=="mixed"&&J!==this.type)throw new w("Graph.".concat(Z,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new w("Graph.".concat(Z,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var $=""+X,K=""+q;if(q=arguments[2],!(Y=I(this,$,K,J)))throw new E("Graph.".concat(Z,': could not find an edge for the given path ("').concat($,'" - "').concat(K,'").'))}else{if(J!=="mixed")throw new w("Graph.".concat(Z,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(X=""+X,!(Y=this._edges.get(X)))throw new E("Graph.".concat(Z,': could not find the "').concat(X,'" edge in the graph.'))}return delete Y.attributes[q],this.emit("edgeAttributesUpdated",{key:Y.key,type:"remove",attributes:Y.attributes,name:q}),this}}},{name:function(Q){return"replace".concat(Q,"Attributes")},attacher:function(Q,Z,J){Q.prototype[Z]=function(X,q){var Y;if(this.type!=="mixed"&&J!=="mixed"&&J!==this.type)throw new w("Graph.".concat(Z,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new w("Graph.".concat(Z,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var $=""+X,K=""+q;if(q=arguments[2],!(Y=I(this,$,K,J)))throw new E("Graph.".concat(Z,': could not find an edge for the given path ("').concat($,'" - "').concat(K,'").'))}else{if(J!=="mixed")throw new w("Graph.".concat(Z,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(X=""+X,!(Y=this._edges.get(X)))throw new E("Graph.".concat(Z,': could not find the "').concat(X,'" edge in the graph.'))}if(!f(q))throw new M("Graph.".concat(Z,": provided attributes are not a plain object."));return Y.attributes=q,this.emit("edgeAttributesUpdated",{key:Y.key,type:"replace",attributes:Y.attributes}),this}}},{name:function(Q){return"merge".concat(Q,"Attributes")},attacher:function(Q,Z,J){Q.prototype[Z]=function(X,q){var Y;if(this.type!=="mixed"&&J!=="mixed"&&J!==this.type)throw new w("Graph.".concat(Z,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new w("Graph.".concat(Z,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var $=""+X,K=""+q;if(q=arguments[2],!(Y=I(this,$,K,J)))throw new E("Graph.".concat(Z,': could not find an edge for the given path ("').concat($,'" - "').concat(K,'").'))}else{if(J!=="mixed")throw new w("Graph.".concat(Z,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(X=""+X,!(Y=this._edges.get(X)))throw new E("Graph.".concat(Z,': could not find the "').concat(X,'" edge in the graph.'))}if(!f(q))throw new M("Graph.".concat(Z,": provided attributes are not a plain object."));return G(Y.attributes,q),this.emit("edgeAttributesUpdated",{key:Y.key,type:"merge",attributes:Y.attributes,data:q}),this}}},{name:function(Q){return"update".concat(Q,"Attributes")},attacher:function(Q,Z,J){Q.prototype[Z]=function(X,q){var Y;if(this.type!=="mixed"&&J!=="mixed"&&J!==this.type)throw new w("Graph.".concat(Z,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new w("Graph.".concat(Z,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var $=""+X,K=""+q;if(q=arguments[2],!(Y=I(this,$,K,J)))throw new E("Graph.".concat(Z,': could not find an edge for the given path ("').concat($,'" - "').concat(K,'").'))}else{if(J!=="mixed")throw new w("Graph.".concat(Z,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(X=""+X,!(Y=this._edges.get(X)))throw new E("Graph.".concat(Z,': could not find the "').concat(X,'" edge in the graph.'))}if(typeof q!="function")throw new M("Graph.".concat(Z,": provided updater is not a function."));return Y.attributes=q(Y.attributes),this.emit("edgeAttributesUpdated",{key:Y.key,type:"update",attributes:Y.attributes}),this}}}],VX=h,WX=B7,Y7=function(){var Q=arguments,Z=null,J=-1;return new VX(function(){for(var X=null;;){if(Z===null){if(++J>=Q.length)return{done:!0};Z=WX(Q[J])}if((X=Z.next()).done!==!0)break;Z=null}return X})},_X=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function PX(Q,Z,J,X){var q=!1;for(var Y in Z)if(Y!==X){var $=Z[Y];if(q=J($.key,$.attributes,$.source.key,$.target.key,$.source.attributes,$.target.attributes,$.undirected),Q&&q)return $.key}}function EX(Q,Z,J,X){var q,Y,$,K=!1;for(var j in Z)if(j!==X){q=Z[j];do{if(Y=q.source,$=q.target,K=J(q.key,q.attributes,Y.key,$.key,Y.attributes,$.attributes,q.undirected),Q&&K)return q.key;q=q.next}while(q!==void 0)}}function v7(Q,Z){var J,X=Object.keys(Q),q=X.length,Y=0;return new h(function(){do if(J)J=J.next;else{if(Y>=q)return{done:!0};var $=X[Y++];if($===Z){J=void 0;continue}J=Q[$]}while(!J);return{done:!1,value:{edge:J.key,attributes:J.attributes,source:J.source.key,target:J.target.key,sourceAttributes:J.source.attributes,targetAttributes:J.target.attributes,undirected:J.undirected}}})}function RX(Q,Z,J,X){var q=Z[J];if(q){var{source:Y,target:$}=q;return X(q.key,q.attributes,Y.key,$.key,Y.attributes,$.attributes,q.undirected)&&Q?q.key:void 0}}function HX(Q,Z,J,X){var q=Z[J];if(q){var Y=!1;do{if(Y=X(q.key,q.attributes,q.source.key,q.target.key,q.source.attributes,q.target.attributes,q.undirected),Q&&Y)return q.key;q=q.next}while(q!==void 0)}}function w7(Q,Z){var J=Q[Z];return J.next!==void 0?new h(function(){if(!J)return{done:!0};var X={edge:J.key,attributes:J.attributes,source:J.source.key,target:J.target.key,sourceAttributes:J.source.attributes,targetAttributes:J.target.attributes,undirected:J.undirected};return J=J.next,{done:!1,value:X}}):h.of({edge:J.key,attributes:J.attributes,source:J.source.key,target:J.target.key,sourceAttributes:J.source.attributes,targetAttributes:J.target.attributes,undirected:J.undirected})}function OX(Q,Z){if(Q.size===0)return[];if(Z==="mixed"||Z===Q.type)return typeof Array.from=="function"?Array.from(Q._edges.keys()):f7(Q._edges.keys(),Q._edges.size);for(var J,X,q=Z==="undirected"?Q.undirectedSize:Q.directedSize,Y=new Array(q),$=Z==="undirected",K=Q._edges.values(),j=0;(J=K.next()).done!==!0;)(X=J.value).undirected===$&&(Y[j++]=X.key);return Y}function h7(Q,Z,J,X){if(Z.size!==0){for(var q,Y,$=J!=="mixed"&&J!==Z.type,K=J==="undirected",j=!1,_=Z._edges.values();(q=_.next()).done!==!0;)if(Y=q.value,!$||Y.undirected===K){var W=Y,V=W.key,R=W.attributes,O=W.source,k=W.target;if(j=X(V,R,O.key,k.key,O.attributes,k.attributes,Y.undirected),Q&&j)return V}}}function UX(Q,Z){if(Q.size===0)return h.empty();var J=Z!=="mixed"&&Z!==Q.type,X=Z==="undirected",q=Q._edges.values();return new h(function(){for(var Y,$;;){if((Y=q.next()).done)return Y;if($=Y.value,!J||$.undirected===X)break}return{value:{edge:$.key,attributes:$.attributes,source:$.source.key,target:$.target.key,sourceAttributes:$.source.attributes,targetAttributes:$.target.attributes,undirected:$.undirected},done:!1}})}function k7(Q,Z,J,X,q,Y){var $,K=Z?EX:PX;if(J!=="undirected"){if(X!=="out"&&($=K(Q,q.in,Y),Q&&$))return $;if(X!=="in"&&($=K(Q,q.out,Y,X?void 0:q.key),Q&&$))return $}if(J!=="directed"&&($=K(Q,q.undirected,Y),Q&&$))return $}function DX(Q,Z,J,X){var q=[];return k7(!1,Q,Z,J,X,function(Y){q.push(Y)}),q}function MX(Q,Z,J){var X=h.empty();return Q!=="undirected"&&(Z!=="out"&&J.in!==void 0&&(X=Y7(X,v7(J.in))),Z!=="in"&&J.out!==void 0&&(X=Y7(X,v7(J.out,Z?void 0:J.key)))),Q!=="directed"&&J.undirected!==void 0&&(X=Y7(X,v7(J.undirected))),X}function G7(Q,Z,J,X,q,Y,$){var K,j=J?HX:RX;if(Z!=="undirected"){if(q.in!==void 0&&X!=="out"&&(K=j(Q,q.in,Y,$),Q&&K))return K;if(q.out!==void 0&&X!=="in"&&(X||q.key!==Y)&&(K=j(Q,q.out,Y,$),Q&&K))return K}if(Z!=="directed"&&q.undirected!==void 0&&(K=j(Q,q.undirected,Y,$),Q&&K))return K}function LX(Q,Z,J,X,q){var Y=[];return G7(!1,Q,Z,J,X,q,function($){Y.push($)}),Y}function zX(Q,Z,J,X){var q=h.empty();return Q!=="undirected"&&(J.in!==void 0&&Z!=="out"&&(X in J.in)&&(q=Y7(q,w7(J.in,X))),J.out!==void 0&&Z!=="in"&&(X in J.out)&&(Z||J.key!==X)&&(q=Y7(q,w7(J.out,X)))),Q!=="directed"&&J.undirected!==void 0&&X in J.undirected&&(q=Y7(q,w7(J.undirected,X))),q}var AX=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function D7(){this.A=null,this.B=null}function R7(Q,Z,J,X,q){for(var Y in X){var $=X[Y],K=$.source,j=$.target,_=K===J?j:K;if(!Z||!Z.has(_.key)){var W=q(_.key,_.attributes);if(Q&&W)return _.key}}}function C7(Q,Z,J,X,q){if(Z!=="mixed"){if(Z==="undirected")return R7(Q,null,X,X.undirected,q);if(typeof J=="string")return R7(Q,null,X,X[J],q)}var Y,$=new D7;if(Z!=="undirected"){if(J!=="out"){if(Y=R7(Q,null,X,X.in,q),Q&&Y)return Y;$.wrap(X.in)}if(J!=="in"){if(Y=R7(Q,$,X,X.out,q),Q&&Y)return Y;$.wrap(X.out)}}if(Z!=="directed"&&(Y=R7(Q,$,X,X.undirected,q),Q&&Y))return Y}function H7(Q,Z,J){var X=Object.keys(J),q=X.length,Y=0;return new h(function(){var $=null;do{if(Y>=q)return Q&&Q.wrap(J),{done:!0};var K=J[X[Y++]],j=K.source,_=K.target;$=j===Z?_:j,Q&&Q.has($.key)&&($=null)}while($===null);return{done:!1,value:{neighbor:$.key,attributes:$.attributes}}})}function SX(Q,Z){var{name:J,type:X,direction:q}=Z;Q.prototype[J]=function(Y){if(X!=="mixed"&&this.type!=="mixed"&&X!==this.type)return[];Y=""+Y;var $=this._nodes.get(Y);if($===void 0)throw new E("Graph.".concat(J,': could not find the "').concat(Y,'" node in the graph.'));return function(K,j,_){if(K!=="mixed"){if(K==="undirected")return Object.keys(_.undirected);if(typeof j=="string")return Object.keys(_[j])}var W=[];return C7(!1,K,j,_,function(V){W.push(V)}),W}(X==="mixed"?this.type:X,q,$)}}function vX(Q,Z){var{name:J,type:X,direction:q}=Z,Y=J.slice(0,-1)+"Entries";Q.prototype[Y]=function($){if(X!=="mixed"&&this.type!=="mixed"&&X!==this.type)return h.empty();$=""+$;var K=this._nodes.get($);if(K===void 0)throw new E("Graph.".concat(Y,': could not find the "').concat($,'" node in the graph.'));return function(j,_,W){if(j!=="mixed"){if(j==="undirected")return H7(null,W,W.undirected);if(typeof _=="string")return H7(null,W,W[_])}var V=h.empty(),R=new D7;return j!=="undirected"&&(_!=="out"&&(V=Y7(V,H7(R,W,W.in))),_!=="in"&&(V=Y7(V,H7(R,W,W.out)))),j!=="directed"&&(V=Y7(V,H7(R,W,W.undirected))),V}(X==="mixed"?this.type:X,q,K)}}function M7(Q,Z,J,X,q){for(var Y,$,K,j,_,W,V,R=X._nodes.values(),O=X.type;(Y=R.next()).done!==!0;){var k=!1;if($=Y.value,O!=="undirected")for(K in j=$.out){_=j[K];do{if(W=_.target,k=!0,V=q($.key,W.key,$.attributes,W.attributes,_.key,_.attributes,_.undirected),Q&&V)return _;_=_.next}while(_)}if(O!=="directed"){for(K in j=$.undirected)if(!(Z&&$.key>K)){_=j[K];do{if((W=_.target).key!==K&&(W=_.source),k=!0,V=q($.key,W.key,$.attributes,W.attributes,_.key,_.attributes,_.undirected),Q&&V)return _;_=_.next}while(_)}}if(J&&!k&&(V=q($.key,null,$.attributes,null,null,null,null),Q&&V))return null}}function wX(Q){if(!f(Q))throw new M('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in Q))throw new M("Graph.import: serialized node is missing its key.");if("attributes"in Q&&(!f(Q.attributes)||Q.attributes===null))throw new M("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function kX(Q){if(!f(Q))throw new M('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in Q))throw new M("Graph.import: serialized edge is missing its source.");if(!("target"in Q))throw new M("Graph.import: serialized edge is missing its target.");if("attributes"in Q&&(!f(Q.attributes)||Q.attributes===null))throw new M("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in Q&&typeof Q.undirected!="boolean")throw new M("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}D7.prototype.wrap=function(Q){this.A===null?this.A=Q:this.B===null&&(this.B=Q)},D7.prototype.has=function(Q){return this.A!==null&&Q in this.A||this.B!==null&&Q in this.B};var p7,GX=(p7=255&Math.floor(256*Math.random()),function(){return p7++}),CX=new Set(["directed","undirected","mixed"]),g7=new Set(["domain","_events","_eventsCount","_maxListeners"]),TX={allowSelfLoops:!0,multi:!1,type:"mixed"};function u7(Q,Z,J){var X=new Q.NodeDataClass(Z,J);return Q._nodes.set(Z,X),Q.emit("nodeAdded",{key:Z,attributes:J}),X}function m7(Q,Z,J,X,q,Y,$,K){if(!X&&Q.type==="undirected")throw new w("Graph.".concat(Z,": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead."));if(X&&Q.type==="directed")throw new w("Graph.".concat(Z,": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead."));if(K&&!f(K))throw new M("Graph.".concat(Z,': invalid attributes. Expecting an object but got "').concat(K,'"'));if(Y=""+Y,$=""+$,K=K||{},!Q.allowSelfLoops&&Y===$)throw new w("Graph.".concat(Z,': source & target are the same ("').concat(Y,`"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`));var j=Q._nodes.get(Y),_=Q._nodes.get($);if(!j)throw new E("Graph.".concat(Z,': source node "').concat(Y,'" not found.'));if(!_)throw new E("Graph.".concat(Z,': target node "').concat($,'" not found.'));var W={key:null,undirected:X,source:Y,target:$,attributes:K};if(J)q=Q._edgeKeyGenerator();else if(q=""+q,Q._edges.has(q))throw new w("Graph.".concat(Z,': the "').concat(q,'" edge already exists in the graph.'));if(!Q.multi&&(X?j.undirected[$]!==void 0:j.out[$]!==void 0))throw new w("Graph.".concat(Z,': an edge linking "').concat(Y,'" to "').concat($,`" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`));var V=new V7(X,q,j,_,K);Q._edges.set(q,V);var R=Y===$;return X?(j.undirectedDegree++,_.undirectedDegree++,R&&(j.undirectedLoops++,Q._undirectedSelfLoopCount++)):(j.outDegree++,_.inDegree++,R&&(j.directedLoops++,Q._directedSelfLoopCount++)),Q.multi?V.attachMulti():V.attach(),X?Q._undirectedSize++:Q._directedSize++,W.key=q,Q.emit("edgeAdded",W),q}function NX(Q,Z,J,X,q,Y,$,K,j){if(!X&&Q.type==="undirected")throw new w("Graph.".concat(Z,": you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead."));if(X&&Q.type==="directed")throw new w("Graph.".concat(Z,": you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead."));if(K){if(j){if(typeof K!="function")throw new M("Graph.".concat(Z,': invalid updater function. Expecting a function but got "').concat(K,'"'))}else if(!f(K))throw new M("Graph.".concat(Z,': invalid attributes. Expecting an object but got "').concat(K,'"'))}var _;if(Y=""+Y,$=""+$,j&&(_=K,K=void 0),!Q.allowSelfLoops&&Y===$)throw new w("Graph.".concat(Z,': source & target are the same ("').concat(Y,`"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`));var W,V,R=Q._nodes.get(Y),O=Q._nodes.get($);if(!J&&(W=Q._edges.get(q))){if(!(W.source.key===Y&&W.target.key===$||X&&W.source.key===$&&W.target.key===Y))throw new w("Graph.".concat(Z,': inconsistency detected when attempting to merge the "').concat(q,'" edge with "').concat(Y,'" source & "').concat($,'" target vs. ("').concat(W.source.key,'", "').concat(W.target.key,'").'));V=W}if(V||Q.multi||!R||(V=X?R.undirected[$]:R.out[$]),V){var k=[V.key,!1,!1,!1];if(j?!_:!K)return k;if(j){var F=V.attributes;V.attributes=_(F),Q.emit("edgeAttributesUpdated",{type:"replace",key:V.key,attributes:V.attributes})}else G(V.attributes,K),Q.emit("edgeAttributesUpdated",{type:"merge",key:V.key,attributes:V.attributes,data:K});return k}K=K||{},j&&_&&(K=_(K));var y={key:null,undirected:X,source:Y,target:$,attributes:K};if(J)q=Q._edgeKeyGenerator();else if(q=""+q,Q._edges.has(q))throw new w("Graph.".concat(Z,': the "').concat(q,'" edge already exists in the graph.'));var u=!1,g=!1;R||(R=u7(Q,Y,{}),u=!0,Y===$&&(O=R,g=!0)),O||(O=u7(Q,$,{}),g=!0),W=new V7(X,q,R,O,K),Q._edges.set(q,W);var d=Y===$;return X?(R.undirectedDegree++,O.undirectedDegree++,d&&(R.undirectedLoops++,Q._undirectedSelfLoopCount++)):(R.outDegree++,O.inDegree++,d&&(R.directedLoops++,Q._directedSelfLoopCount++)),Q.multi?W.attachMulti():W.attach(),X?Q._undirectedSize++:Q._directedSize++,y.key=q,Q.emit("edgeAdded",y),[q,!0,u,g]}function W7(Q,Z){Q._edges.delete(Z.key);var{source:J,target:X,attributes:q,undirected:Y}=Z,$=J===X;Y?(J.undirectedDegree--,X.undirectedDegree--,$&&(J.undirectedLoops--,Q._undirectedSelfLoopCount--)):(J.outDegree--,X.inDegree--,$&&(J.directedLoops--,Q._directedSelfLoopCount--)),Q.multi?Z.detachMulti():Z.detach(),Y?Q._undirectedSize--:Q._directedSize--,Q.emit("edgeDropped",{key:Z.key,attributes:q,source:J.key,target:X.key,undirected:Y})}var b=function(Q){function Z(X){var q;if(q=Q.call(this)||this,typeof(X=G({},TX,X)).multi!="boolean")throw new M(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "`.concat(X.multi,'".'));if(!CX.has(X.type))throw new M(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "`.concat(X.type,'".'));if(typeof X.allowSelfLoops!="boolean")throw new M(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "`.concat(X.allowSelfLoops,'".'));var Y=X.type==="mixed"?F7:X.type==="directed"?b7:y7;N(S(q),"NodeDataClass",Y);var $="geid_"+GX()+"_",K=0;return N(S(q),"_attributes",{}),N(S(q),"_nodes",new Map),N(S(q),"_edges",new Map),N(S(q),"_directedSize",0),N(S(q),"_undirectedSize",0),N(S(q),"_directedSelfLoopCount",0),N(S(q),"_undirectedSelfLoopCount",0),N(S(q),"_edgeKeyGenerator",function(){var j;do j=$+K++;while(q._edges.has(j));return j}),N(S(q),"_options",X),g7.forEach(function(j){return N(S(q),j,q[j])}),m(S(q),"order",function(){return q._nodes.size}),m(S(q),"size",function(){return q._edges.size}),m(S(q),"directedSize",function(){return q._directedSize}),m(S(q),"undirectedSize",function(){return q._undirectedSize}),m(S(q),"selfLoopCount",function(){return q._directedSelfLoopCount+q._undirectedSelfLoopCount}),m(S(q),"directedSelfLoopCount",function(){return q._directedSelfLoopCount}),m(S(q),"undirectedSelfLoopCount",function(){return q._undirectedSelfLoopCount}),m(S(q),"multi",q._options.multi),m(S(q),"type",q._options.type),m(S(q),"allowSelfLoops",q._options.allowSelfLoops),m(S(q),"implementation",function(){return"graphology"}),q}L(Z,Q);var J=Z.prototype;return J._resetInstanceCounters=function(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0},J.hasNode=function(X){return this._nodes.has(""+X)},J.hasDirectedEdge=function(X,q){if(this.type==="undirected")return!1;if(arguments.length===1){var Y=""+X,$=this._edges.get(Y);return!!$&&!$.undirected}if(arguments.length===2){X=""+X,q=""+q;var K=this._nodes.get(X);return!!K&&K.out.hasOwnProperty(q)}throw new M("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},J.hasUndirectedEdge=function(X,q){if(this.type==="directed")return!1;if(arguments.length===1){var Y=""+X,$=this._edges.get(Y);return!!$&&$.undirected}if(arguments.length===2){X=""+X,q=""+q;var K=this._nodes.get(X);return!!K&&K.undirected.hasOwnProperty(q)}throw new M("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},J.hasEdge=function(X,q){if(arguments.length===1){var Y=""+X;return this._edges.has(Y)}if(arguments.length===2){X=""+X,q=""+q;var $=this._nodes.get(X);return!!$&&($.out!==void 0&&$.out.hasOwnProperty(q)||$.undirected!==void 0&&$.undirected.hasOwnProperty(q))}throw new M("Graph.hasEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},J.directedEdge=function(X,q){if(this.type!=="undirected"){if(X=""+X,q=""+q,this.multi)throw new w("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");var Y=this._nodes.get(X);if(!Y)throw new E('Graph.directedEdge: could not find the "'.concat(X,'" source node in the graph.'));if(!this._nodes.has(q))throw new E('Graph.directedEdge: could not find the "'.concat(q,'" target node in the graph.'));var $=Y.out&&Y.out[q]||void 0;return $?$.key:void 0}},J.undirectedEdge=function(X,q){if(this.type!=="directed"){if(X=""+X,q=""+q,this.multi)throw new w("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");var Y=this._nodes.get(X);if(!Y)throw new E('Graph.undirectedEdge: could not find the "'.concat(X,'" source node in the graph.'));if(!this._nodes.has(q))throw new E('Graph.undirectedEdge: could not find the "'.concat(q,'" target node in the graph.'));var $=Y.undirected&&Y.undirected[q]||void 0;return $?$.key:void 0}},J.edge=function(X,q){if(this.multi)throw new w("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");X=""+X,q=""+q;var Y=this._nodes.get(X);if(!Y)throw new E('Graph.edge: could not find the "'.concat(X,'" source node in the graph.'));if(!this._nodes.has(q))throw new E('Graph.edge: could not find the "'.concat(q,'" target node in the graph.'));var $=Y.out&&Y.out[q]||Y.undirected&&Y.undirected[q]||void 0;if($)return $.key},J.areDirectedNeighbors=function(X,q){X=""+X,q=""+q;var Y=this._nodes.get(X);if(!Y)throw new E('Graph.areDirectedNeighbors: could not find the "'.concat(X,'" node in the graph.'));return this.type!=="undirected"&&((q in Y.in)||(q in Y.out))},J.areOutNeighbors=function(X,q){X=""+X,q=""+q;var Y=this._nodes.get(X);if(!Y)throw new E('Graph.areOutNeighbors: could not find the "'.concat(X,'" node in the graph.'));return this.type!=="undirected"&&q in Y.out},J.areInNeighbors=function(X,q){X=""+X,q=""+q;var Y=this._nodes.get(X);if(!Y)throw new E('Graph.areInNeighbors: could not find the "'.concat(X,'" node in the graph.'));return this.type!=="undirected"&&q in Y.in},J.areUndirectedNeighbors=function(X,q){X=""+X,q=""+q;var Y=this._nodes.get(X);if(!Y)throw new E('Graph.areUndirectedNeighbors: could not find the "'.concat(X,'" node in the graph.'));return this.type!=="directed"&&q in Y.undirected},J.areNeighbors=function(X,q){X=""+X,q=""+q;var Y=this._nodes.get(X);if(!Y)throw new E('Graph.areNeighbors: could not find the "'.concat(X,'" node in the graph.'));return this.type!=="undirected"&&((q in Y.in)||(q in Y.out))||this.type!=="directed"&&q in Y.undirected},J.areInboundNeighbors=function(X,q){X=""+X,q=""+q;var Y=this._nodes.get(X);if(!Y)throw new E('Graph.areInboundNeighbors: could not find the "'.concat(X,'" node in the graph.'));return this.type!=="undirected"&&q in Y.in||this.type!=="directed"&&q in Y.undirected},J.areOutboundNeighbors=function(X,q){X=""+X,q=""+q;var Y=this._nodes.get(X);if(!Y)throw new E('Graph.areOutboundNeighbors: could not find the "'.concat(X,'" node in the graph.'));return this.type!=="undirected"&&q in Y.out||this.type!=="directed"&&q in Y.undirected},J.inDegree=function(X){X=""+X;var q=this._nodes.get(X);if(!q)throw new E('Graph.inDegree: could not find the "'.concat(X,'" node in the graph.'));return this.type==="undirected"?0:q.inDegree},J.outDegree=function(X){X=""+X;var q=this._nodes.get(X);if(!q)throw new E('Graph.outDegree: could not find the "'.concat(X,'" node in the graph.'));return this.type==="undirected"?0:q.outDegree},J.directedDegree=function(X){X=""+X;var q=this._nodes.get(X);if(!q)throw new E('Graph.directedDegree: could not find the "'.concat(X,'" node in the graph.'));return this.type==="undirected"?0:q.inDegree+q.outDegree},J.undirectedDegree=function(X){X=""+X;var q=this._nodes.get(X);if(!q)throw new E('Graph.undirectedDegree: could not find the "'.concat(X,'" node in the graph.'));return this.type==="directed"?0:q.undirectedDegree},J.inboundDegree=function(X){X=""+X;var q=this._nodes.get(X);if(!q)throw new E('Graph.inboundDegree: could not find the "'.concat(X,'" node in the graph.'));var Y=0;return this.type!=="directed"&&(Y+=q.undirectedDegree),this.type!=="undirected"&&(Y+=q.inDegree),Y},J.outboundDegree=function(X){X=""+X;var q=this._nodes.get(X);if(!q)throw new E('Graph.outboundDegree: could not find the "'.concat(X,'" node in the graph.'));var Y=0;return this.type!=="directed"&&(Y+=q.undirectedDegree),this.type!=="undirected"&&(Y+=q.outDegree),Y},J.degree=function(X){X=""+X;var q=this._nodes.get(X);if(!q)throw new E('Graph.degree: could not find the "'.concat(X,'" node in the graph.'));var Y=0;return this.type!=="directed"&&(Y+=q.undirectedDegree),this.type!=="undirected"&&(Y+=q.inDegree+q.outDegree),Y},J.inDegreeWithoutSelfLoops=function(X){X=""+X;var q=this._nodes.get(X);if(!q)throw new E('Graph.inDegreeWithoutSelfLoops: could not find the "'.concat(X,'" node in the graph.'));return this.type==="undirected"?0:q.inDegree-q.directedLoops},J.outDegreeWithoutSelfLoops=function(X){X=""+X;var q=this._nodes.get(X);if(!q)throw new E('Graph.outDegreeWithoutSelfLoops: could not find the "'.concat(X,'" node in the graph.'));return this.type==="undirected"?0:q.outDegree-q.directedLoops},J.directedDegreeWithoutSelfLoops=function(X){X=""+X;var q=this._nodes.get(X);if(!q)throw new E('Graph.directedDegreeWithoutSelfLoops: could not find the "'.concat(X,'" node in the graph.'));return this.type==="undirected"?0:q.inDegree+q.outDegree-2*q.directedLoops},J.undirectedDegreeWithoutSelfLoops=function(X){X=""+X;var q=this._nodes.get(X);if(!q)throw new E('Graph.undirectedDegreeWithoutSelfLoops: could not find the "'.concat(X,'" node in the graph.'));return this.type==="directed"?0:q.undirectedDegree-2*q.undirectedLoops},J.inboundDegreeWithoutSelfLoops=function(X){X=""+X;var q=this._nodes.get(X);if(!q)throw new E('Graph.inboundDegreeWithoutSelfLoops: could not find the "'.concat(X,'" node in the graph.'));var Y=0,$=0;return this.type!=="directed"&&(Y+=q.undirectedDegree,$+=2*q.undirectedLoops),this.type!=="undirected"&&(Y+=q.inDegree,$+=q.directedLoops),Y-$},J.outboundDegreeWithoutSelfLoops=function(X){X=""+X;var q=this._nodes.get(X);if(!q)throw new E('Graph.outboundDegreeWithoutSelfLoops: could not find the "'.concat(X,'" node in the graph.'));var Y=0,$=0;return this.type!=="directed"&&(Y+=q.undirectedDegree,$+=2*q.undirectedLoops),this.type!=="undirected"&&(Y+=q.outDegree,$+=q.directedLoops),Y-$},J.degreeWithoutSelfLoops=function(X){X=""+X;var q=this._nodes.get(X);if(!q)throw new E('Graph.degreeWithoutSelfLoops: could not find the "'.concat(X,'" node in the graph.'));var Y=0,$=0;return this.type!=="directed"&&(Y+=q.undirectedDegree,$+=2*q.undirectedLoops),this.type!=="undirected"&&(Y+=q.inDegree+q.outDegree,$+=2*q.directedLoops),Y-$},J.source=function(X){X=""+X;var q=this._edges.get(X);if(!q)throw new E('Graph.source: could not find the "'.concat(X,'" edge in the graph.'));return q.source.key},J.target=function(X){X=""+X;var q=this._edges.get(X);if(!q)throw new E('Graph.target: could not find the "'.concat(X,'" edge in the graph.'));return q.target.key},J.extremities=function(X){X=""+X;var q=this._edges.get(X);if(!q)throw new E('Graph.extremities: could not find the "'.concat(X,'" edge in the graph.'));return[q.source.key,q.target.key]},J.opposite=function(X,q){X=""+X,q=""+q;var Y=this._edges.get(q);if(!Y)throw new E('Graph.opposite: could not find the "'.concat(q,'" edge in the graph.'));var $=Y.source.key,K=Y.target.key;if(X===$)return K;if(X===K)return $;throw new E('Graph.opposite: the "'.concat(X,'" node is not attached to the "').concat(q,'" edge (').concat($,", ").concat(K,")."))},J.hasExtremity=function(X,q){X=""+X,q=""+q;var Y=this._edges.get(X);if(!Y)throw new E('Graph.hasExtremity: could not find the "'.concat(X,'" edge in the graph.'));return Y.source.key===q||Y.target.key===q},J.isUndirected=function(X){X=""+X;var q=this._edges.get(X);if(!q)throw new E('Graph.isUndirected: could not find the "'.concat(X,'" edge in the graph.'));return q.undirected},J.isDirected=function(X){X=""+X;var q=this._edges.get(X);if(!q)throw new E('Graph.isDirected: could not find the "'.concat(X,'" edge in the graph.'));return!q.undirected},J.isSelfLoop=function(X){X=""+X;var q=this._edges.get(X);if(!q)throw new E('Graph.isSelfLoop: could not find the "'.concat(X,'" edge in the graph.'));return q.source===q.target},J.addNode=function(X,q){var Y=function($,K,j){if(j&&!f(j))throw new M('Graph.addNode: invalid attributes. Expecting an object but got "'.concat(j,'"'));if(K=""+K,j=j||{},$._nodes.has(K))throw new w('Graph.addNode: the "'.concat(K,'" node already exist in the graph.'));var _=new $.NodeDataClass(K,j);return $._nodes.set(K,_),$.emit("nodeAdded",{key:K,attributes:j}),_}(this,X,q);return Y.key},J.mergeNode=function(X,q){if(q&&!f(q))throw new M('Graph.mergeNode: invalid attributes. Expecting an object but got "'.concat(q,'"'));X=""+X,q=q||{};var Y=this._nodes.get(X);return Y?(q&&(G(Y.attributes,q),this.emit("nodeAttributesUpdated",{type:"merge",key:X,attributes:Y.attributes,data:q})),[X,!1]):(Y=new this.NodeDataClass(X,q),this._nodes.set(X,Y),this.emit("nodeAdded",{key:X,attributes:q}),[X,!0])},J.updateNode=function(X,q){if(q&&typeof q!="function")throw new M('Graph.updateNode: invalid updater function. Expecting a function but got "'.concat(q,'"'));X=""+X;var Y=this._nodes.get(X);if(Y){if(q){var $=Y.attributes;Y.attributes=q($),this.emit("nodeAttributesUpdated",{type:"replace",key:X,attributes:Y.attributes})}return[X,!1]}var K=q?q({}):{};return Y=new this.NodeDataClass(X,K),this._nodes.set(X,Y),this.emit("nodeAdded",{key:X,attributes:K}),[X,!0]},J.dropNode=function(X){X=""+X;var q,Y=this._nodes.get(X);if(!Y)throw new E('Graph.dropNode: could not find the "'.concat(X,'" node in the graph.'));if(this.type!=="undirected"){for(var $ in Y.out){q=Y.out[$];do W7(this,q),q=q.next;while(q)}for(var K in Y.in){q=Y.in[K];do W7(this,q),q=q.next;while(q)}}if(this.type!=="directed")for(var j in Y.undirected){q=Y.undirected[j];do W7(this,q),q=q.next;while(q)}this._nodes.delete(X),this.emit("nodeDropped",{key:X,attributes:Y.attributes})},J.dropEdge=function(X){var q;if(arguments.length>1){var Y=""+arguments[0],$=""+arguments[1];if(!(q=I(this,Y,$,this.type)))throw new E('Graph.dropEdge: could not find the "'.concat(Y,'" -> "').concat($,'" edge in the graph.'))}else if(X=""+X,!(q=this._edges.get(X)))throw new E('Graph.dropEdge: could not find the "'.concat(X,'" edge in the graph.'));return W7(this,q),this},J.dropDirectedEdge=function(X,q){if(arguments.length<2)throw new w("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new w("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");var Y=I(this,X=""+X,q=""+q,"directed");if(!Y)throw new E('Graph.dropDirectedEdge: could not find a "'.concat(X,'" -> "').concat(q,'" edge in the graph.'));return W7(this,Y),this},J.dropUndirectedEdge=function(X,q){if(arguments.length<2)throw new w("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new w("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");var Y=I(this,X,q,"undirected");if(!Y)throw new E('Graph.dropUndirectedEdge: could not find a "'.concat(X,'" -> "').concat(q,'" edge in the graph.'));return W7(this,Y),this},J.clear=function(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")},J.clearEdges=function(){for(var X,q=this._nodes.values();(X=q.next()).done!==!0;)X.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")},J.getAttribute=function(X){return this._attributes[X]},J.getAttributes=function(){return this._attributes},J.hasAttribute=function(X){return this._attributes.hasOwnProperty(X)},J.setAttribute=function(X,q){return this._attributes[X]=q,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:X}),this},J.updateAttribute=function(X,q){if(typeof q!="function")throw new M("Graph.updateAttribute: updater should be a function.");var Y=this._attributes[X];return this._attributes[X]=q(Y),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:X}),this},J.removeAttribute=function(X){return delete this._attributes[X],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:X}),this},J.replaceAttributes=function(X){if(!f(X))throw new M("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=X,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this},J.mergeAttributes=function(X){if(!f(X))throw new M("Graph.mergeAttributes: provided attributes are not a plain object.");return G(this._attributes,X),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:X}),this},J.updateAttributes=function(X){if(typeof X!="function")throw new M("Graph.updateAttributes: provided updater is not a function.");return this._attributes=X(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this},J.updateEachNodeAttributes=function(X,q){if(typeof X!="function")throw new M("Graph.updateEachNodeAttributes: expecting an updater function.");if(q&&!j7(q))throw new M("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");for(var Y,$,K=this._nodes.values();(Y=K.next()).done!==!0;)($=Y.value).attributes=X($.key,$.attributes);this.emit("eachNodeAttributesUpdated",{hints:q||null})},J.updateEachEdgeAttributes=function(X,q){if(typeof X!="function")throw new M("Graph.updateEachEdgeAttributes: expecting an updater function.");if(q&&!j7(q))throw new M("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");for(var Y,$,K,j,_=this._edges.values();(Y=_.next()).done!==!0;)K=($=Y.value).source,j=$.target,$.attributes=X($.key,$.attributes,K.key,j.key,K.attributes,j.attributes,$.undirected);this.emit("eachEdgeAttributesUpdated",{hints:q||null})},J.forEachAdjacencyEntry=function(X){if(typeof X!="function")throw new M("Graph.forEachAdjacencyEntry: expecting a callback.");M7(!1,!1,!1,this,X)},J.forEachAdjacencyEntryWithOrphans=function(X){if(typeof X!="function")throw new M("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");M7(!1,!1,!0,this,X)},J.forEachAssymetricAdjacencyEntry=function(X){if(typeof X!="function")throw new M("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");M7(!1,!0,!1,this,X)},J.forEachAssymetricAdjacencyEntryWithOrphans=function(X){if(typeof X!="function")throw new M("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");M7(!1,!0,!0,this,X)},J.nodes=function(){return typeof Array.from=="function"?Array.from(this._nodes.keys()):f7(this._nodes.keys(),this._nodes.size)},J.forEachNode=function(X){if(typeof X!="function")throw new M("Graph.forEachNode: expecting a callback.");for(var q,Y,$=this._nodes.values();(q=$.next()).done!==!0;)X((Y=q.value).key,Y.attributes)},J.findNode=function(X){if(typeof X!="function")throw new M("Graph.findNode: expecting a callback.");for(var q,Y,$=this._nodes.values();(q=$.next()).done!==!0;)if(X((Y=q.value).key,Y.attributes))return Y.key},J.mapNodes=function(X){if(typeof X!="function")throw new M("Graph.mapNode: expecting a callback.");for(var q,Y,$=this._nodes.values(),K=new Array(this.order),j=0;(q=$.next()).done!==!0;)Y=q.value,K[j++]=X(Y.key,Y.attributes);return K},J.someNode=function(X){if(typeof X!="function")throw new M("Graph.someNode: expecting a callback.");for(var q,Y,$=this._nodes.values();(q=$.next()).done!==!0;)if(X((Y=q.value).key,Y.attributes))return!0;return!1},J.everyNode=function(X){if(typeof X!="function")throw new M("Graph.everyNode: expecting a callback.");for(var q,Y,$=this._nodes.values();(q=$.next()).done!==!0;)if(!X((Y=q.value).key,Y.attributes))return!1;return!0},J.filterNodes=function(X){if(typeof X!="function")throw new M("Graph.filterNodes: expecting a callback.");for(var q,Y,$=this._nodes.values(),K=[];(q=$.next()).done!==!0;)X((Y=q.value).key,Y.attributes)&&K.push(Y.key);return K},J.reduceNodes=function(X,q){if(typeof X!="function")throw new M("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new M("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");for(var Y,$,K=q,j=this._nodes.values();(Y=j.next()).done!==!0;)K=X(K,($=Y.value).key,$.attributes);return K},J.nodeEntries=function(){var X=this._nodes.values();return new h(function(){var q=X.next();if(q.done)return q;var Y=q.value;return{value:{node:Y.key,attributes:Y.attributes},done:!1}})},J.export=function(){var X=this,q=new Array(this._nodes.size),Y=0;this._nodes.forEach(function(K,j){q[Y++]=function(_,W){var V={key:_};return i(W.attributes)||(V.attributes=G({},W.attributes)),V}(j,K)});var $=new Array(this._edges.size);return Y=0,this._edges.forEach(function(K,j){$[Y++]=function(_,W,V){var R={key:W,source:V.source.key,target:V.target.key};return i(V.attributes)||(R.attributes=G({},V.attributes)),_==="mixed"&&V.undirected&&(R.undirected=!0),R}(X.type,j,K)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:q,edges:$}},J.import=function(X){var q,Y,$,K,j,_=this,W=arguments.length>1&&arguments[1]!==void 0&&arguments[1];if(X instanceof Z)return X.forEachNode(function(o,t){W?_.mergeNode(o,t):_.addNode(o,t)}),X.forEachEdge(function(o,t,L7,z7,cX,sX,i7){W?i7?_.mergeUndirectedEdgeWithKey(o,L7,z7,t):_.mergeDirectedEdgeWithKey(o,L7,z7,t):i7?_.addUndirectedEdgeWithKey(o,L7,z7,t):_.addDirectedEdgeWithKey(o,L7,z7,t)}),this;if(!f(X))throw new M("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(X.attributes){if(!f(X.attributes))throw new M("Graph.import: invalid attributes. Expecting a plain object.");W?this.mergeAttributes(X.attributes):this.replaceAttributes(X.attributes)}if(X.nodes){if($=X.nodes,!Array.isArray($))throw new M("Graph.import: invalid nodes. Expecting an array.");for(q=0,Y=$.length;q<Y;q++){wX(K=$[q]);var V=K,R=V.key,O=V.attributes;W?this.mergeNode(R,O):this.addNode(R,O)}}if(X.edges){var k=!1;if(this.type==="undirected"&&(k=!0),$=X.edges,!Array.isArray($))throw new M("Graph.import: invalid edges. Expecting an array.");for(q=0,Y=$.length;q<Y;q++){kX(j=$[q]);var F=j,y=F.source,u=F.target,g=F.attributes,d=F.undirected,r=d===void 0?k:d;"key"in j?(W?r?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:r?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey).call(this,j.key,y,u,g):(W?r?this.mergeUndirectedEdge:this.mergeDirectedEdge:r?this.addUndirectedEdge:this.addDirectedEdge).call(this,y,u,g)}}return this},J.nullCopy=function(X){var q=new Z(G({},this._options,X));return q.replaceAttributes(G({},this.getAttributes())),q},J.emptyCopy=function(X){var q=this.nullCopy(X);return this._nodes.forEach(function(Y,$){var K=G({},Y.attributes);Y=new q.NodeDataClass($,K),q._nodes.set($,Y)}),q},J.copy=function(X){if(typeof(X=X||{}).type=="string"&&X.type!==this.type&&X.type!=="mixed")throw new w('Graph.copy: cannot create an incompatible copy from "'.concat(this.type,'" type to "').concat(X.type,'" because this would mean losing information about the current graph.'));if(typeof X.multi=="boolean"&&X.multi!==this.multi&&X.multi!==!0)throw new w("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if(typeof X.allowSelfLoops=="boolean"&&X.allowSelfLoops!==this.allowSelfLoops&&X.allowSelfLoops!==!0)throw new w("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");for(var q,Y,$=this.emptyCopy(X),K=this._edges.values();(q=K.next()).done!==!0;)m7($,"copy",!1,(Y=q.value).undirected,Y.key,Y.source.key,Y.target.key,G({},Y.attributes));return $},J.toJSON=function(){return this.export()},J.toString=function(){return"[object Graph]"},J.inspect=function(){var X=this,q={};this._nodes.forEach(function(_,W){q[W]=_.attributes});var Y={},$={};this._edges.forEach(function(_,W){var V,R=_.undirected?"--":"->",O="",k=_.source.key,F=_.target.key;_.undirected&&k>F&&(V=k,k=F,F=V);var y="(".concat(k,")").concat(R,"(").concat(F,")");W.startsWith("geid_")?X.multi&&($[y]===void 0?$[y]=0:$[y]++,O+="".concat($[y],". ")):O+="[".concat(W,"]: "),Y[O+=y]=_.attributes});var K={};for(var j in this)this.hasOwnProperty(j)&&!g7.has(j)&&typeof this[j]!="function"&&U(j)!=="symbol"&&(K[j]=this[j]);return K.attributes=this._attributes,K.nodes=q,K.edges=Y,N(K,"constructor",this.constructor),K},Z}(Z7.exports.EventEmitter);typeof Symbol!="undefined"&&(b.prototype[Symbol.for("nodejs.util.inspect.custom")]=b.prototype.inspect),[{name:function(Q){return"".concat(Q,"Edge")},generateKey:!0},{name:function(Q){return"".concat(Q,"DirectedEdge")},generateKey:!0,type:"directed"},{name:function(Q){return"".concat(Q,"UndirectedEdge")},generateKey:!0,type:"undirected"},{name:function(Q){return"".concat(Q,"EdgeWithKey")}},{name:function(Q){return"".concat(Q,"DirectedEdgeWithKey")},type:"directed"},{name:function(Q){return"".concat(Q,"UndirectedEdgeWithKey")},type:"undirected"}].forEach(function(Q){["add","merge","update"].forEach(function(Z){var J=Q.name(Z),X=Z==="add"?m7:NX;Q.generateKey?b.prototype[J]=function(q,Y,$){return X(this,J,!0,(Q.type||this.type)==="undirected",null,q,Y,$,Z==="update")}:b.prototype[J]=function(q,Y,$,K){return X(this,J,!1,(Q.type||this.type)==="undirected",q,Y,$,K,Z==="update")}})}),function(Q){KX.forEach(function(Z){var{name:J,attacher:X}=Z;X(Q,J("Node"),0),X(Q,J("Source"),1),X(Q,J("Target"),2),X(Q,J("Opposite"),3)})}(b),function(Q){jX.forEach(function(Z){var{name:J,attacher:X}=Z;X(Q,J("Edge"),"mixed"),X(Q,J("DirectedEdge"),"directed"),X(Q,J("UndirectedEdge"),"undirected")})}(b),function(Q){_X.forEach(function(Z){(function(J,X){var{name:q,type:Y,direction:$}=X;J.prototype[q]=function(K,j){if(Y!=="mixed"&&this.type!=="mixed"&&Y!==this.type)return[];if(!arguments.length)return OX(this,Y);if(arguments.length===1){K=""+K;var _=this._nodes.get(K);if(_===void 0)throw new E("Graph.".concat(q,': could not find the "').concat(K,'" node in the graph.'));return DX(this.multi,Y==="mixed"?this.type:Y,$,_)}if(arguments.length===2){K=""+K,j=""+j;var W=this._nodes.get(K);if(!W)throw new E("Graph.".concat(q,':  could not find the "').concat(K,'" source node in the graph.'));if(!this._nodes.has(j))throw new E("Graph.".concat(q,':  could not find the "').concat(j,'" target node in the graph.'));return LX(Y,this.multi,$,W,j)}throw new M("Graph.".concat(q,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."))}})(Q,Z),function(J,X){var{name:q,type:Y,direction:$}=X,K="forEach"+q[0].toUpperCase()+q.slice(1,-1);J.prototype[K]=function(V,R,O){if(Y==="mixed"||this.type==="mixed"||Y===this.type){if(arguments.length===1)return h7(!1,this,Y,O=V);if(arguments.length===2){V=""+V,O=R;var k=this._nodes.get(V);if(k===void 0)throw new E("Graph.".concat(K,': could not find the "').concat(V,'" node in the graph.'));return k7(!1,this.multi,Y==="mixed"?this.type:Y,$,k,O)}if(arguments.length===3){V=""+V,R=""+R;var F=this._nodes.get(V);if(!F)throw new E("Graph.".concat(K,':  could not find the "').concat(V,'" source node in the graph.'));if(!this._nodes.has(R))throw new E("Graph.".concat(K,':  could not find the "').concat(R,'" target node in the graph.'));return G7(!1,Y,this.multi,$,F,R,O)}throw new M("Graph.".concat(K,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."))}};var j="map"+q[0].toUpperCase()+q.slice(1);J.prototype[j]=function(){var V,R=Array.prototype.slice.call(arguments),O=R.pop();if(R.length===0){var k=0;Y!=="directed"&&(k+=this.undirectedSize),Y!=="undirected"&&(k+=this.directedSize),V=new Array(k);var F=0;R.push(function(y,u,g,d,r,o,t){V[F++]=O(y,u,g,d,r,o,t)})}else V=[],R.push(function(y,u,g,d,r,o,t){V.push(O(y,u,g,d,r,o,t))});return this[K].apply(this,R),V};var _="filter"+q[0].toUpperCase()+q.slice(1);J.prototype[_]=function(){var V=Array.prototype.slice.call(arguments),R=V.pop(),O=[];return V.push(function(k,F,y,u,g,d,r){R(k,F,y,u,g,d,r)&&O.push(k)}),this[K].apply(this,V),O};var W="reduce"+q[0].toUpperCase()+q.slice(1);J.prototype[W]=function(){var V,R,O=Array.prototype.slice.call(arguments);if(O.length<2||O.length>4)throw new M("Graph.".concat(W,": invalid number of arguments (expecting 2, 3 or 4 and got ").concat(O.length,")."));if(typeof O[O.length-1]=="function"&&typeof O[O.length-2]!="function")throw new M("Graph.".concat(W,": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));O.length===2?(V=O[0],R=O[1],O=[]):O.length===3?(V=O[1],R=O[2],O=[O[0]]):O.length===4&&(V=O[2],R=O[3],O=[O[0],O[1]]);var k=R;return O.push(function(F,y,u,g,d,r,o){k=V(k,F,y,u,g,d,r,o)}),this[K].apply(this,O),k}}(Q,Z),function(J,X){var{name:q,type:Y,direction:$}=X,K="find"+q[0].toUpperCase()+q.slice(1,-1);J.prototype[K]=function(W,V,R){if(Y!=="mixed"&&this.type!=="mixed"&&Y!==this.type)return!1;if(arguments.length===1)return h7(!0,this,Y,R=W);if(arguments.length===2){W=""+W,R=V;var O=this._nodes.get(W);if(O===void 0)throw new E("Graph.".concat(K,': could not find the "').concat(W,'" node in the graph.'));return k7(!0,this.multi,Y==="mixed"?this.type:Y,$,O,R)}if(arguments.length===3){W=""+W,V=""+V;var k=this._nodes.get(W);if(!k)throw new E("Graph.".concat(K,':  could not find the "').concat(W,'" source node in the graph.'));if(!this._nodes.has(V))throw new E("Graph.".concat(K,':  could not find the "').concat(V,'" target node in the graph.'));return G7(!0,Y,this.multi,$,k,V,R)}throw new M("Graph.".concat(K,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."))};var j="some"+q[0].toUpperCase()+q.slice(1,-1);J.prototype[j]=function(){var W=Array.prototype.slice.call(arguments),V=W.pop();return W.push(function(R,O,k,F,y,u,g){return V(R,O,k,F,y,u,g)}),!!this[K].apply(this,W)};var _="every"+q[0].toUpperCase()+q.slice(1,-1);J.prototype[_]=function(){var W=Array.prototype.slice.call(arguments),V=W.pop();return W.push(function(R,O,k,F,y,u,g){return!V(R,O,k,F,y,u,g)}),!this[K].apply(this,W)}}(Q,Z),function(J,X){var{name:q,type:Y,direction:$}=X,K=q.slice(0,-1)+"Entries";J.prototype[K]=function(j,_){if(Y!=="mixed"&&this.type!=="mixed"&&Y!==this.type)return h.empty();if(!arguments.length)return UX(this,Y);if(arguments.length===1){j=""+j;var W=this._nodes.get(j);if(!W)throw new E("Graph.".concat(K,': could not find the "').concat(j,'" node in the graph.'));return MX(Y,$,W)}if(arguments.length===2){j=""+j,_=""+_;var V=this._nodes.get(j);if(!V)throw new E("Graph.".concat(K,':  could not find the "').concat(j,'" source node in the graph.'));if(!this._nodes.has(_))throw new E("Graph.".concat(K,':  could not find the "').concat(_,'" target node in the graph.'));return zX(Y,$,V,_)}throw new M("Graph.".concat(K,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."))}}(Q,Z)})}(b),function(Q){AX.forEach(function(Z){SX(Q,Z),function(J,X){var{name:q,type:Y,direction:$}=X,K="forEach"+q[0].toUpperCase()+q.slice(1,-1);J.prototype[K]=function(V,R){if(Y==="mixed"||this.type==="mixed"||Y===this.type){V=""+V;var O=this._nodes.get(V);if(O===void 0)throw new E("Graph.".concat(K,': could not find the "').concat(V,'" node in the graph.'));C7(!1,Y==="mixed"?this.type:Y,$,O,R)}};var j="map"+q[0].toUpperCase()+q.slice(1);J.prototype[j]=function(V,R){var O=[];return this[K](V,function(k,F){O.push(R(k,F))}),O};var _="filter"+q[0].toUpperCase()+q.slice(1);J.prototype[_]=function(V,R){var O=[];return this[K](V,function(k,F){R(k,F)&&O.push(k)}),O};var W="reduce"+q[0].toUpperCase()+q.slice(1);J.prototype[W]=function(V,R,O){if(arguments.length<3)throw new M("Graph.".concat(W,": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));var k=O;return this[K](V,function(F,y){k=R(k,F,y)}),k}}(Q,Z),function(J,X){var{name:q,type:Y,direction:$}=X,K=q[0].toUpperCase()+q.slice(1,-1),j="find"+K;J.prototype[j]=function(V,R){if(Y==="mixed"||this.type==="mixed"||Y===this.type){V=""+V;var O=this._nodes.get(V);if(O===void 0)throw new E("Graph.".concat(j,': could not find the "').concat(V,'" node in the graph.'));return C7(!0,Y==="mixed"?this.type:Y,$,O,R)}};var _="some"+K;J.prototype[_]=function(V,R){return!!this[j](V,R)};var W="every"+K;J.prototype[W]=function(V,R){return!this[j](V,function(O,k){return!R(O,k)})}}(Q,Z),vX(Q,Z)})}(b);var l7=function(Q){function Z(J){var X=G({type:"directed"},J);if("multi"in X&&X.multi!==!1)throw new M("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(X.type!=="directed")throw new M('DirectedGraph.from: inconsistent "'+X.type+'" type in given options!');return Q.call(this,X)||this}return L(Z,Q),Z}(b),c7=function(Q){function Z(J){var X=G({type:"undirected"},J);if("multi"in X&&X.multi!==!1)throw new M("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(X.type!=="undirected")throw new M('UndirectedGraph.from: inconsistent "'+X.type+'" type in given options!');return Q.call(this,X)||this}return L(Z,Q),Z}(b),s7=function(Q){function Z(J){var X=G({multi:!0},J);if("multi"in X&&X.multi!==!0)throw new M("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");return Q.call(this,X)||this}return L(Z,Q),Z}(b),d7=function(Q){function Z(J){var X=G({type:"directed",multi:!0},J);if("multi"in X&&X.multi!==!0)throw new M("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(X.type!=="directed")throw new M('MultiDirectedGraph.from: inconsistent "'+X.type+'" type in given options!');return Q.call(this,X)||this}return L(Z,Q),Z}(b),o7=function(Q){function Z(J){var X=G({type:"undirected",multi:!0},J);if("multi"in X&&X.multi!==!0)throw new M("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(X.type!=="undirected")throw new M('MultiUndirectedGraph.from: inconsistent "'+X.type+'" type in given options!');return Q.call(this,X)||this}return L(Z,Q),Z}(b);function _7(Q){Q.from=function(Z,J){var X=G({},Z.options,J),q=new Q(X);return q.import(Z),q}}return _7(b),_7(l7),_7(c7),_7(s7),_7(d7),_7(o7),b.Graph=b,b.DirectedGraph=l7,b.UndirectedGraph=c7,b.MultiGraph=s7,b.MultiDirectedGraph=d7,b.MultiUndirectedGraph=o7,b.InvalidArgumentsGraphError=M,b.NotFoundGraphError=E,b.UsageGraphError=w,b})});function r7(U,L){U=U.trim(),U=U.replace(/<!--[\s\S]*?-->/g,"");let A={declaration:void 0,root:void 0};A.declaration=S();let D=U.match(/<!\[CDATA\[[\s\S]*?\]\]>/gm);if(D)for(let z of D)U=U.replace(z,v(z));let C=G(U);if(C)if(C.children.length===1&&typeof C.children[0]!=="string")A.root=C.children[0];else throw new Error("XML1");if(A.root&&L===!0)c(A.root);return A;function v(z){return`<![CDATA[${z.split("<![CDATA[")[1].split("]]>")[0].replace(/</,"[_*[$(<)$]*_]").replace(/>/,"[_*[$(>)$]*_]").replace(/\//,"[_*[$(/)$]*_]").replace(/\\/,"[_*[$(LS)$]*_]")}]]>`}function x(z){let T=z.match(/<!\[CDATA\[[\s\S]*?\]\]>/gm);if(T)for(let P of T){let H=P.split("<![CDATA[")[1].split("]]>")[0].replace(/\[_\*\[\$\(<\)\$\]\*\_]/,"<").replace(/\[_\*\[\$\(>\)\$\]\*_]/,">").replace(/\[_\*\[\$\(\/\)\$\]\*_]/,"/").replace(/\[_\*\[\$\(LS\)\$\]\*_]/,"\\");z=z.replace(P,`<![CDATA[${H}]]>`)}return z}function S(){let z="",T=U.match(/^<\?xml[\s\S]*\?>/m);if(!T)return;else z=T[0],U=U.slice(z.length);let P={name:""};if(a(z,P),P.attributes)return{attributes:P.attributes};return}function G(z){let T=[],P=!0;while(P){let H=N(z);if(!H)P=!1;else{let B="",l=void 0;if(H.type==="selfClose")B=H.str,l=I(B,H.name,!0);if(H.type==="normal")B=H.strs.outer,l=I(H.strs,H.name,!1);if(l)T.push(l);z=z.replace(B,"")}}if(z=z.replace(/[\r\n]/g,"").trim(),T.length===0)return;else return{children:T,strLeft:z}}function I(z,T,P){let H={name:T};if(P===!0)f(z,H);else i(z,H);return H}function f(z,T){a(z,T)}function i(z,T){a(z.attrs,T);let P=z.inner;if(P.match(/<(?<tag>[\w:]+)([^<^>])*?\/>/m)||P.match(/<(?<tag>[\w:]+)[\s\S]*?>[\s\S]*?<\/\k<tag>*?>/m)){let H=G(P);if(H){if(H.children&&H.children.length>0)T.children=H.children;if(H.strLeft!=="")H.strLeft=H.strLeft.replace(/[\r\n]/g,"").trim(),T.content=x(H.strLeft)}}else if(P!=="")P=P.replace(/[\r\n]/g,"").trim(),T.content=x(P)}function N(z){let T=z.match(/<([\w-:.]+)\s*/m);if(!T)return;else{let P=T[1],H=m(z,P);if(H)return{type:"selfClose",name:P,str:H};let B=j7(z,P);if(B)return{type:"normal",name:P,strs:B};return}}function m(z,T){let P=new RegExp(`<${T}[^<^>]*?/>`,"m"),H=z.match(P);if(!H)return;else return H[0]}function j7(z,T){let H=new RegExp(`<${T}([\\s\\S]*?)>([\\s\\S]*?)</${T}>`,"gm").exec(z);if(!H)return;else return{outer:H[0],attrs:H[1],inner:H[2]}}function a(z,T){let P=!0;while(P){let H=z.match(/([\w:-]+)\s*=\s*("[^"]*"|'[^']*'|\w+)\s*/);if(!H)P=!1;else{if(!T.attributes)T.attributes={};T.attributes[H[1]]=Z7(H[2]),z=z.replace(H[0],"")}}}function Z7(z){return z.replace(/^['"]|['"]$/g,"")}function c(z,T){let P={};if(T)for(let H of Object.keys(T))P[H]=T[H];if(z.attributes){let H=Object.keys(z.attributes);for(let B of H){if(B==="xmlns")P._=z.attributes[B];if(B.indexOf("xmlns:")===0){let l=B.replace("xmlns:","");P[l]=z.attributes[B]}}}if(z.name.indexOf(":")<0){if(P._)z.name=P._+z.name}else if(z.name.indexOf(":")>0&&z.name.split(":")[0]!=="http"&&z.name.split(":")[0]!=="https"){let H=z.name.split(":")[0];if(P[H])z.name=z.name.replace(`${H}:`,`${P[H]}`)}if(z.children)for(let H of z.children)c(H,P)}}var yX=async(U)=>{try{let L=await fetch(U);if(!L.ok)throw new Error(`Network response was not ok, status: ${L.status}`);return await L.text()}catch(L){console.error("There was a problem with the fetch operation:",L)}},n7=async(U)=>{let L=await yX(U);if(!L)throw new Error("Could not get XML contents.");return r7(L)};var t7=FX(e7(),1),XX=(U)=>{let L=new t7.default({multi:!0}),A={};for(let D of U){let{id:C,source:v,target:x,value:S,edge:G,style:I}=D.attributes||{},f=I&&I.startsWith("edgeLabel");if(!G&&!f&&S!==void 0&&v===void 0&&x===void 0)L.addNode(C,{label:S,style:I})}for(let D of U){let{id:C,source:v,target:x,value:S,edge:G}=D.attributes||{};if(G&&v!==void 0&&x!==void 0){if(S!==null)L.addEdgeWithKey(C,v,x,{label:S});else L.addEdgeWithKey(C,v,x);A[C]=C}}for(let D of U){let{parent:C,value:v,style:x}=D.attributes||{};if(x&&x.startsWith("edgeLabel")&&C!==void 0&&v!==void 0&&C in A)L.setEdgeAttribute(C,"label",v),console.log(C,v)}return L};var I7=(U)=>{let L=[["amp","&"],["apos","'"],["#x27","'"],["#x2F","/"],["#39","'"],["#47","/"],["lt","<"],["gt",">"],["nbsp"," "],["quot",'"']];for(var A=0,D=L.length;A<D;++A)U=U.replace(new RegExp("&"+L[A][0]+";","g"),L[A][1]);return U};var O7=(U)=>I7(U.trim()).replace(/<\/?div>/g,`
`).replaceAll("<br>",`
`),qX=(U)=>{let A=/image=([^;]+)/.exec(U),D=A?A[1]:null;if(!D)return"";let v=/alt=([^;]+)/.exec(U),x=v?v[1]:"Zark image",S="",I=/zarbAssetWidth=([^;]+)/.exec(U),f=I?I[1]:null;return S+=`width: ${f};`,`<img src="${D.startsWith("https://")?D:"https://"+D}" alt="${x}" style="${S}">`},QX=(U)=>{let L={},A=U.split(`
`);for(let D=0;D<A.length;D++){let C=A[D].trim();if(C==="")continue;let v=C.split(":");if(v.length!==2){console.warn(`Hey Squambo, line ${D} of the following dict string has an invalid syntax!`,U);continue}let[x,S]=v;x=x.trim(),S=S.trim();let G=S==="true",I=parseFloat(S);if(G||S==="false")L[x]=G;else if(!Number.isNaN(I))L[x]=I;else L[x]=S}return L},A7=(U,L)=>{let A=document.createElement("button");return A.style.display="block",A.tabIndex=0,A.innerHTML=`&gt; ${U}`,A.className="zark-option",A.addEventListener("click",L),A},hX=(U)=>{let L={">":(A,D)=>A>D,"<":(A,D)=>A<D,"<=":(A,D)=>A>=D,">=":(A,D)=>A<=D,"==":(A,D)=>A==D,"=":(A,D)=>A==D,"===":(A,D)=>A==D,":":(A,D)=>A==D};for(let A of Object.keys(L).sort((D,C)=>C.length-D.length)){let D=U.split(A);if(D.length<2)continue;let[C,v]=[D[0],parseFloat(D[1])];if(Number.isNaN(v))continue;let x=L[A];return{left:C,right:v,func:x}}},pX=(U)=>{U=O7(U);let L=(x)=>!0,A=U,D=/\[!if:(?<conditionText>.*?)\]/,v=U.match(D)?.groups?.conditionText;if(v){A=U.replace(D,"");let x=v.indexOf("items:");if(console.log({itemCheckIndex:x,optionText:A,conditionText:v}),x>=0)L=(S)=>{return v.substring(x+6)in S.items};else L=(S)=>{let G=hX(v);if(G===void 0)return console.warn("Squambo, a conditional expression failed to parse:",v),!1;let{left:I,right:f,func:i}=G;return console.log({left:S.player[I],right:f,func:i}),i(S.player[I],f)}}return{condition:L,optionText:A}},x7=({enemyName:U,state:L,className:A="zark-enemy"})=>{let D=document.createElement("img");if(U&&L)D.src=`assets/images/battle/${U}_${L}.gif`,D.alt=`${U} ${L} animation`;else D.src="assets/images/battle/slash.gif",D.alt="Slash!";return D.className=A,{imgElement:D,outerHTML:D.outerHTML}},JX=(U)=>{let L=document.getElementById("game-container"),A=document.getElementById("current-node"),D=document.getElementById("value"),C=document.getElementById("decisions"),v={currentNode:[...U.nodes()][0],items:{},equppedItems:[],player:{health:100,get attack(){return Object.values(v.items).reduce((S,G)=>S+(typeof G.attack==="number"&&G.attack||0),0)}},enemy:void 0,enemyJustDefeated:!1,pacifist:!1},x={};return U.forEachNode((S,G)=>{let{label:I,style:f}=G;if(!I||!f)return;if(!(f.indexOf("rhombus")>=0&&I.indexOf("GOTO:")<0))return;let N=O7(I);x[N]=S}),function S(){if(!L||!A||!D||!C)throw new Error("Did not find expected DOM elements.");if(window.gotoScene===void 0)window.gotoScene=function(P){let H=P in x&&x[P];if(console.log({gotoNode:H}),H&&U.hasNode(H)){v.currentNode=H,S();return}else console.log(`Psst, hey Squambo. The user just tried to go to "${P}", which gave node "${H}".`)};if(window.gotoNode===void 0)window.gotoNode=function(P){let H=P;if(H&&U.hasNode(H)){v.currentNode=H,S();return}else console.log(`Psst, hey Squambo. The user just tried to go to node "${H}".`)};let G=U.getNodeAttribute(v.currentNode,"label"),I=U.getNodeAttribute(v.currentNode,"style"),f=!0,i=!1;if(I.indexOf("rhombus")>=0)f=!1,i=!0;let N=I7(G),m=G.indexOf("GOTO:");if(m>=0){let P=O7(G.substring(m+5)).trim();window.gotoScene?.(P)}let j7=G.indexOf("ITEM:");if(j7>=0){let P=QX(O7(G.substring(j7+5)));N=`You got a ${P.name.toUpperCase()}.<br>`,N+='<div class="zarkbox">';for(let H in P)N+=`${H.toUpperCase()}: ${P[H]}<br>`;N+="</div>",v.items[P.name]=P,console.log(v.items,v.player.attack)}let a=v.enemy,Z7=G.indexOf("ENEMY:");if(a===void 0&&!v.enemyJustDefeated&&!v.pacifist&&Z7>=0)a=QX(O7(G.substring(Z7+6))),v.enemy=a;if(v.enemyJustDefeated=!1,a!==void 0){let P=!0,H=void 0,B=!1,l=!1,n=void 0,X7=0,q7=!1,$7=function(p,K7){if(p===void 0)return!1;if(H===void 0&&K7!==void 0)H=K7;K7??=0,X7=(K7-(H??K7))/1000;let P7=v.player;if(N="",p?.health>0&&Math.floor(X7)%3===2){if(!B){if(n===void 0||Math.abs(n-X7)>0.75)N="You got hit!",v.player.health-=p.attack,P=!0,B=!0;else if(n!==void 0)n=void 0,P=!0,B=!0,q7=!0}}else if(B)B=!1,P=!0,q7=!1;if(!P){requestAnimationFrame((e)=>$7(p,e));return}P=!1;let s=!0;C.innerHTML="";let h="idle";if(B&&!q7)h="attack";else if(l)h="hurt",N=`You attack the ${p.name}!`,p.health-=v.player.attack;if(l=!1,v.player.health<=0)N+="You died!";else if(p.health<=0){N=`Excellent, you defeated the ${p.name}`,h="die";let{outerHTML:e}=x7({enemyName:p.name,state:"die"});N+=e;let E7=A7("Continue...",()=>{v.enemy=p=void 0,v.enemyJustDefeated=!0,S()});C.appendChild(E7),s=!1}else{if(q7)N="You dodge the attack.";else if(h==="idle")N+=`Holy shit it's a fuckign ${p.name.toUpperCase()}.<br>`;let{outerHTML:e}=x7({enemyName:p.name,state:h});if(N+=e,h==="hurt"){let{outerHTML:Q7}=x7({className:"slash"});N+=`${Q7}`}N+='<div class="zarkbox">';for(let Q7 in p)N+=`${Q7.toUpperCase()}: ${p[Q7]}<br>`;N+="</div>",N+='<div class="zarkbox">',N+="YOU<br>";for(let Q7 in P7)N+=`${Q7.toUpperCase()}: ${P7[Q7]}<br>`;N+="</div>";let E7=A7("ATTACK",()=>{l=!0,P=!0});C.appendChild(E7);let U7=A7("DODGE",()=>{n=X7,console.log({dodgedT:n,t:X7})});C.appendChild(U7)}return D.innerHTML=N,D.innerHTML+=qX(I),D.innerHTML+='<div id="time"></div>',requestAnimationFrame((e)=>$7(p,e)),s};if($7(a))return}if(f)D.innerHTML=N,D.innerHTML+=qX(I);let c=Array.from(U.outNeighbors(v.currentNode)),z=U.outEdges(v.currentNode);if(c.length===0){D.innerHTML+="<p>[That's all for now.]</p>",C.innerHTML="";return}C.innerHTML="<p>Decisions:</p>";let T=!0;if(z.forEach((P)=>{let H=U.getEdgeAttributes(P),B=U.target(P),l="label"in H&&H.label,n=l?H.label:B,{optionText:X7,condition:q7}=pX(n);if(!q7(v))return;T=T&&!l;let $7=A7(X7,()=>{v.currentNode=B,S()});C.appendChild($7)}),T){let P=Math.floor(Math.random()*c.length),H=c[P];if(i){v.currentNode=H,S();return}C.innerHTML="<p>Decisions:</p>";let B=document.createElement("button");B.tabIndex=0,B.innerHTML="&gt; The only option is to continue...",B.addEventListener("click",()=>{v.currentNode=H,S()}),C.appendChild(B)}}};var gX="assets/ZARK.drawio.xml",uX=await n7(gX),YX=uX.root?.children[0].children[0].children[0].children;if(!YX)throw new Error("The tree did not have the expected format.");var mX=XX(YX),lX=JX(mX);lX();
