var mb=Object.create;var{getPrototypeOf:Nb,defineProperty:dE,getOwnPropertyNames:Vb}=Object;var _b=Object.prototype.hasOwnProperty;var fb=(X,l,P)=>{P=X!=null?mb(Nb(X)):{};let j=l||!X||!X.__esModule?dE(P,"default",{value:X,enumerable:!0}):P;for(let m of Vb(X))if(!_b.call(j,m))dE(j,m,{get:()=>X[m],enumerable:!0});return j};var vb=(X,l)=>()=>(l||X((l={exports:{}}).exports,l),l.exports);var aE=vb((ZE,AE)=>{(function(X,l){typeof ZE=="object"&&typeof AE!="undefined"?AE.exports=l():typeof define=="function"&&define.amd?define(l):(X=typeof globalThis!="undefined"?globalThis:X||self).graphology=l()})(ZE,function(){function X(s){return X=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(y){return typeof y}:function(y){return y&&typeof Symbol=="function"&&y.constructor===Symbol&&y!==Symbol.prototype?"symbol":typeof y},X(s)}function l(s,y){s.prototype=Object.create(y.prototype),s.prototype.constructor=s,j(s,y)}function P(s){return P=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(y){return y.__proto__||Object.getPrototypeOf(y)},P(s)}function j(s,y){return j=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(g,E){return g.__proto__=E,g},j(s,y)}function m(){if(typeof Reflect=="undefined"||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(s){return!1}}function J(s,y,g){return J=m()?Reflect.construct.bind():function(E,b,$){var R=[null];R.push.apply(R,b);var L=new(Function.bind.apply(E,R));return $&&j(L,$.prototype),L},J.apply(null,arguments)}function N(s){var y=typeof Map=="function"?new Map:void 0;return N=function(g){if(g===null||(E=g,Function.toString.call(E).indexOf("[native code]")===-1))return g;var E;if(typeof g!="function")throw new TypeError("Super expression must either be null or a function");if(y!==void 0){if(y.has(g))return y.get(g);y.set(g,b)}function b(){return J(g,arguments,P(this).constructor)}return b.prototype=Object.create(g.prototype,{constructor:{value:b,enumerable:!1,writable:!0,configurable:!0}}),j(b,g)},N(s)}function Q(s){if(s===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return s}var O=function(){for(var s=arguments[0],y=1,g=arguments.length;y<g;y++)if(arguments[y])for(var E in arguments[y])s[E]=arguments[y][E];return s};function V(s,y,g,E){var b=s._nodes.get(y),$=null;return b?$=E==="mixed"?b.out&&b.out[g]||b.undirected&&b.undirected[g]:E==="directed"?b.out&&b.out[g]:b.undirected&&b.undirected[g]:$}function f(s){return X(s)==="object"&&s!==null}function r(s){var y;for(y in s)return!1;return!0}function S(s,y,g){Object.defineProperty(s,y,{enumerable:!1,configurable:!1,writable:!0,value:g})}function I(s,y,g){var E={enumerable:!0,configurable:!0};typeof g=="function"?E.get=g:(E.value=g,E.writable=!1),Object.defineProperty(s,y,E)}function EE(s){return!!f(s)&&!(s.attributes&&!Array.isArray(s.attributes))}typeof Object.assign=="function"&&(O=Object.assign);var h,t={exports:{}},c=typeof Reflect=="object"?Reflect:null,Y=c&&typeof c.apply=="function"?c.apply:function(s,y,g){return Function.prototype.apply.call(s,y,g)};h=c&&typeof c.ownKeys=="function"?c.ownKeys:Object.getOwnPropertySymbols?function(s){return Object.getOwnPropertyNames(s).concat(Object.getOwnPropertySymbols(s))}:function(s){return Object.getOwnPropertyNames(s)};var K=Number.isNaN||function(s){return s!=s};function D(){D.init.call(this)}t.exports=D,t.exports.once=function(s,y){return new Promise(function(g,E){function b(R){s.removeListener(y,$),E(R)}function $(){typeof s.removeListener=="function"&&s.removeListener("error",b),g([].slice.call(arguments))}jE(s,y,$,{once:!0}),y!=="error"&&function(R,L,M){typeof R.on=="function"&&jE(R,"error",L,M)}(s,b,{once:!0})})},D.EventEmitter=D,D.prototype._events=void 0,D.prototype._eventsCount=0,D.prototype._maxListeners=void 0;var q=10;function v(s){if(typeof s!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof s)}function d(s){return s._maxListeners===void 0?D.defaultMaxListeners:s._maxListeners}function RE(s,y,g,E){var b,$,R,L;if(v(g),($=s._events)===void 0?($=s._events=Object.create(null),s._eventsCount=0):($.newListener!==void 0&&(s.emit("newListener",y,g.listener?g.listener:g),$=s._events),R=$[y]),R===void 0)R=$[y]=g,++s._eventsCount;else if(typeof R=="function"?R=$[y]=E?[g,R]:[R,g]:E?R.unshift(g):R.push(g),(b=d(s))>0&&R.length>b&&!R.warned){R.warned=!0;var M=new Error("Possible EventEmitter memory leak detected. "+R.length+" "+String(y)+" listeners added. Use emitter.setMaxListeners() to increase limit");M.name="MaxListenersExceededWarning",M.emitter=s,M.type=y,M.count=R.length,L=M,console&&console.warn&&console.warn(L)}return s}function TE(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function LE(s,y,g){var E={fired:!1,wrapFn:void 0,target:s,type:y,listener:g},b=TE.bind(E);return b.listener=g,E.wrapFn=b,b}function ME(s,y,g){var E=s._events;if(E===void 0)return[];var b=E[y];return b===void 0?[]:typeof b=="function"?g?[b.listener||b]:[b]:g?function($){for(var R=new Array($.length),L=0;L<R.length;++L)R[L]=$[L].listener||$[L];return R}(b):PE(b,b.length)}function OE(s){var y=this._events;if(y!==void 0){var g=y[s];if(typeof g=="function")return 1;if(g!==void 0)return g.length}return 0}function PE(s,y){for(var g=new Array(y),E=0;E<y;++E)g[E]=s[E];return g}function jE(s,y,g,E){if(typeof s.on=="function")E.once?s.once(y,g):s.on(y,g);else{if(typeof s.addEventListener!="function")throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof s);s.addEventListener(y,function b($){E.once&&s.removeEventListener(y,b),g($)})}}function a(s){if(typeof s!="function")throw new Error("obliterator/iterator: expecting a function!");this.next=s}Object.defineProperty(D,"defaultMaxListeners",{enumerable:!0,get:function(){return q},set:function(s){if(typeof s!="number"||s<0||K(s))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+s+".");q=s}}),D.init=function(){this._events!==void 0&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},D.prototype.setMaxListeners=function(s){if(typeof s!="number"||s<0||K(s))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+s+".");return this._maxListeners=s,this},D.prototype.getMaxListeners=function(){return d(this)},D.prototype.emit=function(s){for(var y=[],g=1;g<arguments.length;g++)y.push(arguments[g]);var E=s==="error",b=this._events;if(b!==void 0)E=E&&b.error===void 0;else if(!E)return!1;if(E){var $;if(y.length>0&&($=y[0]),$ instanceof Error)throw $;var R=new Error("Unhandled error."+($?" ("+$.message+")":""));throw R.context=$,R}var L=b[s];if(L===void 0)return!1;if(typeof L=="function")Y(L,this,y);else{var M=L.length,U=PE(L,M);for(g=0;g<M;++g)Y(U[g],this,y)}return!0},D.prototype.addListener=function(s,y){return RE(this,s,y,!1)},D.prototype.on=D.prototype.addListener,D.prototype.prependListener=function(s,y){return RE(this,s,y,!0)},D.prototype.once=function(s,y){return v(y),this.on(s,LE(this,s,y)),this},D.prototype.prependOnceListener=function(s,y){return v(y),this.prependListener(s,LE(this,s,y)),this},D.prototype.removeListener=function(s,y){var g,E,b,$,R;if(v(y),(E=this._events)===void 0)return this;if((g=E[s])===void 0)return this;if(g===y||g.listener===y)--this._eventsCount==0?this._events=Object.create(null):(delete E[s],E.removeListener&&this.emit("removeListener",s,g.listener||y));else if(typeof g!="function"){for(b=-1,$=g.length-1;$>=0;$--)if(g[$]===y||g[$].listener===y){R=g[$].listener,b=$;break}if(b<0)return this;b===0?g.shift():function(L,M){for(;M+1<L.length;M++)L[M]=L[M+1];L.pop()}(g,b),g.length===1&&(E[s]=g[0]),E.removeListener!==void 0&&this.emit("removeListener",s,R||y)}return this},D.prototype.off=D.prototype.removeListener,D.prototype.removeAllListeners=function(s){var y,g,E;if((g=this._events)===void 0)return this;if(g.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):g[s]!==void 0&&(--this._eventsCount==0?this._events=Object.create(null):delete g[s]),this;if(arguments.length===0){var b,$=Object.keys(g);for(E=0;E<$.length;++E)(b=$[E])!=="removeListener"&&this.removeAllListeners(b);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(typeof(y=g[s])=="function")this.removeListener(s,y);else if(y!==void 0)for(E=y.length-1;E>=0;E--)this.removeListener(s,y[E]);return this},D.prototype.listeners=function(s){return ME(this,s,!0)},D.prototype.rawListeners=function(s){return ME(this,s,!1)},D.listenerCount=function(s,y){return typeof s.listenerCount=="function"?s.listenerCount(y):OE.call(s,y)},D.prototype.listenerCount=OE,D.prototype.eventNames=function(){return this._eventsCount>0?h(this._events):[]},typeof Symbol!="undefined"&&(a.prototype[Symbol.iterator]=function(){return this}),a.of=function(){var s=arguments,y=s.length,g=0;return new a(function(){return g>=y?{done:!0}:{done:!1,value:s[g++]}})},a.empty=function(){return new a(function(){return{done:!0}})},a.fromSequence=function(s){var y=0,g=s.length;return new a(function(){return y>=g?{done:!0}:{done:!1,value:s[y++]}})},a.is=function(s){return s instanceof a||typeof s=="object"&&s!==null&&typeof s.next=="function"};var p=a,WE={};WE.ARRAY_BUFFER_SUPPORT=typeof ArrayBuffer!="undefined",WE.SYMBOL_SUPPORT=typeof Symbol!="undefined";var bb=p,mE=WE,sb=mE.ARRAY_BUFFER_SUPPORT,gb=mE.SYMBOL_SUPPORT,NE=function(s){var y=function(g){return typeof g=="string"||Array.isArray(g)||sb&&ArrayBuffer.isView(g)?bb.fromSequence(g):typeof g!="object"||g===null?null:gb&&typeof g[Symbol.iterator]=="function"?g[Symbol.iterator]():typeof g.next=="function"?g:null}(s);if(!y)throw new Error("obliterator: target is not iterable nor a valid iterator.");return y},$b=NE,VE=function(s,y){for(var g,E=arguments.length>1?y:1/0,b=E!==1/0?new Array(E):[],$=0,R=$b(s);;){if($===E)return b;if((g=R.next()).done)return $!==y&&(b.length=$),b;b[$++]=g.value}},qE=function(s){function y(g){var E;return(E=s.call(this)||this).name="GraphError",E.message=g,E}return l(y,s),y}(N(Error)),k=function(s){function y(g){var E;return(E=s.call(this,g)||this).name="InvalidArgumentsGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(Q(E),y.prototype.constructor),E}return l(y,s),y}(qE),H=function(s){function y(g){var E;return(E=s.call(this,g)||this).name="NotFoundGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(Q(E),y.prototype.constructor),E}return l(y,s),y}(qE),Z=function(s){function y(g){var E;return(E=s.call(this,g)||this).name="UsageGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(Q(E),y.prototype.constructor),E}return l(y,s),y}(qE);function _E(s,y){this.key=s,this.attributes=y,this.clear()}function fE(s,y){this.key=s,this.attributes=y,this.clear()}function vE(s,y){this.key=s,this.attributes=y,this.clear()}function bE(s,y,g,E,b){this.key=y,this.attributes=b,this.undirected=s,this.source=g,this.target=E}_E.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}},fE.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}},vE.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}},bE.prototype.attach=function(){var s="out",y="in";this.undirected&&(s=y="undirected");var g=this.source.key,E=this.target.key;this.source[s][E]=this,this.undirected&&g===E||(this.target[y][g]=this)},bE.prototype.attachMulti=function(){var s="out",y="in",g=this.source.key,E=this.target.key;this.undirected&&(s=y="undirected");var b=this.source[s],$=b[E];if($===void 0)return b[E]=this,void(this.undirected&&g===E||(this.target[y][g]=this));$.previous=this,this.next=$,b[E]=this,this.target[y][g]=this},bE.prototype.detach=function(){var s=this.source.key,y=this.target.key,g="out",E="in";this.undirected&&(g=E="undirected"),delete this.source[g][y],delete this.target[E][s]},bE.prototype.detachMulti=function(){var s=this.source.key,y=this.target.key,g="out",E="in";this.undirected&&(g=E="undirected"),this.previous===void 0?this.next===void 0?(delete this.source[g][y],delete this.target[E][s]):(this.next.previous=void 0,this.source[g][y]=this.next,this.target[E][s]=this.next):(this.previous.next=this.next,this.next!==void 0&&(this.next.previous=this.previous))};function n(s,y,g,E,b,$,R){var L,M,U,C;if(E=""+E,g===0){if(!(L=s._nodes.get(E)))throw new H("Graph.".concat(y,': could not find the "').concat(E,'" node in the graph.'));U=b,C=$}else if(g===3){if(b=""+b,!(M=s._edges.get(b)))throw new H("Graph.".concat(y,': could not find the "').concat(b,'" edge in the graph.'));var x=M.source.key,T=M.target.key;if(E===x)L=M.target;else{if(E!==T)throw new H("Graph.".concat(y,': the "').concat(E,'" node is not attached to the "').concat(b,'" edge (').concat(x,", ").concat(T,")."));L=M.source}U=$,C=R}else{if(!(M=s._edges.get(E)))throw new H("Graph.".concat(y,': could not find the "').concat(E,'" edge in the graph.'));L=g===1?M.source:M.target,U=b,C=$}return[L,U,C]}var yb=[{name:function(s){return"get".concat(s,"Attribute")},attacher:function(s,y,g){s.prototype[y]=function(E,b,$){var R=n(this,y,g,E,b,$),L=R[0],M=R[1];return L.attributes[M]}}},{name:function(s){return"get".concat(s,"Attributes")},attacher:function(s,y,g){s.prototype[y]=function(E,b){return n(this,y,g,E,b)[0].attributes}}},{name:function(s){return"has".concat(s,"Attribute")},attacher:function(s,y,g){s.prototype[y]=function(E,b,$){var R=n(this,y,g,E,b,$),L=R[0],M=R[1];return L.attributes.hasOwnProperty(M)}}},{name:function(s){return"set".concat(s,"Attribute")},attacher:function(s,y,g){s.prototype[y]=function(E,b,$,R){var L=n(this,y,g,E,b,$,R),M=L[0],U=L[1],C=L[2];return M.attributes[U]=C,this.emit("nodeAttributesUpdated",{key:M.key,type:"set",attributes:M.attributes,name:U}),this}}},{name:function(s){return"update".concat(s,"Attribute")},attacher:function(s,y,g){s.prototype[y]=function(E,b,$,R){var L=n(this,y,g,E,b,$,R),M=L[0],U=L[1],C=L[2];if(typeof C!="function")throw new k("Graph.".concat(y,": updater should be a function."));var x=M.attributes,T=C(x[U]);return x[U]=T,this.emit("nodeAttributesUpdated",{key:M.key,type:"set",attributes:M.attributes,name:U}),this}}},{name:function(s){return"remove".concat(s,"Attribute")},attacher:function(s,y,g){s.prototype[y]=function(E,b,$){var R=n(this,y,g,E,b,$),L=R[0],M=R[1];return delete L.attributes[M],this.emit("nodeAttributesUpdated",{key:L.key,type:"remove",attributes:L.attributes,name:M}),this}}},{name:function(s){return"replace".concat(s,"Attributes")},attacher:function(s,y,g){s.prototype[y]=function(E,b,$){var R=n(this,y,g,E,b,$),L=R[0],M=R[1];if(!f(M))throw new k("Graph.".concat(y,": provided attributes are not a plain object."));return L.attributes=M,this.emit("nodeAttributesUpdated",{key:L.key,type:"replace",attributes:L.attributes}),this}}},{name:function(s){return"merge".concat(s,"Attributes")},attacher:function(s,y,g){s.prototype[y]=function(E,b,$){var R=n(this,y,g,E,b,$),L=R[0],M=R[1];if(!f(M))throw new k("Graph.".concat(y,": provided attributes are not a plain object."));return O(L.attributes,M),this.emit("nodeAttributesUpdated",{key:L.key,type:"merge",attributes:L.attributes,data:M}),this}}},{name:function(s){return"update".concat(s,"Attributes")},attacher:function(s,y,g){s.prototype[y]=function(E,b,$){var R=n(this,y,g,E,b,$),L=R[0],M=R[1];if(typeof M!="function")throw new k("Graph.".concat(y,": provided updater is not a function."));return L.attributes=M(L.attributes),this.emit("nodeAttributesUpdated",{key:L.key,type:"update",attributes:L.attributes}),this}}}],Rb=[{name:function(s){return"get".concat(s,"Attribute")},attacher:function(s,y,g){s.prototype[y]=function(E,b){var $;if(this.type!=="mixed"&&g!=="mixed"&&g!==this.type)throw new Z("Graph.".concat(y,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new Z("Graph.".concat(y,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var R=""+E,L=""+b;if(b=arguments[2],!($=V(this,R,L,g)))throw new H("Graph.".concat(y,': could not find an edge for the given path ("').concat(R,'" - "').concat(L,'").'))}else{if(g!=="mixed")throw new Z("Graph.".concat(y,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(E=""+E,!($=this._edges.get(E)))throw new H("Graph.".concat(y,': could not find the "').concat(E,'" edge in the graph.'))}return $.attributes[b]}}},{name:function(s){return"get".concat(s,"Attributes")},attacher:function(s,y,g){s.prototype[y]=function(E){var b;if(this.type!=="mixed"&&g!=="mixed"&&g!==this.type)throw new Z("Graph.".concat(y,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>1){if(this.multi)throw new Z("Graph.".concat(y,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var $=""+E,R=""+arguments[1];if(!(b=V(this,$,R,g)))throw new H("Graph.".concat(y,': could not find an edge for the given path ("').concat($,'" - "').concat(R,'").'))}else{if(g!=="mixed")throw new Z("Graph.".concat(y,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(E=""+E,!(b=this._edges.get(E)))throw new H("Graph.".concat(y,': could not find the "').concat(E,'" edge in the graph.'))}return b.attributes}}},{name:function(s){return"has".concat(s,"Attribute")},attacher:function(s,y,g){s.prototype[y]=function(E,b){var $;if(this.type!=="mixed"&&g!=="mixed"&&g!==this.type)throw new Z("Graph.".concat(y,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new Z("Graph.".concat(y,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var R=""+E,L=""+b;if(b=arguments[2],!($=V(this,R,L,g)))throw new H("Graph.".concat(y,': could not find an edge for the given path ("').concat(R,'" - "').concat(L,'").'))}else{if(g!=="mixed")throw new Z("Graph.".concat(y,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(E=""+E,!($=this._edges.get(E)))throw new H("Graph.".concat(y,': could not find the "').concat(E,'" edge in the graph.'))}return $.attributes.hasOwnProperty(b)}}},{name:function(s){return"set".concat(s,"Attribute")},attacher:function(s,y,g){s.prototype[y]=function(E,b,$){var R;if(this.type!=="mixed"&&g!=="mixed"&&g!==this.type)throw new Z("Graph.".concat(y,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>3){if(this.multi)throw new Z("Graph.".concat(y,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var L=""+E,M=""+b;if(b=arguments[2],$=arguments[3],!(R=V(this,L,M,g)))throw new H("Graph.".concat(y,': could not find an edge for the given path ("').concat(L,'" - "').concat(M,'").'))}else{if(g!=="mixed")throw new Z("Graph.".concat(y,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(E=""+E,!(R=this._edges.get(E)))throw new H("Graph.".concat(y,': could not find the "').concat(E,'" edge in the graph.'))}return R.attributes[b]=$,this.emit("edgeAttributesUpdated",{key:R.key,type:"set",attributes:R.attributes,name:b}),this}}},{name:function(s){return"update".concat(s,"Attribute")},attacher:function(s,y,g){s.prototype[y]=function(E,b,$){var R;if(this.type!=="mixed"&&g!=="mixed"&&g!==this.type)throw new Z("Graph.".concat(y,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>3){if(this.multi)throw new Z("Graph.".concat(y,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var L=""+E,M=""+b;if(b=arguments[2],$=arguments[3],!(R=V(this,L,M,g)))throw new H("Graph.".concat(y,': could not find an edge for the given path ("').concat(L,'" - "').concat(M,'").'))}else{if(g!=="mixed")throw new Z("Graph.".concat(y,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(E=""+E,!(R=this._edges.get(E)))throw new H("Graph.".concat(y,': could not find the "').concat(E,'" edge in the graph.'))}if(typeof $!="function")throw new k("Graph.".concat(y,": updater should be a function."));return R.attributes[b]=$(R.attributes[b]),this.emit("edgeAttributesUpdated",{key:R.key,type:"set",attributes:R.attributes,name:b}),this}}},{name:function(s){return"remove".concat(s,"Attribute")},attacher:function(s,y,g){s.prototype[y]=function(E,b){var $;if(this.type!=="mixed"&&g!=="mixed"&&g!==this.type)throw new Z("Graph.".concat(y,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new Z("Graph.".concat(y,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var R=""+E,L=""+b;if(b=arguments[2],!($=V(this,R,L,g)))throw new H("Graph.".concat(y,': could not find an edge for the given path ("').concat(R,'" - "').concat(L,'").'))}else{if(g!=="mixed")throw new Z("Graph.".concat(y,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(E=""+E,!($=this._edges.get(E)))throw new H("Graph.".concat(y,': could not find the "').concat(E,'" edge in the graph.'))}return delete $.attributes[b],this.emit("edgeAttributesUpdated",{key:$.key,type:"remove",attributes:$.attributes,name:b}),this}}},{name:function(s){return"replace".concat(s,"Attributes")},attacher:function(s,y,g){s.prototype[y]=function(E,b){var $;if(this.type!=="mixed"&&g!=="mixed"&&g!==this.type)throw new Z("Graph.".concat(y,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new Z("Graph.".concat(y,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var R=""+E,L=""+b;if(b=arguments[2],!($=V(this,R,L,g)))throw new H("Graph.".concat(y,': could not find an edge for the given path ("').concat(R,'" - "').concat(L,'").'))}else{if(g!=="mixed")throw new Z("Graph.".concat(y,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(E=""+E,!($=this._edges.get(E)))throw new H("Graph.".concat(y,': could not find the "').concat(E,'" edge in the graph.'))}if(!f(b))throw new k("Graph.".concat(y,": provided attributes are not a plain object."));return $.attributes=b,this.emit("edgeAttributesUpdated",{key:$.key,type:"replace",attributes:$.attributes}),this}}},{name:function(s){return"merge".concat(s,"Attributes")},attacher:function(s,y,g){s.prototype[y]=function(E,b){var $;if(this.type!=="mixed"&&g!=="mixed"&&g!==this.type)throw new Z("Graph.".concat(y,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new Z("Graph.".concat(y,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var R=""+E,L=""+b;if(b=arguments[2],!($=V(this,R,L,g)))throw new H("Graph.".concat(y,': could not find an edge for the given path ("').concat(R,'" - "').concat(L,'").'))}else{if(g!=="mixed")throw new Z("Graph.".concat(y,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(E=""+E,!($=this._edges.get(E)))throw new H("Graph.".concat(y,': could not find the "').concat(E,'" edge in the graph.'))}if(!f(b))throw new k("Graph.".concat(y,": provided attributes are not a plain object."));return O($.attributes,b),this.emit("edgeAttributesUpdated",{key:$.key,type:"merge",attributes:$.attributes,data:b}),this}}},{name:function(s){return"update".concat(s,"Attributes")},attacher:function(s,y,g){s.prototype[y]=function(E,b){var $;if(this.type!=="mixed"&&g!=="mixed"&&g!==this.type)throw new Z("Graph.".concat(y,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new Z("Graph.".concat(y,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var R=""+E,L=""+b;if(b=arguments[2],!($=V(this,R,L,g)))throw new H("Graph.".concat(y,': could not find an edge for the given path ("').concat(R,'" - "').concat(L,'").'))}else{if(g!=="mixed")throw new Z("Graph.".concat(y,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(E=""+E,!($=this._edges.get(E)))throw new H("Graph.".concat(y,': could not find the "').concat(E,'" edge in the graph.'))}if(typeof b!="function")throw new k("Graph.".concat(y,": provided updater is not a function."));return $.attributes=b($.attributes),this.emit("edgeAttributesUpdated",{key:$.key,type:"update",attributes:$.attributes}),this}}}],Lb=p,Mb=NE,e=function(){var s=arguments,y=null,g=-1;return new Lb(function(){for(var E=null;;){if(y===null){if(++g>=s.length)return{done:!0};y=Mb(s[g])}if((E=y.next()).done!==!0)break;y=null}return E})},xb=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function Cb(s,y,g,E){var b=!1;for(var $ in y)if($!==E){var R=y[$];if(b=g(R.key,R.attributes,R.source.key,R.target.key,R.source.attributes,R.target.attributes,R.undirected),s&&b)return R.key}}function Ub(s,y,g,E){var b,$,R,L=!1;for(var M in y)if(M!==E){b=y[M];do{if($=b.source,R=b.target,L=g(b.key,b.attributes,$.key,R.key,$.attributes,R.attributes,b.undirected),s&&L)return b.key;b=b.next}while(b!==void 0)}}function kE(s,y){var g,E=Object.keys(s),b=E.length,$=0;return new p(function(){do if(g)g=g.next;else{if($>=b)return{done:!0};var R=E[$++];if(R===y){g=void 0;continue}g=s[R]}while(!g);return{done:!1,value:{edge:g.key,attributes:g.attributes,source:g.source.key,target:g.target.key,sourceAttributes:g.source.attributes,targetAttributes:g.target.attributes,undirected:g.undirected}}})}function Db(s,y,g,E){var b=y[g];if(b){var{source:$,target:R}=b;return E(b.key,b.attributes,$.key,R.key,$.attributes,R.attributes,b.undirected)&&s?b.key:void 0}}function Hb(s,y,g,E){var b=y[g];if(b){var $=!1;do{if($=E(b.key,b.attributes,b.source.key,b.target.key,b.source.attributes,b.target.attributes,b.undirected),s&&$)return b.key;b=b.next}while(b!==void 0)}}function XE(s,y){var g=s[y];return g.next!==void 0?new p(function(){if(!g)return{done:!0};var E={edge:g.key,attributes:g.attributes,source:g.source.key,target:g.target.key,sourceAttributes:g.source.attributes,targetAttributes:g.target.attributes,undirected:g.undirected};return g=g.next,{done:!1,value:E}}):p.of({edge:g.key,attributes:g.attributes,source:g.source.key,target:g.target.key,sourceAttributes:g.source.attributes,targetAttributes:g.target.attributes,undirected:g.undirected})}function Tb(s,y){if(s.size===0)return[];if(y==="mixed"||y===s.type)return typeof Array.from=="function"?Array.from(s._edges.keys()):VE(s._edges.keys(),s._edges.size);for(var g,E,b=y==="undirected"?s.undirectedSize:s.directedSize,$=new Array(b),R=y==="undirected",L=s._edges.values(),M=0;(g=L.next()).done!==!0;)(E=g.value).undirected===R&&($[M++]=E.key);return $}function SE(s,y,g,E){if(y.size!==0){for(var b,$,R=g!=="mixed"&&g!==y.type,L=g==="undirected",M=!1,U=y._edges.values();(b=U.next()).done!==!0;)if($=b.value,!R||$.undirected===L){var C=$,x=C.key,T=C.attributes,W=C.source,A=C.target;if(M=E(x,T,W.key,A.key,W.attributes,A.attributes,$.undirected),s&&M)return x}}}function Wb(s,y){if(s.size===0)return p.empty();var g=y!=="mixed"&&y!==s.type,E=y==="undirected",b=s._edges.values();return new p(function(){for(var $,R;;){if(($=b.next()).done)return $;if(R=$.value,!g||R.undirected===E)break}return{value:{edge:R.key,attributes:R.attributes,source:R.source.key,target:R.target.key,sourceAttributes:R.source.attributes,targetAttributes:R.target.attributes,undirected:R.undirected},done:!1}})}function YE(s,y,g,E,b,$){var R,L=y?Ub:Cb;if(g!=="undirected"){if(E!=="out"&&(R=L(s,b.in,$),s&&R))return R;if(E!=="in"&&(R=L(s,b.out,$,E?void 0:b.key),s&&R))return R}if(g!=="directed"&&(R=L(s,b.undirected,$),s&&R))return R}function qb(s,y,g,E){var b=[];return YE(!1,s,y,g,E,function($){b.push($)}),b}function kb(s,y,g){var E=p.empty();return s!=="undirected"&&(y!=="out"&&g.in!==void 0&&(E=e(E,kE(g.in))),y!=="in"&&g.out!==void 0&&(E=e(E,kE(g.out,y?void 0:g.key)))),s!=="directed"&&g.undirected!==void 0&&(E=e(E,kE(g.undirected))),E}function lE(s,y,g,E,b,$,R){var L,M=g?Hb:Db;if(y!=="undirected"){if(b.in!==void 0&&E!=="out"&&(L=M(s,b.in,$,R),s&&L))return L;if(b.out!==void 0&&E!=="in"&&(E||b.key!==$)&&(L=M(s,b.out,$,R),s&&L))return L}if(y!=="directed"&&b.undirected!==void 0&&(L=M(s,b.undirected,$,R),s&&L))return L}function Xb(s,y,g,E,b){var $=[];return lE(!1,s,y,g,E,b,function(R){$.push(R)}),$}function Yb(s,y,g,E){var b=p.empty();return s!=="undirected"&&(g.in!==void 0&&y!=="out"&&(E in g.in)&&(b=e(b,XE(g.in,E))),g.out!==void 0&&y!=="in"&&(E in g.out)&&(y||g.key!==E)&&(b=e(b,XE(g.out,E)))),s!=="directed"&&g.undirected!==void 0&&E in g.undirected&&(b=e(b,XE(g.undirected,E))),b}var lb=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function xE(){this.A=null,this.B=null}function $E(s,y,g,E,b){for(var $ in E){var R=E[$],L=R.source,M=R.target,U=L===g?M:L;if(!y||!y.has(U.key)){var C=b(U.key,U.attributes);if(s&&C)return U.key}}}function QE(s,y,g,E,b){if(y!=="mixed"){if(y==="undirected")return $E(s,null,E,E.undirected,b);if(typeof g=="string")return $E(s,null,E,E[g],b)}var $,R=new xE;if(y!=="undirected"){if(g!=="out"){if($=$E(s,null,E,E.in,b),s&&$)return $;R.wrap(E.in)}if(g!=="in"){if($=$E(s,R,E,E.out,b),s&&$)return $;R.wrap(E.out)}}if(y!=="directed"&&($=$E(s,R,E,E.undirected,b),s&&$))return $}function yE(s,y,g){var E=Object.keys(g),b=E.length,$=0;return new p(function(){var R=null;do{if($>=b)return s&&s.wrap(g),{done:!0};var L=g[E[$++]],M=L.source,U=L.target;R=M===y?U:M,s&&s.has(R.key)&&(R=null)}while(R===null);return{done:!1,value:{neighbor:R.key,attributes:R.attributes}}})}function Qb(s,y){var{name:g,type:E,direction:b}=y;s.prototype[g]=function($){if(E!=="mixed"&&this.type!=="mixed"&&E!==this.type)return[];$=""+$;var R=this._nodes.get($);if(R===void 0)throw new H("Graph.".concat(g,': could not find the "').concat($,'" node in the graph.'));return function(L,M,U){if(L!=="mixed"){if(L==="undirected")return Object.keys(U.undirected);if(typeof M=="string")return Object.keys(U[M])}var C=[];return QE(!1,L,M,U,function(x){C.push(x)}),C}(E==="mixed"?this.type:E,b,R)}}function Zb(s,y){var{name:g,type:E,direction:b}=y,$=g.slice(0,-1)+"Entries";s.prototype[$]=function(R){if(E!=="mixed"&&this.type!=="mixed"&&E!==this.type)return p.empty();R=""+R;var L=this._nodes.get(R);if(L===void 0)throw new H("Graph.".concat($,': could not find the "').concat(R,'" node in the graph.'));return function(M,U,C){if(M!=="mixed"){if(M==="undirected")return yE(null,C,C.undirected);if(typeof U=="string")return yE(null,C,C[U])}var x=p.empty(),T=new xE;return M!=="undirected"&&(U!=="out"&&(x=e(x,yE(T,C,C.in))),U!=="in"&&(x=e(x,yE(T,C,C.out)))),M!=="directed"&&(x=e(x,yE(T,C,C.undirected))),x}(E==="mixed"?this.type:E,b,L)}}function CE(s,y,g,E,b){for(var $,R,L,M,U,C,x,T=E._nodes.values(),W=E.type;($=T.next()).done!==!0;){var A=!1;if(R=$.value,W!=="undirected")for(L in M=R.out){U=M[L];do{if(C=U.target,A=!0,x=b(R.key,C.key,R.attributes,C.attributes,U.key,U.attributes,U.undirected),s&&x)return U;U=U.next}while(U)}if(W!=="directed"){for(L in M=R.undirected)if(!(y&&R.key>L)){U=M[L];do{if((C=U.target).key!==L&&(C=U.source),A=!0,x=b(R.key,C.key,R.attributes,C.attributes,U.key,U.attributes,U.undirected),s&&x)return U;U=U.next}while(U)}}if(g&&!A&&(x=b(R.key,null,R.attributes,null,null,null,null),s&&x))return null}}function Ab(s){if(!f(s))throw new k('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in s))throw new k("Graph.import: serialized node is missing its key.");if("attributes"in s&&(!f(s.attributes)||s.attributes===null))throw new k("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function Jb(s){if(!f(s))throw new k('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in s))throw new k("Graph.import: serialized edge is missing its source.");if(!("target"in s))throw new k("Graph.import: serialized edge is missing its target.");if("attributes"in s&&(!f(s.attributes)||s.attributes===null))throw new k("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in s&&typeof s.undirected!="boolean")throw new k("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}xE.prototype.wrap=function(s){this.A===null?this.A=s:this.B===null&&(this.B=s)},xE.prototype.has=function(s){return this.A!==null&&s in this.A||this.B!==null&&s in this.B};var GE,Kb=(GE=255&Math.floor(256*Math.random()),function(){return GE++}),Ob=new Set(["directed","undirected","mixed"]),wE=new Set(["domain","_events","_eventsCount","_maxListeners"]),Pb={allowSelfLoops:!0,multi:!1,type:"mixed"};function hE(s,y,g){var E=new s.NodeDataClass(y,g);return s._nodes.set(y,E),s.emit("nodeAdded",{key:y,attributes:g}),E}function zE(s,y,g,E,b,$,R,L){if(!E&&s.type==="undirected")throw new Z("Graph.".concat(y,": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead."));if(E&&s.type==="directed")throw new Z("Graph.".concat(y,": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead."));if(L&&!f(L))throw new k("Graph.".concat(y,': invalid attributes. Expecting an object but got "').concat(L,'"'));if($=""+$,R=""+R,L=L||{},!s.allowSelfLoops&&$===R)throw new Z("Graph.".concat(y,': source & target are the same ("').concat($,`"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`));var M=s._nodes.get($),U=s._nodes.get(R);if(!M)throw new H("Graph.".concat(y,': source node "').concat($,'" not found.'));if(!U)throw new H("Graph.".concat(y,': target node "').concat(R,'" not found.'));var C={key:null,undirected:E,source:$,target:R,attributes:L};if(g)b=s._edgeKeyGenerator();else if(b=""+b,s._edges.has(b))throw new Z("Graph.".concat(y,': the "').concat(b,'" edge already exists in the graph.'));if(!s.multi&&(E?M.undirected[R]!==void 0:M.out[R]!==void 0))throw new Z("Graph.".concat(y,': an edge linking "').concat($,'" to "').concat(R,`" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`));var x=new bE(E,b,M,U,L);s._edges.set(b,x);var T=$===R;return E?(M.undirectedDegree++,U.undirectedDegree++,T&&(M.undirectedLoops++,s._undirectedSelfLoopCount++)):(M.outDegree++,U.inDegree++,T&&(M.directedLoops++,s._directedSelfLoopCount++)),s.multi?x.attachMulti():x.attach(),E?s._undirectedSize++:s._directedSize++,C.key=b,s.emit("edgeAdded",C),b}function jb(s,y,g,E,b,$,R,L,M){if(!E&&s.type==="undirected")throw new Z("Graph.".concat(y,": you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead."));if(E&&s.type==="directed")throw new Z("Graph.".concat(y,": you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead."));if(L){if(M){if(typeof L!="function")throw new k("Graph.".concat(y,': invalid updater function. Expecting a function but got "').concat(L,'"'))}else if(!f(L))throw new k("Graph.".concat(y,': invalid attributes. Expecting an object but got "').concat(L,'"'))}var U;if($=""+$,R=""+R,M&&(U=L,L=void 0),!s.allowSelfLoops&&$===R)throw new Z("Graph.".concat(y,': source & target are the same ("').concat($,`"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`));var C,x,T=s._nodes.get($),W=s._nodes.get(R);if(!g&&(C=s._edges.get(b))){if(!(C.source.key===$&&C.target.key===R||E&&C.source.key===R&&C.target.key===$))throw new Z("Graph.".concat(y,': inconsistency detected when attempting to merge the "').concat(b,'" edge with "').concat($,'" source & "').concat(R,'" target vs. ("').concat(C.source.key,'", "').concat(C.target.key,'").'));x=C}if(x||s.multi||!T||(x=E?T.undirected[R]:T.out[R]),x){var A=[x.key,!1,!1,!1];if(M?!U:!L)return A;if(M){var _=x.attributes;x.attributes=U(_),s.emit("edgeAttributesUpdated",{type:"replace",key:x.key,attributes:x.attributes})}else O(x.attributes,L),s.emit("edgeAttributesUpdated",{type:"merge",key:x.key,attributes:x.attributes,data:L});return A}L=L||{},M&&U&&(L=U(L));var w={key:null,undirected:E,source:$,target:R,attributes:L};if(g)b=s._edgeKeyGenerator();else if(b=""+b,s._edges.has(b))throw new Z("Graph.".concat(y,': the "').concat(b,'" edge already exists in the graph.'));var u=!1,z=!1;T||(T=hE(s,$,{}),u=!0,$===R&&(W=T,z=!0)),W||(W=hE(s,R,{}),z=!0),C=new bE(E,b,T,W,L),s._edges.set(b,C);var B=$===R;return E?(T.undirectedDegree++,W.undirectedDegree++,B&&(T.undirectedLoops++,s._undirectedSelfLoopCount++)):(T.outDegree++,W.inDegree++,B&&(T.directedLoops++,s._directedSelfLoopCount++)),s.multi?C.attachMulti():C.attach(),E?s._undirectedSize++:s._directedSize++,w.key=b,s.emit("edgeAdded",w),[b,!0,u,z]}function sE(s,y){s._edges.delete(y.key);var{source:g,target:E,attributes:b,undirected:$}=y,R=g===E;$?(g.undirectedDegree--,E.undirectedDegree--,R&&(g.undirectedLoops--,s._undirectedSelfLoopCount--)):(g.outDegree--,E.inDegree--,R&&(g.directedLoops--,s._directedSelfLoopCount--)),s.multi?y.detachMulti():y.detach(),$?s._undirectedSize--:s._directedSize--,s.emit("edgeDropped",{key:y.key,attributes:b,source:g.key,target:E.key,undirected:$})}var G=function(s){function y(E){var b;if(b=s.call(this)||this,typeof(E=O({},Pb,E)).multi!="boolean")throw new k(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "`.concat(E.multi,'".'));if(!Ob.has(E.type))throw new k(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "`.concat(E.type,'".'));if(typeof E.allowSelfLoops!="boolean")throw new k(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "`.concat(E.allowSelfLoops,'".'));var $=E.type==="mixed"?_E:E.type==="directed"?fE:vE;S(Q(b),"NodeDataClass",$);var R="geid_"+Kb()+"_",L=0;return S(Q(b),"_attributes",{}),S(Q(b),"_nodes",new Map),S(Q(b),"_edges",new Map),S(Q(b),"_directedSize",0),S(Q(b),"_undirectedSize",0),S(Q(b),"_directedSelfLoopCount",0),S(Q(b),"_undirectedSelfLoopCount",0),S(Q(b),"_edgeKeyGenerator",function(){var M;do M=R+L++;while(b._edges.has(M));return M}),S(Q(b),"_options",E),wE.forEach(function(M){return S(Q(b),M,b[M])}),I(Q(b),"order",function(){return b._nodes.size}),I(Q(b),"size",function(){return b._edges.size}),I(Q(b),"directedSize",function(){return b._directedSize}),I(Q(b),"undirectedSize",function(){return b._undirectedSize}),I(Q(b),"selfLoopCount",function(){return b._directedSelfLoopCount+b._undirectedSelfLoopCount}),I(Q(b),"directedSelfLoopCount",function(){return b._directedSelfLoopCount}),I(Q(b),"undirectedSelfLoopCount",function(){return b._undirectedSelfLoopCount}),I(Q(b),"multi",b._options.multi),I(Q(b),"type",b._options.type),I(Q(b),"allowSelfLoops",b._options.allowSelfLoops),I(Q(b),"implementation",function(){return"graphology"}),b}l(y,s);var g=y.prototype;return g._resetInstanceCounters=function(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0},g.hasNode=function(E){return this._nodes.has(""+E)},g.hasDirectedEdge=function(E,b){if(this.type==="undirected")return!1;if(arguments.length===1){var $=""+E,R=this._edges.get($);return!!R&&!R.undirected}if(arguments.length===2){E=""+E,b=""+b;var L=this._nodes.get(E);return!!L&&L.out.hasOwnProperty(b)}throw new k("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},g.hasUndirectedEdge=function(E,b){if(this.type==="directed")return!1;if(arguments.length===1){var $=""+E,R=this._edges.get($);return!!R&&R.undirected}if(arguments.length===2){E=""+E,b=""+b;var L=this._nodes.get(E);return!!L&&L.undirected.hasOwnProperty(b)}throw new k("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},g.hasEdge=function(E,b){if(arguments.length===1){var $=""+E;return this._edges.has($)}if(arguments.length===2){E=""+E,b=""+b;var R=this._nodes.get(E);return!!R&&(R.out!==void 0&&R.out.hasOwnProperty(b)||R.undirected!==void 0&&R.undirected.hasOwnProperty(b))}throw new k("Graph.hasEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},g.directedEdge=function(E,b){if(this.type!=="undirected"){if(E=""+E,b=""+b,this.multi)throw new Z("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");var $=this._nodes.get(E);if(!$)throw new H('Graph.directedEdge: could not find the "'.concat(E,'" source node in the graph.'));if(!this._nodes.has(b))throw new H('Graph.directedEdge: could not find the "'.concat(b,'" target node in the graph.'));var R=$.out&&$.out[b]||void 0;return R?R.key:void 0}},g.undirectedEdge=function(E,b){if(this.type!=="directed"){if(E=""+E,b=""+b,this.multi)throw new Z("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");var $=this._nodes.get(E);if(!$)throw new H('Graph.undirectedEdge: could not find the "'.concat(E,'" source node in the graph.'));if(!this._nodes.has(b))throw new H('Graph.undirectedEdge: could not find the "'.concat(b,'" target node in the graph.'));var R=$.undirected&&$.undirected[b]||void 0;return R?R.key:void 0}},g.edge=function(E,b){if(this.multi)throw new Z("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");E=""+E,b=""+b;var $=this._nodes.get(E);if(!$)throw new H('Graph.edge: could not find the "'.concat(E,'" source node in the graph.'));if(!this._nodes.has(b))throw new H('Graph.edge: could not find the "'.concat(b,'" target node in the graph.'));var R=$.out&&$.out[b]||$.undirected&&$.undirected[b]||void 0;if(R)return R.key},g.areDirectedNeighbors=function(E,b){E=""+E,b=""+b;var $=this._nodes.get(E);if(!$)throw new H('Graph.areDirectedNeighbors: could not find the "'.concat(E,'" node in the graph.'));return this.type!=="undirected"&&((b in $.in)||(b in $.out))},g.areOutNeighbors=function(E,b){E=""+E,b=""+b;var $=this._nodes.get(E);if(!$)throw new H('Graph.areOutNeighbors: could not find the "'.concat(E,'" node in the graph.'));return this.type!=="undirected"&&b in $.out},g.areInNeighbors=function(E,b){E=""+E,b=""+b;var $=this._nodes.get(E);if(!$)throw new H('Graph.areInNeighbors: could not find the "'.concat(E,'" node in the graph.'));return this.type!=="undirected"&&b in $.in},g.areUndirectedNeighbors=function(E,b){E=""+E,b=""+b;var $=this._nodes.get(E);if(!$)throw new H('Graph.areUndirectedNeighbors: could not find the "'.concat(E,'" node in the graph.'));return this.type!=="directed"&&b in $.undirected},g.areNeighbors=function(E,b){E=""+E,b=""+b;var $=this._nodes.get(E);if(!$)throw new H('Graph.areNeighbors: could not find the "'.concat(E,'" node in the graph.'));return this.type!=="undirected"&&((b in $.in)||(b in $.out))||this.type!=="directed"&&b in $.undirected},g.areInboundNeighbors=function(E,b){E=""+E,b=""+b;var $=this._nodes.get(E);if(!$)throw new H('Graph.areInboundNeighbors: could not find the "'.concat(E,'" node in the graph.'));return this.type!=="undirected"&&b in $.in||this.type!=="directed"&&b in $.undirected},g.areOutboundNeighbors=function(E,b){E=""+E,b=""+b;var $=this._nodes.get(E);if(!$)throw new H('Graph.areOutboundNeighbors: could not find the "'.concat(E,'" node in the graph.'));return this.type!=="undirected"&&b in $.out||this.type!=="directed"&&b in $.undirected},g.inDegree=function(E){E=""+E;var b=this._nodes.get(E);if(!b)throw new H('Graph.inDegree: could not find the "'.concat(E,'" node in the graph.'));return this.type==="undirected"?0:b.inDegree},g.outDegree=function(E){E=""+E;var b=this._nodes.get(E);if(!b)throw new H('Graph.outDegree: could not find the "'.concat(E,'" node in the graph.'));return this.type==="undirected"?0:b.outDegree},g.directedDegree=function(E){E=""+E;var b=this._nodes.get(E);if(!b)throw new H('Graph.directedDegree: could not find the "'.concat(E,'" node in the graph.'));return this.type==="undirected"?0:b.inDegree+b.outDegree},g.undirectedDegree=function(E){E=""+E;var b=this._nodes.get(E);if(!b)throw new H('Graph.undirectedDegree: could not find the "'.concat(E,'" node in the graph.'));return this.type==="directed"?0:b.undirectedDegree},g.inboundDegree=function(E){E=""+E;var b=this._nodes.get(E);if(!b)throw new H('Graph.inboundDegree: could not find the "'.concat(E,'" node in the graph.'));var $=0;return this.type!=="directed"&&($+=b.undirectedDegree),this.type!=="undirected"&&($+=b.inDegree),$},g.outboundDegree=function(E){E=""+E;var b=this._nodes.get(E);if(!b)throw new H('Graph.outboundDegree: could not find the "'.concat(E,'" node in the graph.'));var $=0;return this.type!=="directed"&&($+=b.undirectedDegree),this.type!=="undirected"&&($+=b.outDegree),$},g.degree=function(E){E=""+E;var b=this._nodes.get(E);if(!b)throw new H('Graph.degree: could not find the "'.concat(E,'" node in the graph.'));var $=0;return this.type!=="directed"&&($+=b.undirectedDegree),this.type!=="undirected"&&($+=b.inDegree+b.outDegree),$},g.inDegreeWithoutSelfLoops=function(E){E=""+E;var b=this._nodes.get(E);if(!b)throw new H('Graph.inDegreeWithoutSelfLoops: could not find the "'.concat(E,'" node in the graph.'));return this.type==="undirected"?0:b.inDegree-b.directedLoops},g.outDegreeWithoutSelfLoops=function(E){E=""+E;var b=this._nodes.get(E);if(!b)throw new H('Graph.outDegreeWithoutSelfLoops: could not find the "'.concat(E,'" node in the graph.'));return this.type==="undirected"?0:b.outDegree-b.directedLoops},g.directedDegreeWithoutSelfLoops=function(E){E=""+E;var b=this._nodes.get(E);if(!b)throw new H('Graph.directedDegreeWithoutSelfLoops: could not find the "'.concat(E,'" node in the graph.'));return this.type==="undirected"?0:b.inDegree+b.outDegree-2*b.directedLoops},g.undirectedDegreeWithoutSelfLoops=function(E){E=""+E;var b=this._nodes.get(E);if(!b)throw new H('Graph.undirectedDegreeWithoutSelfLoops: could not find the "'.concat(E,'" node in the graph.'));return this.type==="directed"?0:b.undirectedDegree-2*b.undirectedLoops},g.inboundDegreeWithoutSelfLoops=function(E){E=""+E;var b=this._nodes.get(E);if(!b)throw new H('Graph.inboundDegreeWithoutSelfLoops: could not find the "'.concat(E,'" node in the graph.'));var $=0,R=0;return this.type!=="directed"&&($+=b.undirectedDegree,R+=2*b.undirectedLoops),this.type!=="undirected"&&($+=b.inDegree,R+=b.directedLoops),$-R},g.outboundDegreeWithoutSelfLoops=function(E){E=""+E;var b=this._nodes.get(E);if(!b)throw new H('Graph.outboundDegreeWithoutSelfLoops: could not find the "'.concat(E,'" node in the graph.'));var $=0,R=0;return this.type!=="directed"&&($+=b.undirectedDegree,R+=2*b.undirectedLoops),this.type!=="undirected"&&($+=b.outDegree,R+=b.directedLoops),$-R},g.degreeWithoutSelfLoops=function(E){E=""+E;var b=this._nodes.get(E);if(!b)throw new H('Graph.degreeWithoutSelfLoops: could not find the "'.concat(E,'" node in the graph.'));var $=0,R=0;return this.type!=="directed"&&($+=b.undirectedDegree,R+=2*b.undirectedLoops),this.type!=="undirected"&&($+=b.inDegree+b.outDegree,R+=2*b.directedLoops),$-R},g.source=function(E){E=""+E;var b=this._edges.get(E);if(!b)throw new H('Graph.source: could not find the "'.concat(E,'" edge in the graph.'));return b.source.key},g.target=function(E){E=""+E;var b=this._edges.get(E);if(!b)throw new H('Graph.target: could not find the "'.concat(E,'" edge in the graph.'));return b.target.key},g.extremities=function(E){E=""+E;var b=this._edges.get(E);if(!b)throw new H('Graph.extremities: could not find the "'.concat(E,'" edge in the graph.'));return[b.source.key,b.target.key]},g.opposite=function(E,b){E=""+E,b=""+b;var $=this._edges.get(b);if(!$)throw new H('Graph.opposite: could not find the "'.concat(b,'" edge in the graph.'));var R=$.source.key,L=$.target.key;if(E===R)return L;if(E===L)return R;throw new H('Graph.opposite: the "'.concat(E,'" node is not attached to the "').concat(b,'" edge (').concat(R,", ").concat(L,")."))},g.hasExtremity=function(E,b){E=""+E,b=""+b;var $=this._edges.get(E);if(!$)throw new H('Graph.hasExtremity: could not find the "'.concat(E,'" edge in the graph.'));return $.source.key===b||$.target.key===b},g.isUndirected=function(E){E=""+E;var b=this._edges.get(E);if(!b)throw new H('Graph.isUndirected: could not find the "'.concat(E,'" edge in the graph.'));return b.undirected},g.isDirected=function(E){E=""+E;var b=this._edges.get(E);if(!b)throw new H('Graph.isDirected: could not find the "'.concat(E,'" edge in the graph.'));return!b.undirected},g.isSelfLoop=function(E){E=""+E;var b=this._edges.get(E);if(!b)throw new H('Graph.isSelfLoop: could not find the "'.concat(E,'" edge in the graph.'));return b.source===b.target},g.addNode=function(E,b){var $=function(R,L,M){if(M&&!f(M))throw new k('Graph.addNode: invalid attributes. Expecting an object but got "'.concat(M,'"'));if(L=""+L,M=M||{},R._nodes.has(L))throw new Z('Graph.addNode: the "'.concat(L,'" node already exist in the graph.'));var U=new R.NodeDataClass(L,M);return R._nodes.set(L,U),R.emit("nodeAdded",{key:L,attributes:M}),U}(this,E,b);return $.key},g.mergeNode=function(E,b){if(b&&!f(b))throw new k('Graph.mergeNode: invalid attributes. Expecting an object but got "'.concat(b,'"'));E=""+E,b=b||{};var $=this._nodes.get(E);return $?(b&&(O($.attributes,b),this.emit("nodeAttributesUpdated",{type:"merge",key:E,attributes:$.attributes,data:b})),[E,!1]):($=new this.NodeDataClass(E,b),this._nodes.set(E,$),this.emit("nodeAdded",{key:E,attributes:b}),[E,!0])},g.updateNode=function(E,b){if(b&&typeof b!="function")throw new k('Graph.updateNode: invalid updater function. Expecting a function but got "'.concat(b,'"'));E=""+E;var $=this._nodes.get(E);if($){if(b){var R=$.attributes;$.attributes=b(R),this.emit("nodeAttributesUpdated",{type:"replace",key:E,attributes:$.attributes})}return[E,!1]}var L=b?b({}):{};return $=new this.NodeDataClass(E,L),this._nodes.set(E,$),this.emit("nodeAdded",{key:E,attributes:L}),[E,!0]},g.dropNode=function(E){E=""+E;var b,$=this._nodes.get(E);if(!$)throw new H('Graph.dropNode: could not find the "'.concat(E,'" node in the graph.'));if(this.type!=="undirected"){for(var R in $.out){b=$.out[R];do sE(this,b),b=b.next;while(b)}for(var L in $.in){b=$.in[L];do sE(this,b),b=b.next;while(b)}}if(this.type!=="directed")for(var M in $.undirected){b=$.undirected[M];do sE(this,b),b=b.next;while(b)}this._nodes.delete(E),this.emit("nodeDropped",{key:E,attributes:$.attributes})},g.dropEdge=function(E){var b;if(arguments.length>1){var $=""+arguments[0],R=""+arguments[1];if(!(b=V(this,$,R,this.type)))throw new H('Graph.dropEdge: could not find the "'.concat($,'" -> "').concat(R,'" edge in the graph.'))}else if(E=""+E,!(b=this._edges.get(E)))throw new H('Graph.dropEdge: could not find the "'.concat(E,'" edge in the graph.'));return sE(this,b),this},g.dropDirectedEdge=function(E,b){if(arguments.length<2)throw new Z("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new Z("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");var $=V(this,E=""+E,b=""+b,"directed");if(!$)throw new H('Graph.dropDirectedEdge: could not find a "'.concat(E,'" -> "').concat(b,'" edge in the graph.'));return sE(this,$),this},g.dropUndirectedEdge=function(E,b){if(arguments.length<2)throw new Z("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new Z("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");var $=V(this,E,b,"undirected");if(!$)throw new H('Graph.dropUndirectedEdge: could not find a "'.concat(E,'" -> "').concat(b,'" edge in the graph.'));return sE(this,$),this},g.clear=function(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")},g.clearEdges=function(){for(var E,b=this._nodes.values();(E=b.next()).done!==!0;)E.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")},g.getAttribute=function(E){return this._attributes[E]},g.getAttributes=function(){return this._attributes},g.hasAttribute=function(E){return this._attributes.hasOwnProperty(E)},g.setAttribute=function(E,b){return this._attributes[E]=b,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:E}),this},g.updateAttribute=function(E,b){if(typeof b!="function")throw new k("Graph.updateAttribute: updater should be a function.");var $=this._attributes[E];return this._attributes[E]=b($),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:E}),this},g.removeAttribute=function(E){return delete this._attributes[E],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:E}),this},g.replaceAttributes=function(E){if(!f(E))throw new k("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=E,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this},g.mergeAttributes=function(E){if(!f(E))throw new k("Graph.mergeAttributes: provided attributes are not a plain object.");return O(this._attributes,E),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:E}),this},g.updateAttributes=function(E){if(typeof E!="function")throw new k("Graph.updateAttributes: provided updater is not a function.");return this._attributes=E(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this},g.updateEachNodeAttributes=function(E,b){if(typeof E!="function")throw new k("Graph.updateEachNodeAttributes: expecting an updater function.");if(b&&!EE(b))throw new k("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");for(var $,R,L=this._nodes.values();($=L.next()).done!==!0;)(R=$.value).attributes=E(R.key,R.attributes);this.emit("eachNodeAttributesUpdated",{hints:b||null})},g.updateEachEdgeAttributes=function(E,b){if(typeof E!="function")throw new k("Graph.updateEachEdgeAttributes: expecting an updater function.");if(b&&!EE(b))throw new k("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");for(var $,R,L,M,U=this._edges.values();($=U.next()).done!==!0;)L=(R=$.value).source,M=R.target,R.attributes=E(R.key,R.attributes,L.key,M.key,L.attributes,M.attributes,R.undirected);this.emit("eachEdgeAttributesUpdated",{hints:b||null})},g.forEachAdjacencyEntry=function(E){if(typeof E!="function")throw new k("Graph.forEachAdjacencyEntry: expecting a callback.");CE(!1,!1,!1,this,E)},g.forEachAdjacencyEntryWithOrphans=function(E){if(typeof E!="function")throw new k("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");CE(!1,!1,!0,this,E)},g.forEachAssymetricAdjacencyEntry=function(E){if(typeof E!="function")throw new k("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");CE(!1,!0,!1,this,E)},g.forEachAssymetricAdjacencyEntryWithOrphans=function(E){if(typeof E!="function")throw new k("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");CE(!1,!0,!0,this,E)},g.nodes=function(){return typeof Array.from=="function"?Array.from(this._nodes.keys()):VE(this._nodes.keys(),this._nodes.size)},g.forEachNode=function(E){if(typeof E!="function")throw new k("Graph.forEachNode: expecting a callback.");for(var b,$,R=this._nodes.values();(b=R.next()).done!==!0;)E(($=b.value).key,$.attributes)},g.findNode=function(E){if(typeof E!="function")throw new k("Graph.findNode: expecting a callback.");for(var b,$,R=this._nodes.values();(b=R.next()).done!==!0;)if(E(($=b.value).key,$.attributes))return $.key},g.mapNodes=function(E){if(typeof E!="function")throw new k("Graph.mapNode: expecting a callback.");for(var b,$,R=this._nodes.values(),L=new Array(this.order),M=0;(b=R.next()).done!==!0;)$=b.value,L[M++]=E($.key,$.attributes);return L},g.someNode=function(E){if(typeof E!="function")throw new k("Graph.someNode: expecting a callback.");for(var b,$,R=this._nodes.values();(b=R.next()).done!==!0;)if(E(($=b.value).key,$.attributes))return!0;return!1},g.everyNode=function(E){if(typeof E!="function")throw new k("Graph.everyNode: expecting a callback.");for(var b,$,R=this._nodes.values();(b=R.next()).done!==!0;)if(!E(($=b.value).key,$.attributes))return!1;return!0},g.filterNodes=function(E){if(typeof E!="function")throw new k("Graph.filterNodes: expecting a callback.");for(var b,$,R=this._nodes.values(),L=[];(b=R.next()).done!==!0;)E(($=b.value).key,$.attributes)&&L.push($.key);return L},g.reduceNodes=function(E,b){if(typeof E!="function")throw new k("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new k("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");for(var $,R,L=b,M=this._nodes.values();($=M.next()).done!==!0;)L=E(L,(R=$.value).key,R.attributes);return L},g.nodeEntries=function(){var E=this._nodes.values();return new p(function(){var b=E.next();if(b.done)return b;var $=b.value;return{value:{node:$.key,attributes:$.attributes},done:!1}})},g.export=function(){var E=this,b=new Array(this._nodes.size),$=0;this._nodes.forEach(function(L,M){b[$++]=function(U,C){var x={key:U};return r(C.attributes)||(x.attributes=O({},C.attributes)),x}(M,L)});var R=new Array(this._edges.size);return $=0,this._edges.forEach(function(L,M){R[$++]=function(U,C,x){var T={key:C,source:x.source.key,target:x.target.key};return r(x.attributes)||(T.attributes=O({},x.attributes)),U==="mixed"&&x.undirected&&(T.undirected=!0),T}(E.type,M,L)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:b,edges:R}},g.import=function(E){var b,$,R,L,M,U=this,C=arguments.length>1&&arguments[1]!==void 0&&arguments[1];if(E instanceof y)return E.forEachNode(function(F,i){C?U.mergeNode(F,i):U.addNode(F,i)}),E.forEachEdge(function(F,i,UE,DE,pb,cb,FE){C?FE?U.mergeUndirectedEdgeWithKey(F,UE,DE,i):U.mergeDirectedEdgeWithKey(F,UE,DE,i):FE?U.addUndirectedEdgeWithKey(F,UE,DE,i):U.addDirectedEdgeWithKey(F,UE,DE,i)}),this;if(!f(E))throw new k("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(E.attributes){if(!f(E.attributes))throw new k("Graph.import: invalid attributes. Expecting a plain object.");C?this.mergeAttributes(E.attributes):this.replaceAttributes(E.attributes)}if(E.nodes){if(R=E.nodes,!Array.isArray(R))throw new k("Graph.import: invalid nodes. Expecting an array.");for(b=0,$=R.length;b<$;b++){Ab(L=R[b]);var x=L,T=x.key,W=x.attributes;C?this.mergeNode(T,W):this.addNode(T,W)}}if(E.edges){var A=!1;if(this.type==="undirected"&&(A=!0),R=E.edges,!Array.isArray(R))throw new k("Graph.import: invalid edges. Expecting an array.");for(b=0,$=R.length;b<$;b++){Jb(M=R[b]);var _=M,w=_.source,u=_.target,z=_.attributes,B=_.undirected,o=B===void 0?A:B;"key"in M?(C?o?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:o?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey).call(this,M.key,w,u,z):(C?o?this.mergeUndirectedEdge:this.mergeDirectedEdge:o?this.addUndirectedEdge:this.addDirectedEdge).call(this,w,u,z)}}return this},g.nullCopy=function(E){var b=new y(O({},this._options,E));return b.replaceAttributes(O({},this.getAttributes())),b},g.emptyCopy=function(E){var b=this.nullCopy(E);return this._nodes.forEach(function($,R){var L=O({},$.attributes);$=new b.NodeDataClass(R,L),b._nodes.set(R,$)}),b},g.copy=function(E){if(typeof(E=E||{}).type=="string"&&E.type!==this.type&&E.type!=="mixed")throw new Z('Graph.copy: cannot create an incompatible copy from "'.concat(this.type,'" type to "').concat(E.type,'" because this would mean losing information about the current graph.'));if(typeof E.multi=="boolean"&&E.multi!==this.multi&&E.multi!==!0)throw new Z("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if(typeof E.allowSelfLoops=="boolean"&&E.allowSelfLoops!==this.allowSelfLoops&&E.allowSelfLoops!==!0)throw new Z("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");for(var b,$,R=this.emptyCopy(E),L=this._edges.values();(b=L.next()).done!==!0;)zE(R,"copy",!1,($=b.value).undirected,$.key,$.source.key,$.target.key,O({},$.attributes));return R},g.toJSON=function(){return this.export()},g.toString=function(){return"[object Graph]"},g.inspect=function(){var E=this,b={};this._nodes.forEach(function(U,C){b[C]=U.attributes});var $={},R={};this._edges.forEach(function(U,C){var x,T=U.undirected?"--":"->",W="",A=U.source.key,_=U.target.key;U.undirected&&A>_&&(x=A,A=_,_=x);var w="(".concat(A,")").concat(T,"(").concat(_,")");C.startsWith("geid_")?E.multi&&(R[w]===void 0?R[w]=0:R[w]++,W+="".concat(R[w],". ")):W+="[".concat(C,"]: "),$[W+=w]=U.attributes});var L={};for(var M in this)this.hasOwnProperty(M)&&!wE.has(M)&&typeof this[M]!="function"&&X(M)!=="symbol"&&(L[M]=this[M]);return L.attributes=this._attributes,L.nodes=b,L.edges=$,S(L,"constructor",this.constructor),L},y}(t.exports.EventEmitter);typeof Symbol!="undefined"&&(G.prototype[Symbol.for("nodejs.util.inspect.custom")]=G.prototype.inspect),[{name:function(s){return"".concat(s,"Edge")},generateKey:!0},{name:function(s){return"".concat(s,"DirectedEdge")},generateKey:!0,type:"directed"},{name:function(s){return"".concat(s,"UndirectedEdge")},generateKey:!0,type:"undirected"},{name:function(s){return"".concat(s,"EdgeWithKey")}},{name:function(s){return"".concat(s,"DirectedEdgeWithKey")},type:"directed"},{name:function(s){return"".concat(s,"UndirectedEdgeWithKey")},type:"undirected"}].forEach(function(s){["add","merge","update"].forEach(function(y){var g=s.name(y),E=y==="add"?zE:jb;s.generateKey?G.prototype[g]=function(b,$,R){return E(this,g,!0,(s.type||this.type)==="undirected",null,b,$,R,y==="update")}:G.prototype[g]=function(b,$,R,L){return E(this,g,!1,(s.type||this.type)==="undirected",b,$,R,L,y==="update")}})}),function(s){yb.forEach(function(y){var{name:g,attacher:E}=y;E(s,g("Node"),0),E(s,g("Source"),1),E(s,g("Target"),2),E(s,g("Opposite"),3)})}(G),function(s){Rb.forEach(function(y){var{name:g,attacher:E}=y;E(s,g("Edge"),"mixed"),E(s,g("DirectedEdge"),"directed"),E(s,g("UndirectedEdge"),"undirected")})}(G),function(s){xb.forEach(function(y){(function(g,E){var{name:b,type:$,direction:R}=E;g.prototype[b]=function(L,M){if($!=="mixed"&&this.type!=="mixed"&&$!==this.type)return[];if(!arguments.length)return Tb(this,$);if(arguments.length===1){L=""+L;var U=this._nodes.get(L);if(U===void 0)throw new H("Graph.".concat(b,': could not find the "').concat(L,'" node in the graph.'));return qb(this.multi,$==="mixed"?this.type:$,R,U)}if(arguments.length===2){L=""+L,M=""+M;var C=this._nodes.get(L);if(!C)throw new H("Graph.".concat(b,':  could not find the "').concat(L,'" source node in the graph.'));if(!this._nodes.has(M))throw new H("Graph.".concat(b,':  could not find the "').concat(M,'" target node in the graph.'));return Xb($,this.multi,R,C,M)}throw new k("Graph.".concat(b,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."))}})(s,y),function(g,E){var{name:b,type:$,direction:R}=E,L="forEach"+b[0].toUpperCase()+b.slice(1,-1);g.prototype[L]=function(x,T,W){if($==="mixed"||this.type==="mixed"||$===this.type){if(arguments.length===1)return SE(!1,this,$,W=x);if(arguments.length===2){x=""+x,W=T;var A=this._nodes.get(x);if(A===void 0)throw new H("Graph.".concat(L,': could not find the "').concat(x,'" node in the graph.'));return YE(!1,this.multi,$==="mixed"?this.type:$,R,A,W)}if(arguments.length===3){x=""+x,T=""+T;var _=this._nodes.get(x);if(!_)throw new H("Graph.".concat(L,':  could not find the "').concat(x,'" source node in the graph.'));if(!this._nodes.has(T))throw new H("Graph.".concat(L,':  could not find the "').concat(T,'" target node in the graph.'));return lE(!1,$,this.multi,R,_,T,W)}throw new k("Graph.".concat(L,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."))}};var M="map"+b[0].toUpperCase()+b.slice(1);g.prototype[M]=function(){var x,T=Array.prototype.slice.call(arguments),W=T.pop();if(T.length===0){var A=0;$!=="directed"&&(A+=this.undirectedSize),$!=="undirected"&&(A+=this.directedSize),x=new Array(A);var _=0;T.push(function(w,u,z,B,o,F,i){x[_++]=W(w,u,z,B,o,F,i)})}else x=[],T.push(function(w,u,z,B,o,F,i){x.push(W(w,u,z,B,o,F,i))});return this[L].apply(this,T),x};var U="filter"+b[0].toUpperCase()+b.slice(1);g.prototype[U]=function(){var x=Array.prototype.slice.call(arguments),T=x.pop(),W=[];return x.push(function(A,_,w,u,z,B,o){T(A,_,w,u,z,B,o)&&W.push(A)}),this[L].apply(this,x),W};var C="reduce"+b[0].toUpperCase()+b.slice(1);g.prototype[C]=function(){var x,T,W=Array.prototype.slice.call(arguments);if(W.length<2||W.length>4)throw new k("Graph.".concat(C,": invalid number of arguments (expecting 2, 3 or 4 and got ").concat(W.length,")."));if(typeof W[W.length-1]=="function"&&typeof W[W.length-2]!="function")throw new k("Graph.".concat(C,": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));W.length===2?(x=W[0],T=W[1],W=[]):W.length===3?(x=W[1],T=W[2],W=[W[0]]):W.length===4&&(x=W[2],T=W[3],W=[W[0],W[1]]);var A=T;return W.push(function(_,w,u,z,B,o,F){A=x(A,_,w,u,z,B,o,F)}),this[L].apply(this,W),A}}(s,y),function(g,E){var{name:b,type:$,direction:R}=E,L="find"+b[0].toUpperCase()+b.slice(1,-1);g.prototype[L]=function(C,x,T){if($!=="mixed"&&this.type!=="mixed"&&$!==this.type)return!1;if(arguments.length===1)return SE(!0,this,$,T=C);if(arguments.length===2){C=""+C,T=x;var W=this._nodes.get(C);if(W===void 0)throw new H("Graph.".concat(L,': could not find the "').concat(C,'" node in the graph.'));return YE(!0,this.multi,$==="mixed"?this.type:$,R,W,T)}if(arguments.length===3){C=""+C,x=""+x;var A=this._nodes.get(C);if(!A)throw new H("Graph.".concat(L,':  could not find the "').concat(C,'" source node in the graph.'));if(!this._nodes.has(x))throw new H("Graph.".concat(L,':  could not find the "').concat(x,'" target node in the graph.'));return lE(!0,$,this.multi,R,A,x,T)}throw new k("Graph.".concat(L,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."))};var M="some"+b[0].toUpperCase()+b.slice(1,-1);g.prototype[M]=function(){var C=Array.prototype.slice.call(arguments),x=C.pop();return C.push(function(T,W,A,_,w,u,z){return x(T,W,A,_,w,u,z)}),!!this[L].apply(this,C)};var U="every"+b[0].toUpperCase()+b.slice(1,-1);g.prototype[U]=function(){var C=Array.prototype.slice.call(arguments),x=C.pop();return C.push(function(T,W,A,_,w,u,z){return!x(T,W,A,_,w,u,z)}),!this[L].apply(this,C)}}(s,y),function(g,E){var{name:b,type:$,direction:R}=E,L=b.slice(0,-1)+"Entries";g.prototype[L]=function(M,U){if($!=="mixed"&&this.type!=="mixed"&&$!==this.type)return p.empty();if(!arguments.length)return Wb(this,$);if(arguments.length===1){M=""+M;var C=this._nodes.get(M);if(!C)throw new H("Graph.".concat(L,': could not find the "').concat(M,'" node in the graph.'));return kb($,R,C)}if(arguments.length===2){M=""+M,U=""+U;var x=this._nodes.get(M);if(!x)throw new H("Graph.".concat(L,':  could not find the "').concat(M,'" source node in the graph.'));if(!this._nodes.has(U))throw new H("Graph.".concat(L,':  could not find the "').concat(U,'" target node in the graph.'));return Yb($,R,x,U)}throw new k("Graph.".concat(L,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."))}}(s,y)})}(G),function(s){lb.forEach(function(y){Qb(s,y),function(g,E){var{name:b,type:$,direction:R}=E,L="forEach"+b[0].toUpperCase()+b.slice(1,-1);g.prototype[L]=function(x,T){if($==="mixed"||this.type==="mixed"||$===this.type){x=""+x;var W=this._nodes.get(x);if(W===void 0)throw new H("Graph.".concat(L,': could not find the "').concat(x,'" node in the graph.'));QE(!1,$==="mixed"?this.type:$,R,W,T)}};var M="map"+b[0].toUpperCase()+b.slice(1);g.prototype[M]=function(x,T){var W=[];return this[L](x,function(A,_){W.push(T(A,_))}),W};var U="filter"+b[0].toUpperCase()+b.slice(1);g.prototype[U]=function(x,T){var W=[];return this[L](x,function(A,_){T(A,_)&&W.push(A)}),W};var C="reduce"+b[0].toUpperCase()+b.slice(1);g.prototype[C]=function(x,T,W){if(arguments.length<3)throw new k("Graph.".concat(C,": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));var A=W;return this[L](x,function(_,w){A=T(A,_,w)}),A}}(s,y),function(g,E){var{name:b,type:$,direction:R}=E,L=b[0].toUpperCase()+b.slice(1,-1),M="find"+L;g.prototype[M]=function(x,T){if($==="mixed"||this.type==="mixed"||$===this.type){x=""+x;var W=this._nodes.get(x);if(W===void 0)throw new H("Graph.".concat(M,': could not find the "').concat(x,'" node in the graph.'));return QE(!0,$==="mixed"?this.type:$,R,W,T)}};var U="some"+L;g.prototype[U]=function(x,T){return!!this[M](x,T)};var C="every"+L;g.prototype[C]=function(x,T){return!this[M](x,function(W,A){return!T(W,A)})}}(s,y),Zb(s,y)})}(G);var uE=function(s){function y(g){var E=O({type:"directed"},g);if("multi"in E&&E.multi!==!1)throw new k("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(E.type!=="directed")throw new k('DirectedGraph.from: inconsistent "'+E.type+'" type in given options!');return s.call(this,E)||this}return l(y,s),y}(G),IE=function(s){function y(g){var E=O({type:"undirected"},g);if("multi"in E&&E.multi!==!1)throw new k("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(E.type!=="undirected")throw new k('UndirectedGraph.from: inconsistent "'+E.type+'" type in given options!');return s.call(this,E)||this}return l(y,s),y}(G),pE=function(s){function y(g){var E=O({multi:!0},g);if("multi"in E&&E.multi!==!0)throw new k("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");return s.call(this,E)||this}return l(y,s),y}(G),cE=function(s){function y(g){var E=O({type:"directed",multi:!0},g);if("multi"in E&&E.multi!==!0)throw new k("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(E.type!=="directed")throw new k('MultiDirectedGraph.from: inconsistent "'+E.type+'" type in given options!');return s.call(this,E)||this}return l(y,s),y}(G),BE=function(s){function y(g){var E=O({type:"undirected",multi:!0},g);if("multi"in E&&E.multi!==!0)throw new k("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(E.type!=="undirected")throw new k('MultiUndirectedGraph.from: inconsistent "'+E.type+'" type in given options!');return s.call(this,E)||this}return l(y,s),y}(G);function gE(s){s.from=function(y,g){var E=O({},y.options,g),b=new s(E);return b.import(y),b}}return gE(G),gE(uE),gE(IE),gE(pE),gE(cE),gE(BE),G.Graph=G,G.DirectedGraph=uE,G.UndirectedGraph=IE,G.MultiGraph=pE,G.MultiDirectedGraph=cE,G.MultiUndirectedGraph=BE,G.InvalidArgumentsGraphError=k,G.NotFoundGraphError=H,G.UsageGraphError=Z,G})});function oE(X,l){X=X.trim(),X=X.replace(/<!--[\s\S]*?-->/g,"");let P={declaration:void 0,root:void 0};P.declaration=Q();let j=X.match(/<!\[CDATA\[[\s\S]*?\]\]>/gm);if(j)for(let Y of j)X=X.replace(Y,J(Y));let m=O(X);if(m)if(m.children.length===1&&typeof m.children[0]!=="string")P.root=m.children[0];else throw new Error("XML1");if(P.root&&l===!0)c(P.root);return P;function J(Y){return`<![CDATA[${Y.split("<![CDATA[")[1].split("]]>")[0].replace(/</,"[_*[$(<)$]*_]").replace(/>/,"[_*[$(>)$]*_]").replace(/\//,"[_*[$(/)$]*_]").replace(/\\/,"[_*[$(LS)$]*_]")}]]>`}function N(Y){let K=Y.match(/<!\[CDATA\[[\s\S]*?\]\]>/gm);if(K)for(let D of K){let q=D.split("<![CDATA[")[1].split("]]>")[0].replace(/\[_\*\[\$\(<\)\$\]\*\_]/,"<").replace(/\[_\*\[\$\(>\)\$\]\*_]/,">").replace(/\[_\*\[\$\(\/\)\$\]\*_]/,"/").replace(/\[_\*\[\$\(LS\)\$\]\*_]/,"\\");Y=Y.replace(D,`<![CDATA[${q}]]>`)}return Y}function Q(){let Y="",K=X.match(/^<\?xml[\s\S]*\?>/m);if(!K)return;else Y=K[0],X=X.slice(Y.length);let D={name:""};if(h(Y,D),D.attributes)return{attributes:D.attributes};return}function O(Y){let K=[],D=!0;while(D){let q=S(Y);if(!q)D=!1;else{let v="",d=void 0;if(q.type==="selfClose")v=q.str,d=V(v,q.name,!0);if(q.type==="normal")v=q.strs.outer,d=V(q.strs,q.name,!1);if(d)K.push(d);Y=Y.replace(v,"")}}if(Y=Y.replace(/[\r\n]/g,"").trim(),K.length===0)return;else return{children:K,strLeft:Y}}function V(Y,K,D){let q={name:K};if(D===!0)f(Y,q);else r(Y,q);return q}function f(Y,K){h(Y,K)}function r(Y,K){h(Y.attrs,K);let D=Y.inner;if(D.match(/<(?<tag>[\w:]+)([^<^>])*?\/>/m)||D.match(/<(?<tag>[\w:]+)[\s\S]*?>[\s\S]*?<\/\k<tag>*?>/m)){let q=O(D);if(q){if(q.children&&q.children.length>0)K.children=q.children;if(q.strLeft!=="")q.strLeft=q.strLeft.replace(/[\r\n]/g,"").trim(),K.content=N(q.strLeft)}}else if(D!=="")D=D.replace(/[\r\n]/g,"").trim(),K.content=N(D)}function S(Y){let K=Y.match(/<([\w-:.]+)\s*/m);if(!K)return;else{let D=K[1],q=I(Y,D);if(q)return{type:"selfClose",name:D,str:q};let v=EE(Y,D);if(v)return{type:"normal",name:D,strs:v};return}}function I(Y,K){let D=new RegExp(`<${K}[^<^>]*?/>`,"m"),q=Y.match(D);if(!q)return;else return q[0]}function EE(Y,K){let q=new RegExp(`<${K}([\\s\\S]*?)>([\\s\\S]*?)</${K}>`,"gm").exec(Y);if(!q)return;else return{outer:q[0],attrs:q[1],inner:q[2]}}function h(Y,K){let D=!0;while(D){let q=Y.match(/([\w:-]+)\s*=\s*("[^"]*"|'[^']*'|\w+)\s*/);if(!q)D=!1;else{if(!K.attributes)K.attributes={};K.attributes[q[1]]=t(q[2]),Y=Y.replace(q[0],"")}}}function t(Y){return Y.replace(/^['"]|['"]$/g,"")}function c(Y,K){let D={};if(K)for(let q of Object.keys(K))D[q]=K[q];if(Y.attributes){let q=Object.keys(Y.attributes);for(let v of q){if(v==="xmlns")D._=Y.attributes[v];if(v.indexOf("xmlns:")===0){let d=v.replace("xmlns:","");D[d]=Y.attributes[v]}}}if(Y.name.indexOf(":")<0){if(D._)Y.name=D._+Y.name}else if(Y.name.indexOf(":")>0&&Y.name.split(":")[0]!=="http"&&Y.name.split(":")[0]!=="https"){let q=Y.name.split(":")[0];if(D[q])Y.name=Y.name.replace(`${q}:`,`${D[q]}`)}if(Y.children)for(let q of Y.children)c(q,D)}}var Sb=async(X)=>{try{let l=await fetch(X);if(!l.ok)throw new Error(`Network response was not ok, status: ${l.status}`);return await l.text()}catch(l){console.error("There was a problem with the fetch operation:",l)}},iE=async(X)=>{let l=await Sb(X);if(!l)throw new Error("Could not get XML contents.");return oE(l)};var rE=fb(aE(),1),nE=(X)=>{let l=new rE.default({multi:!0}),P={};for(let j of X){let{id:m,source:J,target:N,value:Q,edge:O,style:V}=j.attributes||{},f=V&&V.startsWith("edgeLabel");if(!O&&!f&&Q!==void 0&&J===void 0&&N===void 0)l.addNode(m,{label:Q,style:V})}for(let j of X){let{id:m,source:J,target:N,value:Q,edge:O}=j.attributes||{};if(O&&J!==void 0&&N!==void 0){if(Q!==null)l.addEdgeWithKey(m,J,N,{label:Q});else l.addEdgeWithKey(m,J,N);P[m]=m}}for(let j of X){let{parent:m,value:J,style:N}=j.attributes||{};if(N&&N.startsWith("edgeLabel")&&m!==void 0&&J!==void 0&&m in P)l.setEdgeAttribute(m,"label",J),console.log(m,J)}return l};var JE=(X)=>{let l=[["amp","&"],["apos","'"],["#x27","'"],["#x2F","/"],["#39","'"],["#47","/"],["lt","<"],["gt",">"],["nbsp"," "],["quot",'"']];for(var P=0,j=l.length;P<j;++P)X=X.replace(new RegExp("&"+l[P][0]+";","g"),l[P][1]);return X};var HE=(X)=>JE(X.trim()).replace(/<\/?div>/g,`
`).replaceAll("<br>",`
`),Gb=(X)=>{let P=/image=([^;]+)/.exec(X),j=P?P[1]:null;if(!j)return"";let J=/alt=([^;]+)/.exec(X),N=J?J[1]:"Zark image",Q="",V=/zarbAssetWidth=([^;]+)/.exec(X),f=V?V[1]:null;return Q+=`width: ${f};`,`<img src="${j.startsWith("https://")?j:"https://"+j}" alt="${N}" style="${Q}">`},eE=(X)=>{let l={},P=X.split(`
`);for(let j=0;j<P.length;j++){let m=P[j].trim();if(m==="")continue;let J=m.split(":");if(J.length!==2){console.warn(`Hey Squambo, line ${j} of the following dict string has an invalid syntax!`,X);continue}let[N,Q]=J;N=N.trim(),Q=Q.trim();let O=Q==="true",V=parseFloat(Q);if(O||Q==="false")l[N]=O;else if(!Number.isNaN(V))l[N]=V;else l[N]=Q}return l},KE=(X,l)=>{let P=document.createElement("button");return P.style.display="block",P.tabIndex=0,P.innerHTML=`&gt; ${X}`,P.className="zark-option",P.addEventListener("click",l),P},wb=(X)=>{X=HE(X);let l=(N)=>!0,P=X,j=/<!if:(?<conditionText>.*?)>/,J=X.match(j)?.groups?.conditionText;if(J){P=X.replace(j,"");let N=J.indexOf("items:");if(N>=0)l=(Q)=>{return console.log(Q.items,{conditionText:J,optionText:P},J.substring(N+6)),J.substring(N+6)in Q.items}}return{condition:l,optionText:P}},tE=(X)=>{let l=document.getElementById("game-container"),P=document.getElementById("current-node"),j=document.getElementById("value"),m=document.getElementById("decisions"),J={currentNode:[...X.nodes()][0],items:{},equppedItems:[],playerHealth:100,baseAttack:2,enemy:void 0},N={};return X.forEachNode((Q,O)=>{let{label:V,style:f}=O;if(!V||!f)return;if(!(f.indexOf("rhombus")>=0&&V.indexOf("GOTO:")<0))return;let S=HE(V);N[S]=Q}),function Q(){if(!l||!P||!j||!m)throw new Error("Did not find expected DOM elements.");let O=X.getNodeAttribute(J.currentNode,"label"),V=X.getNodeAttribute(J.currentNode,"style"),f=!0,r=!1;if(V.indexOf("rhombus")>=0)f=!1,r=!0;let S=JE(O),I=O.indexOf("GOTO:");if(I>=0){let D=O.substring(I+5).trim(),q=D in N&&N[D];if(q&&X.hasNode(q)){J.currentNode=q,Q();return}else console.log(`Psst, hey Squambo. The user just tried to go to "${D}", which gave node "${q}".`)}let EE=O.indexOf("ITEM:");if(EE>=0){let D=eE(HE(O.substring(EE+5)));S=`You got a ${D.name.toUpperCase()}.<br>`,S+='<div class="zarkbox">';for(let q in D)S+=`${q.toUpperCase()}: ${D[q]}<br>`;S+="</div>",J.items[D.name]=D}let h=J.enemy,t=O.indexOf("ENEMY:");if(h===void 0&&t>=0)h=eE(HE(O.substring(t+6))),J.enemy=h;if(h!==void 0)if(h.health<=0)S=`Excellent, you defeated the ${h.name}`,J.enemy=h=void 0;else{S=`Holy shit it's a fuckign ${h.name.toUpperCase()}.<br>`,S+='<div class="zarkbox">';for(let v in h)S+=`${v.toUpperCase()}: ${h[v]}<br>`;S+="</div>",m.innerHTML="";let D=KE("ATTACK",()=>{h.health-=J.baseAttack,Q()});m.appendChild(D);let q=KE("DODGE",()=>{});m.appendChild(q)}if(f)j.innerHTML=S,j.innerHTML+=Gb(V);if(h!==void 0)return;let c=Array.from(X.outNeighbors(J.currentNode)),Y=X.outEdges(J.currentNode);if(c.length===0){j.innerHTML+="<p>[That's all for now.]</p>",m.innerHTML="";return}m.innerHTML="<p>Decisions:</p>";let K=!0;if(Y.forEach((D)=>{let q=X.getEdgeAttributes(D),v=X.target(D),d="label"in q&&q.label,RE=d?q.label:v,{optionText:TE,condition:LE}=wb(RE);if(!LE(J))return;K=K&&!d;let ME=KE(TE,()=>{J.currentNode=v,Q()});m.appendChild(ME)}),K){let D=Math.floor(Math.random()*c.length),q=c[D];if(r){J.currentNode=q,Q();return}m.innerHTML="<p>Decisions:</p>";let v=document.createElement("button");v.tabIndex=0,v.innerHTML="&gt; The only option is to continue...",v.addEventListener("click",()=>{J.currentNode=q,Q()}),m.appendChild(v)}}};var hb="assets/ZARK.drawio.xml",zb=await iE(hb),Eb=zb.root?.children[0].children[0].children[0].children;if(!Eb)throw new Error("The tree did not have the expected format.");var ub=nE(Eb),Ib=tE(ub);Ib();
